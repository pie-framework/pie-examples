"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Wrapper_js_1 = require("../Wrapper.js");
var mtable_js_1 = require("../../common/Wrappers/mtable.js");
var mtable_js_2 = require("../../../core/MmlTree/MmlNodes/mtable.js");
var WFUZZ = .25;
var SVGmtable = (function (_super) {
    __extends(SVGmtable, _super);
    function SVGmtable(factory, node, parent) {
        if (parent === void 0) { parent = null; }
        var _this = _super.call(this, factory, node, parent) || this;
        _this.labels = _this.svg('g', { transform: 'matrix(1 0 0 -1 0 0)' });
        return _this;
    }
    SVGmtable.prototype.toSVG = function (parent) {
        var svg = this.standardSVGnode(parent);
        this.placeRows(svg);
        this.handleColumnLines(svg);
        this.handleRowLines(svg);
        this.handleFrame(svg);
        this.handleLabels(svg, parent);
    };
    SVGmtable.prototype.placeRows = function (svg) {
        var equal = this.node.attributes.get('equalrows');
        var _a = this.getTableData(), H = _a.H, D = _a.D;
        var HD = this.getEqualRowHeight();
        var rSpace = this.getRowHalfSpacing();
        var rLines = __spread([this.fLine], this.rLines, [this.fLine]);
        var y = this.getBBox().h - rLines[0];
        for (var i = 0; i < this.numRows; i++) {
            var row = this.childNodes[i];
            _b = __read(this.getRowHD(equal, HD, H[i], D[i]), 2), row.H = _b[0], row.D = _b[1];
            _c = __read([rSpace[i], rSpace[i + 1]], 2), row.tSpace = _c[0], row.bSpace = _c[1];
            _d = __read([rLines[i], rLines[i + 1]], 2), row.tLine = _d[0], row.bLine = _d[1];
            row.toSVG(svg);
            row.place(0, y - rSpace[i] - row.H);
            y -= rSpace[i] + row.H + row.D + rSpace[i + 1] + rLines[i + 1];
        }
        var _b, _c, _d;
    };
    SVGmtable.prototype.getRowHD = function (equal, HD, H, D) {
        return (equal ? [(HD + H - D) / 2, (HD - H + D) / 2] : [H, D]);
    };
    SVGmtable.prototype.handleColumnLines = function (svg) {
        if (this.node.attributes.get('columnlines') === 'none')
            return;
        var lines = this.getColumnAttributes('columnlines');
        if (!lines)
            return;
        var cSpace = this.getColumnHalfSpacing();
        var cLines = this.cLines;
        var cWidth = this.getComputedWidths();
        var x = this.fLine;
        for (var i = 0; i < lines.length; i++) {
            x += cSpace[i] + cWidth[i] + cSpace[i + 1];
            this.adaptor.append(svg, this.makeVLine(x, lines[i]));
            x += cLines[i];
        }
    };
    SVGmtable.prototype.handleRowLines = function (svg) {
        if (this.node.attributes.get('rowlines') === 'none')
            return;
        var lines = this.getRowAttributes('rowlines');
        if (!lines)
            return;
        var equal = this.node.attributes.get('equalrows');
        var _a = this.getTableData(), H = _a.H, D = _a.D;
        var HD = this.getEqualRowHeight();
        var rSpace = this.getRowHalfSpacing();
        var rLines = this.rLines;
        var y = this.getBBox().h - this.fLine;
        for (var i = 0; i < lines.length; i++) {
            var _b = __read(this.getRowHD(equal, HD, H[i], D[i]), 2), rH = _b[0], rD = _b[1];
            y -= rSpace[i] + rH + rD + rSpace[i + 1];
            this.adaptor.append(svg, this.makeHLine(y, lines[i]));
            y -= rLines[i];
        }
    };
    SVGmtable.prototype.handleFrame = function (svg) {
        if (this.frame) {
            var _a = this.getBBox(), h = _a.h, d = _a.d, w = _a.w;
            var style = this.node.attributes.get('frame');
            this.adaptor.append(svg, this.makeFrame(w, h, d, style));
        }
    };
    SVGmtable.prototype.makeFrame = function (w, h, d, style) {
        var properties = {
            'data-frame': true,
            width: this.fixed(w), height: this.fixed(h + d), y: this.fixed(-d)
        };
        if (style !== 'solid') {
            properties.style = { 'outline-style': style };
        }
        return this.svg('rect', properties);
    };
    SVGmtable.prototype.makeVLine = function (x, style) {
        var _a = this.getBBox(), h = _a.h, d = _a.d;
        var p = (style === 'dashed' || style === 'dotted' || style === 'solid' ? 0 : .07);
        var properties = {
            width: this.fixed(.07 + 2 * p), height: this.fixed(h + d + 2 * p),
            x: this.fixed(x), y: this.fixed(-d - p), 'data-line': 'v'
        };
        if (style !== 'solid') {
            properties.style = { 'outline-style': style };
        }
        if (p) {
            properties['clip-path'] = 'inset(70 130 70 0)';
        }
        return this.svg('rect', properties);
    };
    SVGmtable.prototype.makeHLine = function (y, style) {
        var w = this.getBBox().w;
        var p = (style === 'dashed' || style === 'dotted' || style === 'solid' ? 0 : .07);
        var properties = {
            width: this.fixed(w + 2 * p), height: this.fixed(.07 + 2 * p),
            y: this.fixed(y - .07), 'data-line': 'h'
        };
        if (style !== 'solid') {
            properties.style = { 'outline-style': style };
        }
        if (p) {
            properties['clip-path'] = 'inset(0 70 130 70)';
            properties['x'] = this.fixed(-p);
        }
        return this.svg('rect', properties);
    };
    SVGmtable.prototype.getColumnWidthsPercent = function (swidths, width) {
        var W = this.length2em(width, this.metrics.containerWidth / this.metrics.em);
        return this.getColumnWidthsFixed(swidths, W);
    };
    SVGmtable.prototype.handleLabels = function (svg, parent) {
        var labels = this.labels;
        var attributes = this.node.attributes;
        var adaptor = this.adaptor;
        if (adaptor.childNodes(labels).length === 0)
            return;
        var side = attributes.get('side');
        var L = this.getTableData().L;
        var sep = this.length2em(attributes.get('minlabelspacing'));
        var pad = L + sep;
        var _a = __read((this.styles == null ? ['', ''] :
            [this.styles.get('padding-left'), this.styles.get('padding-right')]), 2), lpad = _a[0], rpad = _a[1];
        if (lpad || rpad) {
            pad = Math.max(pad, this.length2em(lpad || '0'), this.length2em(rpad || '0'));
        }
        var _b = __read(this.getAlignShift(), 2), align = _b[0], shift = _b[1];
        if (align === side) {
            shift = (side === 'left' ? Math.max(pad, shift) - pad : Math.min(-pad, shift) + pad);
        }
        this.placeLabels();
        this.nestTable(svg, labels, side, align, pad, shift);
    };
    SVGmtable.prototype.placeLabels = function () {
        var adaptor = this.adaptor;
        var equal = this.node.attributes.get('equalrows');
        var _a = this.getBBox(), h = _a.h, d = _a.d;
        var L = this.getTableData().L;
        var space = this.getRowHalfSpacing();
        var y = h - this.fLine;
        var current = adaptor.firstChild(this.labels);
        for (var i = 0; i < this.numRows; i++) {
            var row = this.childNodes[i];
            if (row.node.isKind('mlabeledtr')) {
                var cell = row.childNodes[0];
                y -= space[i] + row.H;
                row.placeCell(cell, { x: 0, y: y, w: L, lSpace: 0, rSpace: 0, lLine: 0, rLine: 0 });
                y -= row.D + space[i + 1] + this.rLines[i];
                current = adaptor.next(current);
            }
            else {
                y -= space[i] + row.H + row.D + space[i + 1] + this.rLines[i];
            }
        }
    };
    SVGmtable.prototype.nestTable = function (svg, labels, side, align, pad, shift) {
        var adaptor = this.adaptor;
        var _a = this.getBBox(), h = _a.h, d = _a.d, w = _a.w;
        var L = this.getTableData().L;
        var _b = __read((side === align ? [side === 'left' ? -pad : 0, pad] : [0, 0]), 2), x = _b[0], dw = _b[1];
        var translate = (shift ? 'translate(' + this.fixed(shift) + ' 0)' : '');
        var table = this.svg('svg', {
            'data-table': true,
            preserveAspectRatio: (align === 'left' ? 'xMinYMid' : align === 'right' ? 'xMaxYMid' : 'xMidYMid'),
            viewBox: [this.fixed(x), this.fixed(-h), this.fixed(w + dw), this.fixed(h + d)].join(' ')
        }, [this.svg('g', { transform: 'matrix(1 0 0 -1 0 0)' + translate }, adaptor.childNodes(svg))]);
        labels = this.svg('svg', {
            'data-labels': true,
            preserveAspectRatio: (side === 'left' ? 'xMinYMid' : 'xMaxYMid'),
            viewBox: [0, this.fixed(-h), this.fixed(L), this.fixed(h + d)].join(' ')
        }, [labels]);
        this.jax.minwidth = w + pad + (align === 'center' ? pad : 0) + WFUZZ;
        adaptor.append(svg, table);
        adaptor.append(svg, labels);
    };
    return SVGmtable;
}(mtable_js_1.CommonMtableMixin(Wrapper_js_1.SVGWrapper)));
SVGmtable.kind = mtable_js_2.MmlMtable.prototype.kind;
SVGmtable.styles = {
    'g[data-mml-node="mtable"] rect[data-line]': {
        'outline-style': 'solid',
        'outline-width': '70px',
        'outline-offset': '-70px',
        fill: 'none'
    },
    'g[data-mml-node="mtable"] rect[data-frame]': {
        'outline-style': 'solid',
        'outline-width': '70px',
        'outline-offset': '-70px',
        fill: 'none'
    }
};
exports.SVGmtable = SVGmtable;
//# sourceMappingURL=mtable.js.map