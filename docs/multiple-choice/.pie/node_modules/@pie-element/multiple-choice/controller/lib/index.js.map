{"version":3,"sources":["../src/index.js"],"names":["model","outcome","log","prepareChoice","mode","defaultFeedback","choice","out","label","value","correct","feedbackType","feedback","type","question","session","env","Promise","resolve","reject","Object","assign","incorrect","choices","map","disabled","prompt","choiceMode","keyMode","complete","min","filter","c","length","responseCorrect","undefined","isCorrect","normalize","n","max","Math","scoreFromRule","rule","fallback","Number","isFinite","scorePercentage","config","maxScore","chosen","find","v","correctAndNotChosen","incorrectAndChosen","correctCount","reduce","total","partialScoring","score","scoreString","toFixed","parseFloat"],"mappings":"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","file":"index.js","sourcesContent":["import { isResponseCorrect } from './utils';\nimport debug from 'debug';\n\nconst log = debug('pie-elements:multiple-choice:controller');\n\nconst prepareChoice = (mode, defaultFeedback) => choice => {\n  const out = {\n    label: choice.label,\n    value: choice.value\n  };\n\n  if (mode == 'evaluate') {\n    out.correct = !!choice.correct;\n\n    const feedbackType = (choice.feedback && choice.feedback.type) || 'none';\n\n    if (feedbackType === 'default') {\n      out.feedback = defaultFeedback[choice.correct ? 'correct' : 'incorrect'];\n    } else if (feedbackType === 'custom') {\n      out.feedback = choice.feedback.value;\n    }\n  }\n\n  return out;\n};\n\nexport function model(question, session, env) {\n  return new Promise((resolve, reject) => {\n    const defaultFeedback = Object.assign(\n      { correct: 'Correct', incorrect: 'Incorrect' },\n      question.defaultFeedback\n    );\n    const choices = question.choices.map(\n      prepareChoice(env.mode, defaultFeedback)\n    );\n\n    const out = {\n      disabled: env.mode !== 'gather',\n      mode: env.mode,\n      prompt: question.prompt,\n      choiceMode: question.choiceMode,\n      keyMode: question.keyMode,\n      choices,\n\n      //TODO: ok to return this in gather mode? gives a clue to how many answers are needed?\n      complete: {\n        min: question.choices.filter(c => c.correct).length\n      },\n      responseCorrect:\n        env.mode === 'evaluate'\n          ? isResponseCorrect(question, session)\n          : undefined\n    };\n\n    resolve(out);\n  });\n}\n\nconst isCorrect = c => c.correct === true;\n\nconst normalize = (n, min, max) => Math.max(min, Math.min(max, n));\n\nexport const scoreFromRule = (rule, fallback) => {\n  if (!rule || !Number.isFinite(rule.scorePercentage)) {\n    return fallback;\n  }\n  return normalize(rule.scorePercentage, 0, 100) * 0.01;\n};\n\nexport function outcome(config, session, env) {\n  return new Promise((resolve, reject) => {\n    log('outcome...');\n    const maxScore = config.choices.length;\n\n    const chosen = c => !!(session.value || []).find(v => v === c.value);\n    const correctAndNotChosen = c => isCorrect(c) && !chosen(c);\n    const incorrectAndChosen = c => !isCorrect(c) && chosen(c);\n    const correctCount = config.choices.reduce((total, choice) => {\n      if (correctAndNotChosen(choice) || incorrectAndChosen(choice)) {\n        return total - 1;\n      } else {\n        return total;\n      }\n    }, config.choices.length);\n\n    if (!config.partialScoring && correctCount < maxScore) {\n      resolve({ score: 0 });\n    } else {\n      const scoreString = ( correctCount / config.choices.length ).toFixed(2);\n\n      resolve( {score: parseFloat( scoreString ) });\n    }\n  });\n}\n"]}