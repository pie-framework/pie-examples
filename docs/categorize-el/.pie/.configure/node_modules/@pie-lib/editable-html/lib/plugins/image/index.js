'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serialization = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = ImagePlugin;

var _slate = require('slate');

var _Image = require('@material-ui/icons/Image');

var _Image2 = _interopRequireDefault(_Image);

var _component = require('./component');

var _component2 = _interopRequireDefault(_component);

var _imageToolbar = require('./image-toolbar');

var _imageToolbar2 = _interopRequireDefault(_imageToolbar);

var _insertImageHandler = require('./insert-image-handler');

var _insertImageHandler2 = _interopRequireDefault(_insertImageHandler);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('@pie-lib:editable-html:plugins:image');

function ImagePlugin(opts) {
  var toolbar = opts.insertImageRequested && {
    icon: _react2.default.createElement(_Image2.default, null),
    onClick: function onClick(value, onChange) {
      log('[toolbar] onClick');
      var inline = _slate.Inline.create({
        type: 'image',
        isVoid: true,
        data: {
          loaded: false,
          src: undefined
        }
      });

      var change = value.change().insertInline(inline);
      onChange(change);
      opts.insertImageRequested(function (getValue) {
        return new _insertImageHandler2.default(inline, getValue, onChange);
      });
    },
    supports: function supports(node) {
      return node.object === 'inline' && node.type === 'image';
    },
    customToolbar: function customToolbar(node, value, onToolbarDone) {
      var percent = node.data.get('resizePercent');

      var onChange = function onChange(resizePercent) {
        var update = _extends({}, node.data.toObject(), {
          resizePercent: resizePercent
        });

        var change = value.change().setNodeByKey(node.key, { data: update });
        onToolbarDone(change, false);
      };

      var Tb = function Tb() {
        return _react2.default.createElement(_imageToolbar2.default, { percent: percent || 100, onChange: onChange });
      };
      return Tb;
    },
    showDone: true
  };

  return {
    toolbar: toolbar,
    deleteNode: function deleteNode(e, node, value, onChange) {
      e.preventDefault();
      if (opts.onDelete) {
        var update = node.data.merge(_slate.Data.create({ deleteStatus: 'pending' }));

        var change = value.change().setNodeByKey(node.key, { data: update });

        onChange(change);
        opts.onDelete(node.data.get('src'), function (err, v) {
          if (!err) {
            change = v.change().removeNodeByKey(node.key);
          } else {
            log('[error]: ', err);
            change = v.change().setNodeByKey(node.key, node.data.merge(_slate.Data.create({ deleteStatus: 'failed' })));
          }
          onChange(change);
        });
      } else {
        var _change = value.change().removeNodeByKey(node.key);
        onChange(_change);
      }
    },
    stopReset: function stopReset(value) {
      var imgPendingInsertion = value.document.findDescendant(function (n) {
        if (n.type !== 'image') {
          return;
        }
        return n.data.get('loaded') === false;
      });
      /** don't reset if there is an image pending insertion */
      return imgPendingInsertion !== undefined && imgPendingInsertion !== null;
    },
    renderNode: function renderNode(props) {
      if (props.node.type === 'image') {
        var all = Object.assign({
          onDelete: opts.onDelete,
          onFocus: opts.onFocus,
          onBlur: opts.onBlur
        }, props);
        return _react2.default.createElement(_component2.default, all);
      }
    },

    normalizeNode: function normalizeNode(node) {
      var textNodeMap = {};
      var updateNodesArray = [];
      var index = 0;

      if (node.object !== 'document') return;

      node.findDescendant(function (d) {
        if (d.object === 'text') {
          textNodeMap[index] = d;
        }

        if (d.type === 'image') {
          if (index > 0 && textNodeMap[index - 1] && textNodeMap[index - 1].text === '') {
            updateNodesArray.push(textNodeMap[index - 1]);
          }
        }

        index++;
      });

      if (!updateNodesArray.length) return;

      return function (change) {
        change.withoutNormalization(function () {
          updateNodesArray.forEach(function (n) {
            return change.insertTextByKey(n.key, 0, ' ');
          });
        });
      };
    }
  };
}

var serialization = exports.serialization = {
  deserialize: function deserialize(el /*, next*/) {
    var name = el.tagName.toLowerCase();
    if (name !== 'img') return;

    log('deserialize: ', name);
    var style = el.style || { width: '', height: '' };
    var width = parseInt(style.width.replace('px', ''), 10) || null;
    var height = parseInt(style.height.replace('px', ''), 10) || null;

    var out = {
      object: 'inline',
      type: 'image',
      isVoid: true,
      data: {
        src: el.getAttribute('src'),
        width: width,
        height: height
      }
    };
    log('return object: ', out);
    return out;
  },
  serialize: function serialize(object /*, children*/) {
    if (object.type !== 'image') return;

    var data = object.data;

    var src = data.get('src');
    var width = data.get('width');
    var height = data.get('height');
    var style = {};
    if (width) {
      style.width = width + 'px';
    }

    if (height) {
      style.height = height + 'px';
    }

    var props = {
      src: src,
      style: style
    };

    return _react2.default.createElement('img', props);
  }
};