'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildState = exports.moveChoiceToCategory = exports.removeChoiceFromCategory = exports.removeAllChoices = exports.removeCategory = exports.countChosen = exports.countInChoices = exports.countInAnswer = exports.ensureNoExtraChoicesInAnswer = exports.limitInArray = exports.limitInArrays = exports.limitChoices = exports.score = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _compact = require('lodash/compact');

var _compact2 = _interopRequireDefault(_compact);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

var _remove = require('lodash/remove');

var _remove2 = _interopRequireDefault(_remove);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _every = require('lodash/every');

var _every2 = _interopRequireDefault(_every);

var _scoring = require('./scoring');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.score = _scoring.score;

var log = (0, _debug2.default)('@pie-lib:categorize');

var limitChoices = exports.limitChoices = function limitChoices(choiceId, count, choices) {
  var out = choices.reduce(function (acc, id) {
    var foundCount = countInChoices(choiceId, acc.choices);
    // log('[limitChoices] choiceId: ', choiceId, '  foundCount: ', foundCount);
    if (id !== choiceId || foundCount < count) {
      acc.choices.push(id);
    }
    return acc;
  }, { choices: [] });

  return out.choices;
};

/**
 * Limit in an array of arrays.
 * So for an array with [[1,1],[1,1]] if you call limitInArray(1, arr, 3) you'll get: [[1,1], [1]]
 * @param {*} id
 * @param {*} arrays
 * @param {*} limit
 */
var limitInArrays = exports.limitInArrays = function limitInArrays(id, arrays, limit) {
  var result = arrays.reduce(function (acc, array) {
    var l = limit - acc.count;
    var result = limitInArray(id, array, l);
    acc.out.push(result.array);
    acc.count = acc.count + (result.count || 0);
    return acc;
  }, { out: [], count: 0 });

  return result.out;
};

/**
 * Limit the id in the array to the limit set.
 * So for an array with [1,1,1,1] if you call limitInArray(1, arr, 2) you'll get: [1,1]
 * @param {string} id
 * @param {string[]} arr
 * @param {number} limit
 */
var limitInArray = exports.limitInArray = function limitInArray(id, arr, limit) {
  if (limit === 0) {
    var stripped = arr.filter(function (v) {
      return v !== id;
    });
    return { array: stripped, count: arr.length - stripped.length };
  } else {
    var result = arr.reduce(function (acc, v) {
      if (v === id) {
        if (acc.count < limit) {
          acc.count += 1;
          acc.out.push(v);
        }
      } else {
        acc.out.push(v);
      }
      return acc;
    }, { out: [], count: 0 });

    return { array: result.out, count: result.count };
  }
};

/**
 * Ensure that there are no extra choices in answer, if a choice.categoryCount is > 0.
 * @param {{category: string, choices: string[]}[]} answer
 * @param {{id:string,categoryCount:number}} choices
 */
var ensureNoExtraChoicesInAnswer = exports.ensureNoExtraChoicesInAnswer = function ensureNoExtraChoicesInAnswer(answer, choices) {
  var out = choices.reduce(function (answerArray, choice) {
    log('choice: ----> ', choice.id, 'categoryCount: ', choice.categoryCount);
    // log('answer array: ', answerArray);
    if (choice.categoryCount === undefined || choice.categoryCount === 0) {
      return answerArray;
    } else {
      var _choices = answerArray.map(function (a) {
        return a.choices;
      });
      var result = limitInArrays(choice.id, _choices, choice.categoryCount);
      var updatedArray = result.map(function (r, index) {
        return { category: answerArray[index].category, choices: r };
      });
      return updatedArray;
    }
  }, answer);
  return out;
};

/**
 * Count the number of choice ids in a given answer array
 * @param {string} choiceId
 * @param {{category: string, choices: string[]}[]} answer
 */
var countInAnswer = exports.countInAnswer = function countInAnswer(choiceId, answer) {
  var out = answer.reduce(function (acc, a) {
    return acc + countInChoices(choiceId, a.choices);
  }, 0);
  log('[countInAnswer] choiceId:', choiceId, answer);
  return out;
};

var countInChoices = exports.countInChoices = function countInChoices(choiceId, choices) {
  return (choices || []).filter(function (c) {
    return c === choiceId;
  }).length;
};

/**
 * Count the number of times a choice has been selected in categories.
 * @param {*} choice
 * @param {*} categories
 */
var countChosen = exports.countChosen = function countChosen(choice, categories) {
  if (!choice || !choice.id) {
    return 0;
  }

  if (!Array.isArray(categories)) {
    return 0;
  }

  return categories.reduce(function (acc, c) {
    var count = (c.choices || []).filter(function (h) {
      return h.id === choice.id;
    }).length;
    return acc + count;
  }, 0);
};

/**
 * @param {string?} categoryId
 * @param {{category:string, choices: string[]}} answers
 */
var removeCategory = exports.removeCategory = function removeCategory(categoryId, answers) {
  return answers.filter(function (a) {
    return a.category !== categoryId;
  });
};

/**
 * @param {string} choiceId
 * @param {{category:string, choices: string[]}} answers
 * @param {string?} categoryId - optional categegory id
 */
var removeAllChoices = exports.removeAllChoices = function removeAllChoices(choiceId, answers, categoryId) {
  return answers.map(function (a) {
    if (!categoryId || a.category === categoryId) {
      var cloned = (0, _clone2.default)(a.choices);
      (0, _remove2.default)(cloned, function (v) {
        return v === choiceId;
      });
      return _extends({}, a, { choices: cloned });
    } else {
      return a;
    }
  });
};

var removeChoiceFromCategory = exports.removeChoiceFromCategory = function removeChoiceFromCategory(choiceId, categoryId, choiceIndex, answers) {
  log('[removeChoiceFromCategory] choiceIndex:', choiceIndex);

  return answers.map(function (a) {
    if (a.category === categoryId) {
      var cloned = (0, _clone2.default)(a.choices);
      var index = cloned.findIndex(function (v, index) {
        return v === choiceId && index >= choiceIndex;
      });
      if (index !== -1) {
        cloned.splice(index, 1);
      }
      return _extends({}, a, { choices: cloned });
    } else {
      return a;
    }
  });
};

var moveChoiceToCategory = exports.moveChoiceToCategory = function moveChoiceToCategory(choiceId, from, to, choiceIndex, answers) {
  log('[moveChoiceToCategory] choice: ', choiceId, 'from: ', from, 'to: ', to, 'answers: ', answers);

  if (from === to) {
    return answers;
  }

  if (from) {
    answers = removeChoiceFromCategory(choiceId, from, choiceIndex, answers);
  }

  var index = answers.findIndex(function (a) {
    return a.category === to;
  });
  if (index === -1) {
    answers.push({ category: to, choices: [choiceId] });
    return answers;
  } else {
    return answers.map(function (a) {
      if (a.category === to) {
        a.choices = a.choices || [];
        a.choices.push(choiceId);
        return a;
      }
      return a;
    });
  }
};

/**
 *
 * build the choice and category state
 * @param {Object[]} categories
 * @param {{id:string}[]} choices
 * @param {{category: string, choices:string[]}[]} answers
 *
 * @returns {categories: Category[], choices: Choice[]}
 */
var buildState = exports.buildState = function buildState(categories, choices) {
  var answers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var correctResponse = arguments[3];

  var addChoices = function addChoices(category) {
    var answer = answers.find(function (a) {
      return a.category === category.id;
    });

    var hasCorrectResponse = Array.isArray(correctResponse) && correctResponse.length > 0;

    var cr = hasCorrectResponse ? correctResponse.find(function (r) {
      return r.category === category.id;
    }) : undefined;
    var correctChoices = (0, _clone2.default)(cr ? cr.choices || [] : undefined);

    if (answer) {
      var mappedChoices = (0, _compact2.default)((answer.choices || []).map(function (id) {
        return choices.find(function (c) {
          return c.id === id;
        });
      }));

      var out = mappedChoices.reduce(function (acc, choice) {
        if (!acc.correct) {
          acc.choices.push(_extends({}, choice, { correct: undefined }));
        } else {
          var index = acc.correct.findIndex(function (id) {
            return id === choice.id;
          });
          acc.choices.push(_extends({}, choice, { correct: index !== -1 }));
          if (index !== -1) {
            acc.correct.splice(index, 1);
          }
        }
        return acc;
      }, {
        choices: [],
        correct: hasCorrectResponse ? correctChoices || [] : undefined
      });

      var ids = out.choices.map(function (c) {
        return c.id;
      }).sort();
      var correctIds = (0, _clone2.default)(cr && Array.isArray(cr.choices) ? cr.choices : []).sort();

      log('ids: ', ids, 'correctIds: ', correctIds);
      var _correct = hasCorrectResponse ? (0, _isEqual2.default)(ids, correctIds) : undefined;
      return _extends({}, category, {
        choices: out.choices,
        correct: _correct
      });
    } else {
      var _correct2 = correctChoices === undefined ? true : correctChoices.length === 0;
      log('empty choices is that correct?', correctChoices);
      return _extends({}, category, {
        choices: [],
        correct: _correct2
      });
    }
  };

  var withChoices = categories.map(addChoices);

  var correct = correctResponse ? (0, _every2.default)(withChoices, function (category) {
    return category.correct;
  }) : undefined;

  var stillSelectable = function stillSelectable(h) {
    if (h.categoryCount > 0) {
      var count = countChosen(h, withChoices);
      return count < h.categoryCount;
    } else {
      return true;
    }
  };

  var filteredChoices = choices.map(function (h) {
    if (stillSelectable(h)) {
      return h;
    } else {
      return { empty: true };
    }
  });

  return { choices: filteredChoices, categories: withChoices, correct: correct };
};