'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalize = exports.sort = exports.intersection = exports.words = exports.sentences = exports.paragraphs = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _compact = require('lodash/compact');

var _compact2 = _interopRequireDefault(_compact);

var _parseEnglish = require('parse-english');

var _parseEnglish2 = _interopRequireDefault(_parseEnglish);

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var g = function g(str, node) {
  if (node.children) {
    return node.children.reduce(g, str);
  } else if (node.value) {
    return str + node.value;
  } else {
    return str;
  }
};

var getParagraph = function getParagraph(p) {
  return g('', p);
};

var getSentence = function getSentence(s) {
  return g('', s);
};

var getWord = function getWord(w) {
  return g('', w);
};

var paragraphs = exports.paragraphs = function paragraphs(text) {
  var tree = new _parseEnglish2.default().parse(text);

  var out = tree.children.reduce(function (acc, child) {
    if (child.type === 'ParagraphNode') {
      var paragraph = {
        text: getParagraph(child),
        start: child.position.start.offset,
        end: child.position.end.offset
      };

      return acc.concat([paragraph]);
    } else {
      return acc;
    }
  }, []);

  return out;
};
var sentences = exports.sentences = function sentences(text) {
  var tree = new _parseEnglish2.default().parse(text);

  var out = tree.children.reduce(function (acc, child) {
    if (child.type === 'ParagraphNode') {
      return child.children.reduce(function (acc, child) {
        if (child.type === 'SentenceNode') {
          var sentence = {
            text: getSentence(child),
            start: child.position.start.offset,
            end: child.position.end.offset
          };
          return acc.concat([sentence]);
        } else {
          return acc;
        }
      }, acc);
    } else {
      return acc;
    }
  }, []);

  return out;
};
var words = exports.words = function words(text) {
  var tree = new _parseEnglish2.default().parse(text);

  var out = tree.children.reduce(function (acc, child) {
    if (child.type === 'ParagraphNode') {
      return child.children.reduce(function (acc, child) {
        if (child.type === 'SentenceNode') {
          return child.children.reduce(function (acc, child) {
            if (child.type === 'WordNode') {
              var node = {
                text: getWord(child),
                start: child.position.start.offset,
                end: child.position.end.offset
              };
              return acc.concat([node]);
            } else {
              return acc;
            }
          }, acc);
        } else {
          return acc;
        }
      }, acc);
    } else {
      return acc;
    }
  }, []);

  return out;
};

var Intersection = function () {
  function Intersection(results) {
    _classCallCheck(this, Intersection);

    this.results = results;
  }

  _createClass(Intersection, [{
    key: 'hasOverlap',
    get: function get() {
      return this.results.filter(function (r) {
        return r.type === 'overlap';
      }).length > 0;
    }
  }, {
    key: 'surroundedTokens',
    get: function get() {
      return this.results.filter(function (r) {
        return r.type === 'within-selection';
      }).map(function (t) {
        return t.token;
      });
    }
  }]);

  return Intersection;
}();
/**
 * get intersection info for the selection in relation to tokens.
 * @param {{start: number, end: number}} selection
 * @param {{start: number, end: number}[]} tokens
 * @return {tokens: [], type: 'overlap|no-overlap|contains'}
 */


var intersection = exports.intersection = function intersection(selection, tokens) {
  var start = selection.start,
      end = selection.end;


  var startsWithin = function startsWithin(t) {
    return start >= t.start && start < t.end;
  };
  var endsWithin = function endsWithin(t) {
    return end > t.start && end <= t.end;
  };

  var mapped = tokens.map(function (t) {
    if (start === t.start && end === t.end) {
      return { token: t, type: 'exact-fit' };
    } else if (start <= t.start && end >= t.end) {
      return { token: t, type: 'within-selection' };
    } else if (startsWithin(t) || endsWithin(t)) {
      return { token: t, type: 'overlap' };
    }
  });
  return new Intersection((0, _compact2.default)(mapped));
};

var sort = exports.sort = function sort(tokens) {
  if (!Array.isArray(tokens)) {
    return tokens;
  } else {
    var out = (0, _clone2.default)(tokens);
    out.sort(function (a, b) {
      var s = a.start < b.start ? -1 : a.start > b.start ? 1 : 0;
      var e = a.end < b.end ? -1 : a.end > b.end ? 1 : 0;
      if (s === -1 && e !== -1) {
        throw new Error('sort does not support intersecting tokens. a: ' + a.start + '-' + a.end + ', b: ' + b.start + '-' + b.end);
      }
      return s;
    });
    return out;
  }
};

var normalize = exports.normalize = function normalize(text, tokens) {
  if (!Array.isArray(tokens) || tokens.length === 0) {
    return [{
      text: text,
      start: 0,
      end: text.length
    }];
  }
  var out = sort(tokens).reduce(function (acc, t, index, outer) {
    var tokens = [];

    var lastIndex = acc.lastIndex;
    if (t.start === lastIndex) {
      tokens = [{
        text: text.substring(lastIndex, t.end),
        start: lastIndex,
        end: t.end,
        predefined: true,
        correct: t.correct
      }];
    } else {
      tokens = [{
        text: text.substring(lastIndex, t.start),
        start: lastIndex,
        end: t.start
      }, {
        text: text.substring(t.start, t.end),
        start: t.start,
        end: t.end,
        predefined: true,
        correct: t.correct
      }];
    }

    if (index === outer.length - 1 && t.end < text.length) {
      var last = {
        text: text.substring(t.end),
        start: t.end,
        end: text.length
      };
      tokens.push(last);
    }

    return {
      lastIndex: tokens[tokens.length - 1].end,
      result: acc.result.concat(tokens)
    };
  }, { result: [], lastIndex: 0 });

  return out.result;
};