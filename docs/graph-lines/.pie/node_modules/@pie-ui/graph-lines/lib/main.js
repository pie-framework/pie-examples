'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Main = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _charting = require('@pie-lib/charting');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _controls = require('./controls');

var _controls2 = _interopRequireDefault(_controls);

var _correctAnswerToggle = require('@pie-lib/correct-answer-toggle');

var _correctAnswerToggle2 = _interopRequireDefault(_correctAnswerToggle);

var _renderUi = require('@pie-lib/render-ui');

var _GraphLineControls = require('./GraphLineControls');

var _GraphLineControls2 = _interopRequireDefault(_GraphLineControls);

var _styles = require('@material-ui/core/styles');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Main extends _react2.default.Component {

  constructor(props) {
    super(props);

    _initialiseProps.call(this);

    const lines = props.session.lines || [];

    this.state = {
      session: _extends({}, props.session, { lines }),
      selection: [],
      useSessionLines: false,
      showCorrect: false
    };
  }

  componentWillReceiveProps(nextProps) {
    const lines = nextProps.session.lines || [];
    let shouldUseSessionLines = true;

    // if we do not have lines in the session OR
    // if we previously had lines in the session and they were cleared out
    // it means the model has changed and we need to stop using the lines in the session
    if (!this.props.session.lines || this.props.session.lines && this.props.session.lines.length && this.state.useSessionLines && !lines.length) {
      shouldUseSessionLines = false;
    }

    const session = _extends({}, nextProps.session, { lines });

    this.setState({ session, useSessionLines: shouldUseSessionLines });
  }

  render() {
    var _props = this.props;
    const model = _props.model,
          classes = _props.classes;
    var _state = this.state;
    const selection = _state.selection,
          showCorrect = _state.showCorrect;

    const lines = this.buildLines();

    return _react2.default.createElement(
      'div',
      { className: classes.mainContainer },
      _react2.default.createElement(
        'div',
        { className: classes.main },
        model.correctness && _react2.default.createElement(
          'div',
          null,
          'Score: ',
          model.correctness.score
        ),
        _react2.default.createElement(_correctAnswerToggle2.default, {
          className: classes.toggle,
          show: !model.exhibitOnly && model.correctness && model.correctness.correctness !== 'correct',
          toggled: showCorrect,
          onToggle: this.toggleShowCorrect
        }),
        !model.disabled && !model.exhibitOnly && _react2.default.createElement(_controls2.default, {
          iconOnly: false,
          disabled: !(selection && selection.length > 0),
          onDeleteClick: this.deleteSelection
        }),
        _react2.default.createElement(_GraphLineControls2.default, {
          lines: lines,
          model: model,
          onDeleteLine: this.onDeleteLine,
          updateLines: this.updateLines
        }),
        _react2.default.createElement(_charting.GraphLines, {
          maxLines: model.multiple ? model.lines.length : 1,
          className: classes.graph,
          lines: lines,
          width: model.width,
          height: model.height,
          domain: model.domain,
          range: model.range,
          disabled: model.disabled || model.exhibitOnly || false,
          onAddPoint: this.onAddPoint,
          onAddLine: this.onAddLine,
          onLineChange: this.onLineChange,
          onLineClick: this.toggleSelectLine
        })
      ),
      model.feedback && _react2.default.createElement(_renderUi.Feedback, {
        correctness: model.correctness.correctness,
        feedback: model.feedback,
        width: model.width - 20
      })
    );
  }
}

exports.Main = Main;
Main.propTypes = {
  classes: _propTypes2.default.object,
  session: _propTypes2.default.shape({
    lines: _propTypes2.default.arrayOf(_propTypes2.default.shape({
      from: _propTypes2.default.shape({
        x: _propTypes2.default.number.isRequired,
        y: _propTypes2.default.number.isRequired
      }),
      to: _propTypes2.default.shape({
        x: _propTypes2.default.number.isRequired,
        y: _propTypes2.default.number.isRequired
      })
    }))
  }),
  onSessionChange: _propTypes2.default.func,
  model: _propTypes2.default.object.isRequired
};

var _initialiseProps = function _initialiseProps() {
  this.setUseSessionLines = lines => {
    this.setState(state => ({
      session: _extends({}, state.session, { lines }),
      useSessionLines: true
    }), this.callOnSessionChange);
  };

  this.callOnSessionChange = () => {
    const onSessionChange = this.props.onSessionChange;


    if (onSessionChange) {
      onSessionChange(this.state.session);
    }
  };

  this.deleteSelection = () => {
    const lines = _charting.lineUtils.removeLines(this.state.session.lines, this.state.selection);

    const session = _extends({}, this.state.session, { lines });
    this.setState({ session, selection: [] }, this.callOnSessionChange);
  };

  this.buildLines = () => {
    const model = this.props.model;
    var _state2 = this.state;
    const session = _state2.session,
          showCorrect = _state2.showCorrect,
          selection = _state2.selection,
          useSessionLines = _state2.useSessionLines;


    if (model.correctResponse) {
      if (showCorrect) {
        return model.correctResponse;
      } else {
        return session.lines.map(line => _extends({}, line, {
          selected: _charting.lineUtils.hasLine(selection, line),
          correct: _charting.lineUtils.hasLine(model.correctResponse, line)
        }));
      }
    } else if (useSessionLines) {
      return session.lines;
    } else {
      const lines = [];

      model.model.config.lines.forEach(line => {
        const lineExpression = _charting.lineUtils.expressionFromDescriptor(line.initialView);
        const points = _charting.lineUtils.pointsFromExpression(lineExpression);

        lines.push(_extends({}, line, points));
      });

      return lines;
    }
  };

  this.toggleShowCorrect = show => {
    this.setState({ showCorrect: show });
  };

  this.onLineChange = (old, newLine) => {
    var _state3 = this.state;
    const session = _state3.session,
          selection = _state3.selection,
          useSessionLines = _state3.useSessionLines;

    const linesToUse = useSessionLines ? session.lines : this.buildLines();
    const newLines = _charting.lineUtils.swapLine(linesToUse, old, newLine);
    const newSelection = _charting.lineUtils.swapLine(selection, old, newLine);
    const newSession = _extends({}, session, { lines: newLines });

    this.setState({ session: newSession, selection: newSelection, useSessionLines: true }, this.callOnSessionChange);
  };

  this.toggleSelectLine = line => {
    var _state4 = this.state;
    const session = _state4.session,
          useSessionLines = _state4.useSessionLines,
          selection = _state4.selection;

    let newLines;
    let newSelection;

    if (_charting.lineUtils.hasLine(selection, line)) {
      newSelection = _charting.lineUtils.removeLine(selection, line);
    } else {
      newSelection = selection.concat([_extends({}, line, { selected: true })]);
    }

    const linesToUse = useSessionLines ? session.lines : this.buildLines();

    newLines = linesToUse.map(lineToUse => {
      if (_charting.lineUtils.linesEqual(lineToUse, line)) {
        return _extends({}, lineToUse, { selected: !_charting.lineUtils.hasLine(selection, line) });
      }

      return lineToUse;
    });

    const newSession = _extends({}, session, { lines: newLines });

    this.setState({ selection: newSelection, session: newSession, useSessionLines: true }, this.callOnSessionChange);
  };

  this.onAddPoint = () => {
    const linesFromModel = this.buildLines();

    this.setUseSessionLines(linesFromModel);
  };

  this.onAddLine = line => {
    this.setState(state => ({
      session: _extends({}, state.session, { lines: [...state.session.lines, line] })
    }), this.callOnSessionChange);
  };

  this.updateLines = newLines => {
    this.setUseSessionLines(newLines);
  };

  this.onDeleteLine = line => {
    var _state5 = this.state;
    const session = _state5.session,
          useSessionLines = _state5.useSessionLines,
          selection = _state5.selection;

    const linesToUse = useSessionLines ? session.lines : this.buildLines();

    this.setState(state => ({
      session: _extends({}, state.session, {
        lines: _charting.lineUtils.removeLine(linesToUse, line)
      }),
      useSessionLines: true,
      selection: _charting.lineUtils.removeLine(selection, line)
    }), this.callOnSessionChange);
  };
};

const styles = theme => ({
  mainContainer: {
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center'
  },
  graph: {
    display: 'flex',
    justifyContent: 'center'
  },
  main: {
    width: '100%'
  },
  toggle: {
    paddingBottom: theme.spacing.unit * 3
  }
});

exports.default = (0, _styles.withStyles)(styles)(Main);