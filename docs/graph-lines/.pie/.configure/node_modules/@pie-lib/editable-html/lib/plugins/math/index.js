'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serialization = exports.inlineMath = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = MathPlugin;

var _Functions = require('@material-ui/icons/Functions');

var _Functions2 = _interopRequireDefault(_Functions);

var _slate = require('slate');

var _component = require('./component');

var _component2 = _interopRequireDefault(_component);

var _mathToolbar = require('./math-toolbar');

var _mathToolbar2 = _interopRequireDefault(_mathToolbar);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('editable-html:plugins:math');

var TEXT_NODE = 3;

function MathPlugin(options) {
  return {
    toolbar: {
      icon: _react2.default.createElement(_Functions2.default, null),
      onClick: function onClick(value, onChange) {
        log('[insertMath]');
        var math = inlineMath();
        var change = value.change().insertInline(math);
        onChange(change);
      },
      supports: function supports(node) {
        return node && node.object === 'inline' && node.type === 'math';
      },
      customToolbar: function customToolbar(node) {
        return node && node.object === 'inline' && node.type === 'math' && _mathToolbar2.default;
      }
    },
    schema: {
      document: { types: ['math'] }
    },
    /**
     * A onDone wrapper function, places a blur change on the node, then calls
     * the original donefn.
     * Feels a bit messy - there may be a cleaner way to do this.
     */
    onDone: function onDone(e, node, value, onChange, fn) {
      var update = _extends({}, node.data.toObject(), { change: { type: 'blur' } });
      var change = value.change().setNodeByKey(node.key, { data: update });
      onChange(change);
      fn(e);
    },
    renderNode: function renderNode(props) {
      if (props.node.type === 'math') {
        log('[renderNode]: ', props);
        log('MathInput', _component2.default);
        return _react2.default.createElement(_component2.default, _extends({}, props, {
          onClick: function onClick() {
            return options.onClick(props.node);
          },
          onFocus: options.onFocus,
          onBlur: options.onBlur
        }));
      }
    }
  };
}

var inlineMath = exports.inlineMath = function inlineMath() {
  return _slate.Inline.create({
    object: 'inline',
    type: 'math',
    isVoid: true,
    data: {
      latex: '1 + 1 = 2'
    }
  });
};

var serialization = exports.serialization = {
  deserialize: function deserialize(el) {
    if (el.nodeType === TEXT_NODE) {
      return;
    }

    var tagName = el.tagName.toLowerCase();
    log('[deserialize] name: ', tagName);
    var hasMathJaxAttribute = el.getAttribute('mathjax') !== undefined || el.getAttribute('data-mathjax') !== undefined;

    log('[deserialize] hasMathJaxAttribute: ', hasMathJaxAttribute);
    if (tagName === 'span' && hasMathJaxAttribute) {
      return {
        object: 'inline',
        type: 'math',
        isVoid: true,
        nodes: [],
        data: {
          latex: el.innerHTML
        }
      };
    }
  },
  serialize: function serialize(object) {
    if (object.type === 'math') {
      return _react2.default.createElement(
        'span',
        { 'data-mathjax': '' },
        object.data.get('latex')
      );
    }
  }
};