'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tickCount = exports.buildSizeArray = undefined;
exports.getInterval = getInterval;
exports.snapTo = snapTo;
exports.buildTickModel = buildTickModel;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _range = require('lodash/range');

var _range2 = _interopRequireDefault(_range);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var buildSizeArray = exports.buildSizeArray = function buildSizeArray(size, padding) {
  (0, _invariant2.default)(padding < size, 'padding must be less than size');
  var half = Math.round(padding * 0.5);
  return [half, size - half];
};

var tickCount = exports.tickCount = function tickCount(min, max, step) {
  (0, _invariant2.default)(min < max, 'min must be less than max');
  var size = Math.abs(min - max);
  return Math.round(size / step);
};

function getInterval(domain, ticks) {
  var min = domain.min,
      max = domain.max;
  var major = ticks.major,
      minor = ticks.minor;


  if (min >= max) {
    throw new Error('min is > max: ' + min + ' > ' + max);
  }

  var distance = max - min;
  var minorTicks = minor > 0 ? minor + 1 : 1;
  var normalizedMajor = major - 1;

  if (isNaN(normalizedMajor)) {
    throw new Error('Tick Frequency must be 2 or higher');
  }

  if (normalizedMajor <= 0) {
    throw new Error('Tick Frequency must be 2 or higher');
  }

  var divider = normalizedMajor * minorTicks;
  var raw = distance / divider;
  return parseFloat(Number(raw).toFixed(4));
}

var mkRange = function mkRange(min, max, interval) {
  var raw = (0, _range2.default)(min, max, interval);
  /* Fix the last step due to rounding errors */
  raw.splice(raw.length, 1, max);
  return raw;
};

function snapTo(min, max, interval, value) {
  if (value >= max) {
    return max;
  }

  if (value <= min) {
    return min;
  }

  var rng = mkRange(min, max, interval);

  rng = rng.filter(function (v) {
    return Math.abs(value - v) <= interval;
  });

  var closest = rng.reduce(function (prev, curr) {
    var currentDistance = Math.abs(curr - value);
    var previousDistance = Math.abs(prev - value);
    return currentDistance <= previousDistance ? curr : prev;
  });

  return closest;
}

function buildTickModel(domain, ticks, interval, scaleFn) {
  var rng = mkRange(domain.min, domain.max, interval);

  return rng.map(function (r, index) {
    var isMajor = index % (ticks.minor + 1) === 0;

    return {
      value: r,
      major: isMajor,
      x: scaleFn(r)
    };
  });
}