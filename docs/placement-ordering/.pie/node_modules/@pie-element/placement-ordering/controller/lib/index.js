'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.outcome = outcome;
exports.model = model;

var _scoring = require('./scoring');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _feedback = require('@pie-lib/feedback');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _debug2.default)('@pie-element:placement-ordering-controller');

function outcome(question, session, env) {
  session.value = session.value || [];
  return new Promise((resolve, reject) => {
    if (!question || !question.correctResponse || _lodash2.default.isEmpty(question.correctResponse)) {
      reject(new Error('Question is missing required array: correctResponse'));
    } else {
      resolve({
        score: {
          scaled: (0, _scoring.score)(question, session)
        }
      });
    }
  });
}

/**
 * remove any ids from the stashed shuffle that arent in choices
 * @param {*} choices
 * @param {*} shuffled
 */
function normalize(choices, shuffled) {
  return shuffled && shuffled.filter(s => choices.findIndex(c => c.id === s) !== -1);
}

/**
 * If there is a shuffled order stored in the session, restore it. Otherwise shuffle
 * all choices which do not have their shuffle property explicitly set to false.
 *
 * TODO: need to add a method to `model`: `saveSession: (session) => Promise<session>`
 * To allow the shuffle to be persisted.
 */
function shuffle(session, choices) {
  const stashedShuffle = normalize(choices, session.stash && session.stash.shuffledOrder);
  if (stashedShuffle) {
    return stashedShuffle.map(choiceId => {
      return choices.find(c => c.id === choiceId);
    });
  } else {
    let result = _lodash2.default.cloneDeep(choices);
    for (var i = choices.length - 1; i >= 0; i--) {
      if (choices[i].shuffle === false) {
        result.splice(i, 1);
      }
    }
    let shuffled = _lodash2.default.shuffle(_lodash2.default.cloneDeep(result));
    choices.forEach((choice, index) => {
      if (choice.shuffle === false) {
        shuffled.splice(index, 0, choice);
      }
    });
    session.stash = session.stash || {};
    session.stash.shuffledOrder = shuffled.map(({ id }) => id);
    return shuffled;
  }
}

function model(question, session, env) {
  return new Promise((resolve, reject) => {
    const base = {};

    base.outcomes = [];
    base.completeLength = question.correctResponse.length;

    const choices = question.shuffle ? shuffle(session, question.choices) : question.choices;
    base.choices = choices;

    log('[model] removing tileSize for the moment.');

    base.prompt = question.prompt;
    base.config = {
      orientation: question.choiceAreaLayout || 'vertical',
      includeTargets: question.placementType === 'placement',
      targetLabel: question.answerAreaLabel,
      choiceLabel: question.choiceAreaLabel,
      showOrdering: question.showOrdering
    };
    base.configure = question.configure;

    base.disabled = env.mode !== 'gather';

    if (env.mode === 'evaluate') {
      base.outcomes = _lodash2.default.map(session.value, function (c, idx) {
        return {
          id: c,
          outcome: (0, _scoring.flattenCorrect)(question)[idx] === c ? 'correct' : 'incorrect'
        };
      });
      var allCorrect = _lodash2.default.isEqual((0, _scoring.flattenCorrect)(question), session.value);

      base.correctness = allCorrect ? 'correct' : 'incorrect';

      if (!allCorrect) {
        base.correctResponse = (0, _scoring.flattenCorrect)(question);
      }
      (0, _feedback.getFeedbackForCorrectness)(base.correctness, question.feedback).then(feedback => {
        base.feedback = feedback;
        resolve(base);
      });
    } else {
      resolve(base);
    }
  });
}