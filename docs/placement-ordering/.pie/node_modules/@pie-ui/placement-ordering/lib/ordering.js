'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.swap = undefined;
exports.buildState = buildState;
exports.reducer = reducer;

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _assign = require('lodash/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _debug2.default)('pie-elements:placement-ordering:ordering');

const swap = exports.swap = (arr, fromIndex, toIndex) => {
  log('[swap]', arr, fromIndex, toIndex);
  if (!arr || arr.length <= 1 || fromIndex === undefined || toIndex === undefined) {
    throw new Error(`swap requires a non-empty array, fromIndex, toIndex: ${arr}, ${fromIndex} ${toIndex}`);
  }
  const update = (0, _cloneDeep2.default)(arr);
  const tmp = arr[toIndex];
  update[toIndex] = update[fromIndex];
  update[fromIndex] = tmp;
  return update;
};

function removeResponse(state, targetTile) {
  const update = (0, _cloneDeep2.default)(state.response);

  if (update[targetTile.index] === targetTile.id) {
    update[targetTile.index] = undefined;
  } else {
    throw new Error(`Tried to remove from index: ${targetTile.index}, but the id doesn't match: array: ${update}, target: ${targetTile.id}`);
  }
  return update;
}

function updateResponse(state, from, to) {
  const response = state.response,
        opts = state.opts;

  const update = (0, _cloneDeep2.default)(response);
  if (opts.includeTargets) {
    if (from.type === 'choice' && to.type === 'target') {
      update[to.index] = from.id;
      return update;
    } else if (from.type === 'target' && to.type === 'choice') {
      update[from.index] = undefined;
      return update;
    } else if (from.type === 'target' && to.type === 'target') {
      return swap(response, from.index, to.index);
    } else {
      log('do nothing to the response');
      return response;
    }
  } else {
    const fromIndex = state.response.findIndex(r => r !== undefined && r === from.id);
    const toIndex = state.response.findIndex(r => r !== undefined && r === to.id);
    log('fromIndex: ', fromIndex, 'toIndex:', toIndex);
    return swap(state.response, fromIndex, toIndex);
  }
}

function buildTiles(choices, response, outcomes, opts) {
  if (opts.includeTargets) {
    const targets = [];
    for (var i = 0; i < response.length; i++) {
      const r = response[i];

      const choice = choices.find(c => r !== undefined && r !== null && c.id === r);
      //TODO: index needs to match too!!
      const outcome = outcomes[i];

      const out = Object.assign({ type: 'target', index: i, empty: choice === undefined }, choice, outcome, { draggable: choice !== undefined });

      targets.push(out);
    }

    const processedChoices = choices.map(m => {
      if (response.indexOf(m.id) !== -1 && m.moveOnDrag) {
        return {
          type: 'choice',
          empty: true,
          droppable: true,
          draggable: false
        };
      } else {
        return Object.assign({}, m, {
          type: 'choice',
          droppable: false,
          draggable: true
        });
      }
    });

    return processedChoices.concat(targets);
  } else {
    return response.map((id, index) => {
      return Object.assign({ type: 'choice', draggable: true, droppable: true }, choices.find(m => m.id === id), outcomes[index]);
    });
  }
}

function buildState(choices, response, outcomes, opts) {
  opts = (0, _assign2.default)({ includeTargets: true }, opts);

  outcomes = outcomes || [];
  response = !response || (0, _isEmpty2.default)(response) ? opts.includeTargets ? new Array(choices.length) : (0, _map2.default)(choices, c => c.id) : response;
  return {
    choices,
    response,
    opts,
    outcomes,
    tiles: buildTiles(choices, response, outcomes, opts)
  };
}

function reducer(action, state) {
  switch (action.type) {
    case 'move':
      {
        const from = action.from,
              to = action.to;

        const response = updateResponse(state, from, to);
        const tiles = buildTiles(state.choices, response, state.outcomes, state.opts);
        return Object.assign({}, state, { response, tiles });
      }
    case 'remove':
      {
        const target = action.target;

        const response = removeResponse(state, target);
        const tiles = buildTiles(state.choices, response, state.outcomes, state.opts);
        return Object.assign({}, state, { response, tiles });
      }
  }
  return state;
}