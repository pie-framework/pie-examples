'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tile = undefined;

var _reactDnd = require('react-dnd');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _styles = require('@material-ui/core/styles');

var _drag = require('@pie-lib/drag');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _debug2.default)('pie-elements:placement-ordering:tile');

const Holder = (0, _styles.withStyles)(() => ({
  number: {
    width: '100%',
    fontSize: '30px',
    textAlign: 'center',
    color: 'rgba(0,0,0,0.6)'
  }
}))(({ classes, type, index, isOver, disabled }) => _react2.default.createElement(
  _drag.PlaceHolder,
  { isOver: isOver, disabled: disabled },
  type === 'target' && index !== undefined && _react2.default.createElement(
    'div',
    { className: classes.number },
    index
  )
));

Holder.propTypes = {
  type: _propTypes2.default.string,
  index: _propTypes2.default.number,
  isOver: _propTypes2.default.bool,
  disabled: _propTypes2.default.bool
};

const TileContent = (0, _styles.withStyles)({
  over: {
    opacity: 0.2
  },
  tileContent: {
    cursor: 'pointer',
    width: '100%',
    height: '100%',
    padding: '10px',
    boxSizing: 'border-box',
    overflow: 'hidden',
    border: '1px solid #c2c2c2',
    backgroundColor: 'white',
    transition: 'opacity 200ms linear'
  },
  dragging: {
    opacity: 0.5
  },
  disabled: {
    backgroundColor: '#ececec',
    cursor: 'not-allowed'
  },
  incorrect: {
    border: 'solid 1px orange'
  },
  correct: {
    border: 'solid 1px green'
  }
})(props => {
  const type = props.type,
        classes = props.classes,
        isDragging = props.isDragging,
        empty = props.empty,
        isOver = props.isOver,
        label = props.label,
        disabled = props.disabled,
        outcome = props.outcome,
        guideIndex = props.guideIndex;


  if (empty) {
    return _react2.default.createElement(Holder, {
      type: type,
      index: guideIndex,
      isOver: isOver,
      disabled: disabled
    });
  } else {
    const names = (0, _classnames2.default)(classes.tileContent, isDragging && !disabled && classes.dragging, isOver && !disabled && classes.over, disabled && classes.disabled, outcome && classes[outcome]);
    return _react2.default.createElement('div', { className: names, dangerouslySetInnerHTML: { __html: label } });
  }
});

class Tile extends _react2.default.Component {

  render() {
    var _props = this.props;
    const label = _props.label,
          isDragging = _props.isDragging,
          connectDragSource = _props.connectDragSource,
          connectDropTarget = _props.connectDropTarget,
          classes = _props.classes,
          isOver = _props.isOver,
          type = _props.type,
          id = _props.id,
          empty = _props.empty,
          disabled = _props.disabled,
          outcome = _props.outcome,
          index = _props.index,
          guideIndex = _props.guideIndex;


    log('[render], props: ', this.props);

    const name = (0, _classnames2.default)(classes.tile);

    const dragSourceOpts = {
      //dropEffect: moveOnDrag ? 'move' : 'copy'
    };

    return connectDragSource(connectDropTarget(_react2.default.createElement(
      'div',
      { className: name },
      _react2.default.createElement(TileContent, {
        label: label,
        id: id,
        empty: empty,
        index: index,
        guideIndex: guideIndex,
        isOver: isOver,
        isDragging: isDragging,
        disabled: disabled,
        outcome: outcome,
        type: type
      })
    )), dragSourceOpts);
  }
}

exports.Tile = Tile;
Tile.propTypes = {
  connectDragSource: _propTypes2.default.func.isRequired,
  connectDropTarget: _propTypes2.default.func.isRequired,
  isDragging: _propTypes2.default.bool.isRequired,
  id: _propTypes2.default.any,
  label: _propTypes2.default.string,
  isOver: _propTypes2.default.bool,
  classes: _propTypes2.default.object.isRequired,
  type: _propTypes2.default.string,
  empty: _propTypes2.default.bool,
  disabled: _propTypes2.default.bool,
  outcome: _propTypes2.default.object,
  index: _propTypes2.default.number,
  guideIndex: _propTypes2.default.number.isRequired
};
const StyledTile = (0, _styles.withStyles)({
  tile: {
    boxSizing: 'border-box',
    overflow: 'hidden',
    margin: '0px',
    padding: '0px',
    textAlign: 'center'
  }
})(Tile);

const tileTarget = {
  drop(props, monitor) {
    const draggedItem = monitor.getItem();
    log('props.instanceId', props.instanceId, 'draggedItem.instanceId:', draggedItem.instanceId);
    if (draggedItem.instanceId === props.instanceId) {
      props.onDropChoice(draggedItem, props.index);
    }
  },
  canDrop(props, monitor) {
    const draggedItem = monitor.getItem();
    const canDrop = draggedItem.instanceId === props.instanceId;
    return canDrop;
  }
};

const DropTile = (0, _reactDnd.DropTarget)('Tile', tileTarget, (connect, monitor) => ({
  connectDropTarget: connect.dropTarget(),
  isOver: monitor.isOver()
}))(StyledTile);

const tileSource = {
  canDrag(props) {
    return props.draggable && !props.disabled;
  },
  beginDrag(props) {
    return {
      id: props.id,
      type: props.type,
      instanceId: props.instanceId
    };
  },
  endDrag(props, monitor) {
    if (!monitor.didDrop()) {
      if (props.type === 'target') {
        props.onRemoveChoice(monitor.getItem());
      }
    }
  }
};

const DragDropTile = (0, _reactDnd.DragSource)('Tile', tileSource, (connect, monitor) => ({
  connectDragSource: connect.dragSource(),
  isDragging: monitor.isDragging()
}))(DropTile);

exports.default = DragDropTile;