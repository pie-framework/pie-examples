'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PlacementOrdering = undefined;

var _tiler = require('./tiler');

var _ordering = require('./ordering');

var _renderUi = require('@pie-lib/render-ui');

var _correctAnswerToggle = require('@pie-lib/correct-answer-toggle');

var _correctAnswerToggle2 = _interopRequireDefault(_correctAnswerToggle);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _compact = require('lodash/compact');

var _compact2 = _interopRequireDefault(_compact);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _uniqueId = require('lodash/uniqueId');

var _uniqueId2 = _interopRequireDefault(_uniqueId);

var _styles = require('@material-ui/core/styles');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _debug2.default)('pie-elements:placement-ordering');

class PlacementOrdering extends _react2.default.Component {

  constructor(props) {
    super(props);
    this.state = {
      showingCorrect: false
    };

    this.instanceId = (0, _uniqueId2.default)();

    this.toggleCorrect = showingCorrect => {
      this.setState({ showingCorrect });
    };
  }

  componentWillReceiveProps(nextProps) {
    if (!nextProps.model.correctResponse) {
      this.setState({ showingCorrect: false });
    }
  }

  onDropChoice(ordering, target, source) {
    var _props = this.props;
    const onSessionChange = _props.onSessionChange,
          session = _props.session;

    const from = ordering.tiles.find(t => t.id === source.id && t.type === source.type);
    const to = target;
    log('[onDropChoice] ', from, to);
    const update = (0, _ordering.reducer)({ type: 'move', from, to }, ordering);
    const sessionUpdate = Object.assign({}, session, {
      value: update.response
    });
    onSessionChange(sessionUpdate);
  }

  onRemoveChoice(ordering, target) {
    var _props2 = this.props;
    const onSessionChange = _props2.onSessionChange,
          session = _props2.session;

    log('[onRemoveChoice]', target);
    const update = (0, _ordering.reducer)({ type: 'remove', target }, ordering);
    const sessionUpdate = Object.assign({}, session, {
      value: update.response
    });
    onSessionChange(sessionUpdate);
  }

  componentDidUpdate() {
    this.initSessionIfNeeded();
  }

  componentDidMount() {
    this.initSessionIfNeeded();
  }

  initSessionIfNeeded() {
    var _props3 = this.props;
    const model = _props3.model,
          session = _props3.session,
          onSessionChange = _props3.onSessionChange;

    const config = model.config || { includeTargets: true };

    log('[initSessionIfNeeded] config:', config, 'session.value: ', session.value);
    if (!config.includeTargets && (0, _isEmpty2.default)((0, _compact2.default)(session.value))) {
      log('[initSessionIfNeeded] initing session...', config.includeTargets);
      const update = (0, _cloneDeep2.default)(session);
      update.value = model.choices.map(m => m.id);
      onSessionChange(update);
    }
  }

  render() {
    var _props4 = this.props;
    const classes = _props4.classes,
          model = _props4.model,
          session = _props4.session;

    const showToggle = model.correctResponse && model.correctResponse.length > 0;
    const showingCorrect = this.state.showingCorrect;

    const config = model.config || {
      orientation: 'vertical',
      includeTargets: true
    };
    const orientation = config.orientation,
          includeTargets = config.includeTargets;

    const vertical = orientation === 'vertical';

    const ordering = showingCorrect ? (0, _ordering.buildState)(model.choices, model.correctResponse, model.correctResponse.map(id => ({ id, outcome: 'correct' })), { includeTargets }) : (0, _ordering.buildState)(model.choices, session.value, model.outcomes, {
      includeTargets
    });

    const Tiler = vertical ? _tiler.VerticalTiler : _tiler.HorizontalTiler;

    return _react2.default.createElement(
      'div',
      { className: classes.placementOrdering },
      _react2.default.createElement(_correctAnswerToggle2.default, {
        show: showToggle,
        toggled: this.state.showingCorrect,
        onToggle: this.toggleCorrect
      }),
      _react2.default.createElement('div', {
        className: classes.prompt,
        dangerouslySetInnerHTML: { __html: model.prompt }
      }),
      _react2.default.createElement(Tiler, {
        instanceId: this.instanceId,
        choiceLabel: config.choiceLabel,
        targetLabel: config.targetLabel,
        tiles: ordering.tiles,
        disabled: model.disabled,
        addGuide: model.config.showOrdering,
        tileSize: model.config && model.config.tileSize,
        includeTargets: includeTargets,
        onDropChoice: this.onDropChoice.bind(this, ordering),
        onRemoveChoice: this.onRemoveChoice.bind(this, ordering)
      }),
      _react2.default.createElement('br', null),
      !showingCorrect && _react2.default.createElement(_renderUi.Feedback, { correctness: model.correctness, feedback: model.feedback })
    );
  }
}

exports.PlacementOrdering = PlacementOrdering;
PlacementOrdering.propTypes = {
  onSessionChange: _propTypes2.default.func.isRequired,
  model: _propTypes2.default.object.isRequired,
  session: _propTypes2.default.object.isRequired,
  classes: _propTypes2.default.object.isRequired
};
const styles = {
  placementOrdering: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    boxSizing: 'border-box'
  },
  prompt: {
    padding: '5px',
    paddingBottom: '15px'
  }
};

exports.default = (0, _styles.withStyles)(styles)(PlacementOrdering);