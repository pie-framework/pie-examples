'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.toSessionPoints = toSessionPoints;
exports.toSessionAnswers = toSessionAnswers;
exports.toComponentModel = toComponentModel;
const rangeModelMap = {
  rangeLabel: 'label',
  rangeMin: 'min',
  rangeMax: 'max',
  rangeStepValue: 'step',
  rangeSnapValue: 'snap',
  rangeLabelFrequency: 'labelFrequency',
  rangeGraphPadding: 'padding'
};

const domainModelMap = {
  domainLabel: 'label',
  domainMin: 'min',
  domainMax: 'max',
  domainStepValue: 'step',
  domainSnapValue: 'snap',
  domainLabelFrequency: 'labelFrequency',
  domainGraphPadding: 'padding'
};

const modelMap = {
  graphTitle: 'title',
  graphWidth: 'width',
  graphHeight: 'height',
  maxPoints: '',
  labelsType: '',
  pointLabels: '',
  sigfigs: '',
  showCoordinates: '',
  showPointLabels: '',
  showInputs: '',
  showAxisLabels: '',
  showFeedback: ''
};

/**
 * Convert old xy string array to points array
 * @param {string[]} points - eg: ['x,y', 'x,y']
 * @param {*} oldModel
 *
 * @return {{x:number,y:number,label:string}[]}
 */
function toSessionPoints(points = [], oldModel) {
  return points.map((point, idx) => {
    var _point$split = point.split(','),
        _point$split2 = _slicedToArray(_point$split, 2);

    const x = _point$split2[0],
          y = _point$split2[1];


    return { x: parseInt(x, 10), y: parseInt(y, 10), label: oldModel.model.config.pointLabels[idx] };
  });
}

/**
 * Convert points array to xy string array
 * @param {{x:number,y:number,label:string}[]} points
 *
 * @return {string[]}
 */
function toSessionAnswers(points) {
  return points.map(point => `${point.x},${point.y}`);
}

/**
 * Convert model to one the @pie-ui/point-intercept/Component uses.
 * @param {} m
 */
function toComponentModel(m) {
  const newModel = Object.assign({}, m);
  const oldModelCopy = Object.assign({}, m);

  newModel.range = {};
  newModel.domain = {};
  newModel.config = m.model.config;

  if (m.correctResponse) {
    newModel.correctResponse = toSessionPoints(m.correctResponse, m);
  }

  Object.keys(rangeModelMap).forEach(key => {
    newModel.range[rangeModelMap[key]] = oldModelCopy.model.config[key];
  });

  Object.keys(domainModelMap).forEach(key => {
    newModel.domain[domainModelMap[key]] = oldModelCopy.model.config[key];
  });

  Object.keys(oldModelCopy.model.config).forEach(key => {
    newModel[modelMap[key] || key] = m.model.config[key];
  });

  return newModel;
}