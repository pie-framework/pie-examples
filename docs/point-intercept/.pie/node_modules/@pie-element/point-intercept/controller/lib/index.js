'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.model = model;

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _feedback = require('@pie-lib/feedback');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _debug2.default)('@pie-element:point-intercept:controller');

const getResponseCorrectness = (correctResponseWithLabels, points, model, partialScores) => {
  const allowPartialScores = model.config.allowPartialScoring;
  const pointsMustMatchLabels = model.config.pointsMustMatchLabels;

  let correctAnswers = 0;

  if (!points || points.length === 0) {
    return {
      correctness: 'empty',
      score: 0
    };
  }

  points.forEach(point => {
    const isCorrectAnswer = correctResponseWithLabels.find(correctAnswer => {
      const answerPresent = correctAnswer.x === point.x && correctAnswer.y === point.y;
      return pointsMustMatchLabels ? answerPresent && correctAnswer.label === point.label : answerPresent;
    });

    if (isCorrectAnswer) {
      correctAnswers += 1;
    }
  });

  if (correctResponseWithLabels.length === correctAnswers) {
    return { correctness: 'correct', score: '100%' };
  } else if (correctAnswers === 0) {
    return { correctness: 'incorrect', score: '0%' };
  } else if (allowPartialScores && partialScores && partialScores.length) {
    return {
      correctness: 'partial',
      score: `${(partialScores.find(partialScore => partialScore.numberOfCorrect === correctAnswers) || {}).scorePercentage || 0}%`
    };
  }

  return { correctness: 'incorrect', score: '0%' };
};

function model(question, session, env) {
  return new Promise(resolve => {
    const model = question.model,
          correctResponse = question.correctResponse,
          partialScoring = question.partialScoring;


    const getCorrectness = () => {
      if (env.mode === 'evaluate') {
        if (!session.points || session.points.length === 0) {
          return {
            correctness: 'unanswered',
            score: '0%'
          };
        }

        const correctResponseWithLabels = correctResponse.map((answer, idx) => {
          var _answer$split = answer.split(','),
              _answer$split2 = _slicedToArray(_answer$split, 2);

          const x = _answer$split2[0],
                y = _answer$split2[1];


          return {
            x: parseInt(x, 10),
            y: parseInt(y, 10),
            label: model.config.pointLabels[idx]
          };
        });

        return getResponseCorrectness(correctResponseWithLabels, session.points, model, partialScoring);
      }
    };

    const correctInfo = getCorrectness();
    const fb = env.mode === 'evaluate' ? (0, _feedback.getFeedbackForCorrectness)(correctInfo.correctness, question.feedback) : Promise.resolve(undefined);

    fb.then(feedback => {
      const base = {
        correctness: correctInfo,
        feedback,
        disabled: env.mode !== 'gather'
      };

      const out = Object.assign(base, {
        model,
        correctResponse: env.mode === 'evaluate' ? correctResponse : undefined
      });
      resolve(out);
    });
  });
}