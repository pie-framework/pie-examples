'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.swapPoint = exports.swap = exports.bounds = exports.addPoint = exports.firstAvailableLabel = exports.removePoints = exports.trim = exports.hasPoint = exports.pointIndex = undefined;

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _omitBy = require('lodash/omitBy');

var _omitBy2 = _interopRequireDefault(_omitBy);

var _isUndefined = require('lodash/isUndefined');

var _isUndefined2 = _interopRequireDefault(_isUndefined);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('pie-lib:charting:point:utils');

/**
 * Get the index of the point in the points array
 * @param {Point[]} points
 * @param {Point} p
 * @param {Boolean} includeLabel - will look at label too to determine if point is there
 */
var pointIndex = exports.pointIndex = function pointIndex(points, p, includeLabel) {
  return (points || []).findIndex(function (s) {
    return s.x === p.x && s.y === p.y && (includeLabel ? s.label === p.label : true);
  });
};

var hasPoint = exports.hasPoint = function hasPoint(points, p, includeLabel) {
  return pointIndex(points, p, includeLabel) !== -1;
};

var trim = exports.trim = function trim(point) {
  return {
    x: point.x,
    y: point.y,
    label: point.label
  };
};

var removePoints = exports.removePoints = function removePoints(points, toRemove) {
  log('[removePoints] points: ', points, toRemove);
  toRemove = Array.isArray(toRemove) ? toRemove : [toRemove];

  var out = points.filter(function (p) {
    return !hasPoint(toRemove, p);
  });

  log('[removePoints] points: ', out);
  return out;
};

var firstAvailableLabel = exports.firstAvailableLabel = function firstAvailableLabel(points, labels) {
  var existing = points.map(function (p) {
    return p.label;
  });
  log('points: ', points);
  var filtered = labels.filter(function (l) {
    return !existing.some(function (e) {
      return e === l;
    });
  });
  log('existing: ', existing, 'filtered: ', filtered);
  return filtered.length > 0 ? filtered[0] : '';
};

var addPoint = exports.addPoint = function addPoint(points, p, labels) {
  labels = labels || [];
  if (!hasPoint(points, p)) {
    var out = points.slice();
    var label = firstAvailableLabel(points, labels);
    out.push(Object.assign({}, p, { label: label }));
    return out;
  } else {
    return points;
  }
};

var bounds = exports.bounds = function bounds(p, domain, range) {
  return {
    left: domain.min - p.x,
    right: Math.abs(p.x - domain.max),
    top: Math.abs(p.y - range.max),
    bottom: range.min - p.y
  };
};

var swap = exports.swap = function swap(arr, from, to, getIndex) {
  log('[swap] arr: ', arr, 'from: ', from, 'to: ', to);

  var toIndex = getIndex(arr, to);

  log('[swap] toIndex: ', toIndex);

  if (toIndex !== -1) {
    //prevent moving one point on top of another.
    return arr;
  }

  var fromIndex = getIndex(arr, from);

  log('[swap] fromIndex: ', fromIndex);

  if (fromIndex === -1) {
    //cant move a point that isn't in the points array
    return arr;
  }

  var f = arr[fromIndex];
  var replacement = Object.assign({}, f, (0, _omitBy2.default)(to, _isUndefined2.default));
  var out = arr.slice();
  out.splice(fromIndex, 1, replacement); //{ ...to, label: f.label });
  return out;
};

/**
 * swap a point 'from', with point 'to'.
 * Finds the point in the array and updates it to equal the 'to' point.
 * @param {Point[]} points
 * @param {Point} from
 * @param {Point} to
 */

var swapPoint = exports.swapPoint = function swapPoint(points, from, to) {
  return swap(points, from, to, pointIndex);
};