'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.swapLine = exports.lineIndex = exports.linesEqual = exports.pointsEqual = exports.removeLines = exports.removeLine = exports.hasLine = exports.expressionFromDescriptor = exports.pointsFromExpression = exports.point = exports.expression = exports.pointsHaveSameExpression = exports.Expression = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _utils = require('../point/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var log = (0, _debug2.default)('pie-lib:charting:line:utils');

var lineExpressionRegex = new RegExp(/([+|-]?\d+)?(x)?([+|-]\d+)?/i);

var Expression = exports.Expression = function () {
  function Expression(multiplier, b) {
    _classCallCheck(this, Expression);

    this.multiplier = multiplier;
    this.isVerticalLine = Math.abs(this.multiplier) === Infinity;
    this.b = this.isVerticalLine ? undefined : b;
  }

  _createClass(Expression, [{
    key: 'expr',
    value: function expr() {
      return this.isVerticalLine ? 'x' : this.multiplier + 'x + ' + this.b;
    }
  }, {
    key: 'getY',
    value: function getY(x) {
      return this.isVerticalLine ? x : this.multiplier * x + this.b;
    }
  }, {
    key: 'getX',
    value: function getX(y) {
      return this.isVerticalLine ? y : (y - this.b) / this.multiplier;
    }
  }, {
    key: 'equals',
    value: function equals(other) {
      return this.multiplier === other.multiplier && this.b === other.b;
    }
  }]);

  return Expression;
}();

var pointsHaveSameExpression = exports.pointsHaveSameExpression = function pointsHaveSameExpression(a, b) {
  var expressionA = expression(a.from, a.to);
  var expressionB = expression(b.from, b.to);
  return expressionA.equals(expressionB);
};
/**
 * Create a linear expression from 2 points
 */

var expression = exports.expression = function expression(from, to) {
  log('[expression] from: ', from, 'to: ', to);
  var multiplier = (to.y - from.y) / (to.x - from.x);
  var zeroedY = multiplier * from.x;
  var b = from.y - zeroedY;
  return new Expression(multiplier, b);
};

var point = exports.point = function point(x, y) {
  return { x: x, y: y };
};

var pointsFromExpression = exports.pointsFromExpression = function pointsFromExpression(expression) {
  var to = point(0, expression.b);
  var huh = expression.getX(0);
  var from = point(huh, 0);

  return {
    from: from,
    to: to
  };
};

var expressionFromDescriptor = exports.expressionFromDescriptor = function expressionFromDescriptor(descriptor) {
  var lineDescriptor = descriptor.match(lineExpressionRegex);
  var maybeB = parseInt(lineDescriptor[3], 10);
  var maybeMultiplier = parseInt(lineDescriptor[1], 10);
  var multiplier = isNaN(maybeMultiplier) ? lineDescriptor[2] === undefined ? 0 : 1 : maybeMultiplier;
  var b = isNaN(maybeB) ? 0 : maybeB;

  // it's a constant, no variable found
  if (lineDescriptor[2] === undefined) {
    b = multiplier;
    multiplier = 0;
  }

  return new Expression(multiplier, b);
};

var hasLine = exports.hasLine = function hasLine(lines, line) {
  return lineIndex(lines, line) !== -1;
};

var removeLine = exports.removeLine = function removeLine(lines, line) {
  var index = lineIndex(lines, line);
  if (index === -1) {
    return lines;
  }
  var out = lines.slice();
  out.splice(index, 1);
  return out;
};

var removeLines = exports.removeLines = function removeLines(lines, toRemove) {
  log('[removeLines] points: ', lines, toRemove);
  toRemove = Array.isArray(toRemove) ? toRemove : [toRemove];
  var out = lines.filter(function (p) {
    return !hasLine(toRemove, p);
  });
  log('[removePoints] points: ', out);
  return out;
};

var pointsEqual = exports.pointsEqual = function pointsEqual(a, b) {
  return a.x == b.x && a.y == b.y;
};

var linesEqual = exports.linesEqual = function linesEqual(a, b) {
  return pointsEqual(a.from, b.from) && pointsEqual(a.to, b.to);
};

var lineIndex = exports.lineIndex = function lineIndex(lines, line) {
  return lines.findIndex(function (l) {
    return linesEqual(l, line);
  });
};

var swapLine = exports.swapLine = function swapLine(lines, from, to) {
  return (0, _utils.swap)(lines, from, to, lineIndex);
};