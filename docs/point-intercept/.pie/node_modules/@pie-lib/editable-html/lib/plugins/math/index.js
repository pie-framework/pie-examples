'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serialization = exports.inlineMath = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = MathPlugin;

var _Functions = require('@material-ui/icons/Functions');

var _Functions2 = _interopRequireDefault(_Functions);

var _slate = require('slate');

var _mathPreview = require('./math-preview');

var _mathPreview2 = _interopRequireDefault(_mathPreview);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _mathToolbar = require('./math-toolbar');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('editable-html:plugins:math');

var TEXT_NODE = 3;

function MathPlugin() /*options*/{
  return {
    toolbar: {
      icon: _react2.default.createElement(_Functions2.default, null),
      onClick: function onClick(value, onChange) {
        log('[insertMath]');
        var math = inlineMath();
        var change = value.change().insertInline(math);
        onChange(change);
      },
      supports: function supports(node) {
        return node && node.object === 'inline' && node.type === 'math';
      },
      /**
       * Return a react component function
       * @param node {Slate.Node}
       * @param toolbarDone {Function} a function to call once the toolbar has made any changes, call with the node.key and a data object.
       */
      customToolbar: function customToolbar(node, toolbarDone) {
        if (node && node.object === 'inline' && node.type === 'math') {
          var latex = node.data.get('latex');
          var onDone = function onDone(latex) {
            var update = _extends({}, node.data.toObject(), {
              latex: latex
            });
            toolbarDone(node.key, update);
          };

          var Tb = function Tb() {
            return _react2.default.createElement(_mathToolbar.MathToolbar, { latex: latex, onDone: onDone });
          };
          return Tb;
        }
      },

      /**
       * This method takes the output of customToolbars onDone method + a Slate.Value object.
       * @returns {Slate.Change} a change object
       */
      applyChange: function applyChange(nodeKey, nodeData, value) {
        return value.change().setNodeByKey(nodeKey, { data: nodeData });
      }
    },
    schema: {
      document: { types: ['math'] }
    },

    renderNode: function renderNode(props) {
      if (props.node.type === 'math') {
        log('[renderNode]: data:', props.node.data);
        return _react2.default.createElement(_mathPreview2.default, props);
      }
    }
  };
}

var inlineMath = exports.inlineMath = function inlineMath() {
  return _slate.Inline.create({
    object: 'inline',
    type: 'math',
    isVoid: true,
    data: {
      latex: '1 + 1 = 2'
    }
  });
};

var serialization = exports.serialization = {
  deserialize: function deserialize(el) {
    if (el.nodeType === TEXT_NODE) {
      return;
    }

    var tagName = el.tagName.toLowerCase();
    log('[deserialize] name: ', tagName);
    var hasMathJaxAttribute = el.getAttribute('mathjax') !== undefined || el.getAttribute('data-mathjax') !== undefined;

    log('[deserialize] hasMathJaxAttribute: ', hasMathJaxAttribute);
    if (tagName === 'span' && hasMathJaxAttribute) {
      return {
        object: 'inline',
        type: 'math',
        isVoid: true,
        nodes: [],
        data: {
          latex: el.innerHTML
        }
      };
    }
  },
  serialize: function serialize(object) {
    if (object.type === 'math') {
      return _react2.default.createElement(
        'span',
        { 'data-mathjax': '' },
        object.data.get('latex')
      );
    }
  }
};