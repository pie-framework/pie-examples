'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.serialization = exports.unwrap = exports.wrap = exports.inlineMath = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _PAIRS;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = MathPlugin;

var _Functions = require('@material-ui/icons/Functions');

var _Functions2 = _interopRequireDefault(_Functions);

var _slate = require('slate');

var _mathPreview = require('./math-preview');

var _mathPreview2 = _interopRequireDefault(_mathPreview);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _mathToolbar = require('./math-toolbar');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var log = (0, _debug2.default)('@pie-lib:editable-html:plugins:math');

var TEXT_NODE = 3;

function MathPlugin() /*options*/{
  return {
    toolbar: {
      icon: _react2.default.createElement(_Functions2.default, null),
      onClick: function onClick(value, onChange) {
        log('[insertMath]');
        var math = inlineMath();
        var change = value.change().insertInline(math);
        onChange(change);
      },
      supports: function supports(node) {
        return node && node.object === 'inline' && node.type === 'math';
      },
      /**
       * Return a react component function
       * @param node {Slate.Node}
       * @param value {Slate.Value}
       * @param onDone {(change?: Slate.Change, finishEditing :boolea) => void} - a function to call once the toolbar has made any changes, call with the node.key and a data object.
       */
      customToolbar: function customToolbar(node, value, onToolbarDone) {
        if (node && node.object === 'inline' && node.type === 'math') {
          var latex = node.data.get('latex');
          var onDone = function onDone(latex) {
            var update = _extends({}, node.data.toObject(), {
              latex: latex
            });
            var change = value.change().setNodeByKey(node.key, { data: update });
            onToolbarDone(change, true);
          };

          var Tb = function Tb() {
            return _react2.default.createElement(_mathToolbar.MathToolbar, { latex: latex, onDone: onDone });
          };
          return Tb;
        }
      }
    },
    schema: {
      document: { match: [{ type: 'math' }] }
    },

    renderNode: function renderNode(props) {
      if (props.node.type === 'math') {
        log('[renderNode]: data:', props.node.data);
        return _react2.default.createElement(_mathPreview2.default, props);
      }
    }
  };
}

MathPlugin.ROUND_BRACKETS = 'round_brackets';
MathPlugin.SQUARE_BRACKETS = 'square_brackets';
MathPlugin.DOLLAR = 'dollar';
MathPlugin.DOUBLE_DOLLAR = 'double_dollar';

var inlineMath = exports.inlineMath = function inlineMath() {
  return _slate.Inline.create({
    object: 'inline',
    type: 'math',
    isVoid: true,
    data: {
      latex: '1 + 1 = 2'
    }
  });
};

var htmlDecode = function htmlDecode(input) {
  var doc = new DOMParser().parseFromString(input, 'text/html');
  return doc.documentElement.textContent;
};

var PAIRS = (_PAIRS = {}, _defineProperty(_PAIRS, MathPlugin.ROUND_BRACKETS, ['\\(', '\\)']), _defineProperty(_PAIRS, MathPlugin.SQUARE_BRACKETS, ['\\[', '\\]']), _defineProperty(_PAIRS, MathPlugin.DOLLAR, ['$', '$']), _defineProperty(_PAIRS, MathPlugin.DOUBLE_DOLLAR, ['$$', '$$']), _PAIRS);

var wrap = exports.wrap = function wrap(content, wrapType) {
  if (wrapType === MathPlugin.SQUARE_BRACKETS) {
    console.warn('\\[...\\] is not supported yet'); // eslint-disable-line
    wrapType = MathPlugin.ROUND_BRACKETS;
  }
  if (wrapType === MathPlugin.DOUBLE_DOLLAR) {
    console.warn('$$...$$ is not supported yet'); // eslint-disable-line
    wrapType = MathPlugin.DOLLAR;
  }

  var _ref = PAIRS[wrapType] || PAIRS[MathPlugin.ROUND_BRACKETS],
      _ref2 = _slicedToArray(_ref, 2),
      start = _ref2[0],
      end = _ref2[1];

  return '' + start + content + end;
};

var unwrap = exports.unwrap = function unwrap(content) {
  var displayStyleIndex = content.indexOf('\\displaystyle');
  if (displayStyleIndex !== -1) {
    console.warn('\\displaystyle is not supported - removing'); // eslint-disable-line
    content = content.replace('\\displaystyle', '').trim();
  }

  if (content.startsWith('$$') && content.endsWith('$$')) {
    console.warn('$$ syntax is not yet supported'); // eslint-disable-line
    return {
      unwrapped: content.substring(2, content.length - 2),
      wrapType: MathPlugin.DOLLAR
    };
  }
  if (content.startsWith('$') && content.endsWith('$')) {
    return {
      unwrapped: content.substring(1, content.length - 1),
      wrapType: MathPlugin.DOLLAR
    };
  }

  if (content.startsWith('\\[') && content.endsWith('\\]')) {
    console.warn('\\[..\\] syntax is not yet supported'); // eslint-disable-line
    return {
      unwrapped: content.substring(2, content.length - 2),
      wrapType: MathPlugin.ROUND_BRACKETS
    };
  }

  if (content.startsWith('\\(') && content.endsWith('\\)')) {
    return {
      unwrapped: content.substring(2, content.length - 2),
      wrapType: MathPlugin.ROUND_BRACKETS
    };
  }

  return {
    unwrapped: content,
    wrapType: MathPlugin.ROUND_BRACKETS
  };
};

var serialization = exports.serialization = {
  deserialize: function deserialize(el) {
    if (el.nodeType === TEXT_NODE) {
      return;
    }

    var tagName = el.tagName.toLowerCase();
    log('[deserialize] name: ', tagName);

    if (tagName !== 'span') {
      return;
    }

    var hasLatex = el.hasAttribute('data-latex') || el.hasAttribute('latex');

    if (hasLatex) {
      var latex = htmlDecode(el.innerHTML);

      var _unwrap = unwrap(latex),
          unwrapped = _unwrap.unwrapped,
          wrapType = _unwrap.wrapType;

      log('[deserialize]: noBrackets: ', unwrapped, wrapType);
      return {
        object: 'inline',
        type: 'math',
        isVoid: true,
        nodes: [],
        data: {
          latex: unwrapped,
          wrapper: wrapType
        }
      };
    }
  },
  serialize: function serialize(object) {
    if (object.type === 'math') {
      var l = object.data.get('latex');
      var wrapper = object.data.get('wrapper');
      log('[serialize] latex: ', l);
      var decoded = htmlDecode(l);
      return _react2.default.createElement(
        'span',
        { 'data-latex': '', 'data-raw': decoded },
        wrap(decoded, wrapper)
      );
    }
  }
};