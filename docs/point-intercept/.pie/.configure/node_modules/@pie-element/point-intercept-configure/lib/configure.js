'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _styles = require('@material-ui/core/styles');

var _chartingConfig = require('@pie-lib/charting-config');

var _chartingConfig2 = _interopRequireDefault(_chartingConfig);

var _scoringConfig = require('@pie-lib/scoring-config');

var _scoringConfig2 = _interopRequireDefault(_scoringConfig);

var _configUi = require('@pie-lib/config-ui');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _reactSwipeableViews = require('react-swipeable-views');

var _reactSwipeableViews2 = _interopRequireDefault(_reactSwipeableViews);

var _Tabs = require('@material-ui/core/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Tab = require('@material-ui/core/Tab');

var _Tab2 = _interopRequireDefault(_Tab);

var _Typography = require('@material-ui/core/Typography');

var _Typography2 = _interopRequireDefault(_Typography);

var _generalConfigBlock = require('./general-config-block');

var _generalConfigBlock2 = _interopRequireDefault(_generalConfigBlock);

var _pointConfig = require('./point-config');

var _pointConfig2 = _interopRequireDefault(_pointConfig);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _debug2.default)('@pie-element:text-entry:configure');

const styles = theme => ({
  title: {
    fontSize: '1.1rem',
    display: 'block',
    marginTop: theme.spacing.unit * 2,
    marginBottom: theme.spacing.unit
  },
  tab: {
    marginTop: theme.spacing.unit * 2
  }
});

class Configure extends _react2.default.Component {

  constructor(props) {
    super(props);

    this.resetToDefaults = () => {
      this.props.onModelChanged(JSON.parse(JSON.stringify(this.defaults)));
    };

    this.onTabChange = (event, value) => {
      this.setState({ activeTab: value });
    };

    this.onChangeTabIndex = index => {
      this.setState({ activeTab: index });
    };

    this.onModelConfigChange = name => event => {
      this.props.model.model.config[name] = event.target.checked;
      this.props.onModelChanged(this.props.model);
    };

    this.onChange = (config, fieldName) => {
      const newValue = parseInt(config[fieldName], 10);
      const points = this.props.model.correctResponse;
      const newPoints = [];

      points.forEach(point => {
        var _point$split = point.split(','),
            _point$split2 = _slicedToArray(_point$split, 2);

        let pointX = _point$split2[0],
            pointY = _point$split2[1];

        pointX = parseInt(pointX, 10);
        pointY = parseInt(pointY, 10);

        switch (fieldName) {
          case 'domainMin':
            {
              if (pointX < newValue) {
                point = `${newValue},${pointY}`;
              }

              break;
            }

          case 'domainMax':
            {
              if (pointX > newValue) {
                point = `${newValue},${pointY}`;
              }

              break;
            }
          case 'rangeMin':
            {
              if (pointY < newValue) {
                point = `${pointX},${newValue}`;
              }

              break;
            }
          case 'rangeMax':
            {
              if (pointY > newValue) {
                point = `${pointX},${newValue}`;
              }

              break;
            }
        }

        newPoints.push(point);
      });

      this.props.model.correctResponse = newPoints;
      this.props.model.model.config = _extends({}, config);
      this.props.onModelChanged(this.props.model);
    };

    this.onPointLabelChange = index => event => {
      const config = this.props.model.model.config;
      config.pointLabels[index] = event.target.value;
      this.props.onModelChanged(this.props.model);
    };

    this.onPointValueChange = (pointIndex, pointCoordinateIndex) => event => {
      const points = this.props.model.correctResponse;

      var _points$pointIndex$sp = points[pointIndex].split(','),
          _points$pointIndex$sp2 = _slicedToArray(_points$pointIndex$sp, 2);

      const pointX = _points$pointIndex$sp2[0],
            pointY = _points$pointIndex$sp2[1];

      const newValue = parseInt(event.target.value, 10);

      if (!isNaN(newValue)) {
        if (pointCoordinateIndex === 0) {
          points[pointIndex] = `${newValue},${pointY}`;
        } else {
          points[pointIndex] = `${pointX},${newValue}`;
        }

        this.props.onModelChanged(this.props.model);
      }
    };

    this.addPoint = () => {
      this.props.model.correctResponse.push('0,0');
      this.props.model.model.config.pointLabels.push('');
      this.props.onModelChanged(this.props.model);
    };

    this.deletePoint = pointIndex => () => {
      const points = this.props.model.correctResponse;
      points.splice(pointIndex, 1);
      this.props.onModelChanged(this.props.model);
    };

    this.onMaxPointsChange = event => {
      const config = this.props.model.model.config;
      const newValue = parseInt(event.target.value, 10);

      if (!isNaN(newValue)) {
        config.maxPoints = newValue;

        this.props.onModelChanged(this.props.model);
      }
    };

    this.onFeedbackChange = feedback => {
      var _props = this.props;
      const model = _props.model,
            onModelChanged = _props.onModelChanged;

      model.feedback = feedback;
      onModelChanged(model);
    };

    this.onToggleWithLabels = setTrue => () => {
      this.setState({
        withLabels: setTrue
      });
    };

    this.onPartialScoringChange = partialScoring => {
      this.props.model.partialScoring = partialScoring.map(partialScore => ({
        numberOfCorrect: partialScore.numberOfCorrect || '',
        scorePercentage: partialScore.scorePercentage || ''
      }));

      this.props.onModelChanged(this.props.model);
    };

    this.defaults = JSON.parse(JSON.stringify(props.model));
    this.state = {
      activeTab: 0,
      withLabels: true
    };
  }

  render() {
    var _props2 = this.props;
    const classes = _props2.classes,
          model = _props2.model;

    const config = model.model.config;

    log('[render] model', model);

    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement(
        _Tabs2.default,
        {
          value: this.state.activeTab,
          onChange: this.onTabChange,
          indicatorColor: 'primary',
          textColor: 'primary',
          fullWidth: true
        },
        _react2.default.createElement(_Tab2.default, { label: 'Design' }),
        _react2.default.createElement(_Tab2.default, { disabled: !config.allowPartialScoring, label: 'Scoring' })
      ),
      _react2.default.createElement(
        _reactSwipeableViews2.default,
        {
          axis: 'x',
          index: this.state.activeTab,
          onChangeIndex: this.onChangeTabIndex
        },
        _react2.default.createElement(
          'div',
          { className: classes.tab },
          _react2.default.createElement(
            _Typography2.default,
            { component: 'div', type: 'body1' },
            _react2.default.createElement(
              'span',
              null,
              'In Plot Points, students identify coordinates or plot points on a graph by clicking on the graph.'
            ),
            _react2.default.createElement(
              'h2',
              null,
              'Points'
            )
          ),
          _react2.default.createElement(_generalConfigBlock2.default, {
            config: config,
            onToggleWithLabels: this.onToggleWithLabels,
            onModelConfigChange: this.onModelConfigChange,
            withLabels: this.state.withLabels
          }),
          _react2.default.createElement(_pointConfig2.default, {
            withLabels: this.state.withLabels,
            model: model,
            config: config,
            addPoint: this.addPoint,
            onMaxPointsChange: this.onMaxPointsChange,
            deletePoint: this.deletePoint,
            onPointValueChange: this.onPointValueChange,
            onPointLabelChange: this.onPointLabelChange
          }),
          _react2.default.createElement(_chartingConfig2.default, {
            config: config,
            onChange: this.onChange,
            resetToDefaults: this.resetToDefaults
          }),
          _react2.default.createElement(_configUi.FeedbackConfig, {
            feedback: model.feedback,
            onChange: this.onFeedbackChange
          })
        ),
        _react2.default.createElement(
          'div',
          { className: classes.tab },
          _react2.default.createElement(_scoringConfig2.default, {
            numberOfCorrectResponses: model.correctResponse.length,
            partialScoring: model.partialScoring,
            onChange: this.onPartialScoringChange
          })
        )
      )
    );
  }
}

Configure.propTypes = {
  onModelChanged: _propTypes2.default.func,
  classes: _propTypes2.default.object,
  model: _propTypes2.default.object.isRequired
};
const ConfigureMain = (0, _styles.withStyles)(styles)(Configure);

class StateWrapper extends _react2.default.Component {

  constructor(props) {
    super(props);

    this.state = {
      model: props.model
    };

    this.onModelChanged = m => {
      this.setState({ model: m }, () => {
        this.props.onModelChanged(this.state.model);
      });
    };
  }

  render() {
    const model = this.state.model;

    return _react2.default.createElement(ConfigureMain, { model: model, onModelChanged: this.onModelChanged });
  }
}

StateWrapper.propTypes = {
  model: _propTypes2.default.any,
  onModelChanged: _propTypes2.default.func
};
exports.default = StateWrapper;