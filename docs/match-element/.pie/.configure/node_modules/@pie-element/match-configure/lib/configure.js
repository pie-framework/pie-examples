'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _styles = require('@material-ui/core/styles');

var _configUi = require('@pie-lib/config-ui');

var _scoringConfig = require('@pie-lib/scoring-config');

var _scoringConfig2 = _interopRequireDefault(_scoringConfig);

var _reactSwipeableViews = require('react-swipeable-views');

var _reactSwipeableViews2 = _interopRequireDefault(_reactSwipeableViews);

var _Tabs = require('@material-ui/core/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Tab = require('@material-ui/core/Tab');

var _Tab2 = _interopRequireDefault(_Tab);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _Typography = require('@material-ui/core/Typography');

var _Typography2 = _interopRequireDefault(_Typography);

var _generalConfigBlock = require('./general-config-block');

var _generalConfigBlock2 = _interopRequireDefault(_generalConfigBlock);

var _answerConfigBlock = require('./answer-config-block');

var _answerConfigBlock2 = _interopRequireDefault(_answerConfigBlock);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _debug2.default)('@pie-element:match:configure');

const styles = theme => ({
  title: {
    fontSize: '1.1rem',
    display: 'block',
    marginTop: theme.spacing.unit * 2,
    marginBottom: theme.spacing.unit
  },
  content: {
    marginTop: theme.spacing.unit * 2
  }
});

class Configure extends _react2.default.Component {

  constructor(props) {
    super(props);

    this.onTabChange = (event, value) => {
      this.setState({ activeTab: value });
    };

    this.onChangeTabIndex = index => {
      this.setState({ activeTab: index });
    };

    this.onChange = model => {
      this.props.onModelChanged(model);
    };

    this.onFeedbackChange = feedback => {
      var _props = this.props;
      const model = _props.model,
            onModelChanged = _props.onModelChanged;

      model.feedback = feedback;
      onModelChanged(model);
    };

    this.onDeleteRow = rowIndex => {
      const model = this.props.model;


      const newModel = _extends({}, model);

      newModel.rows.splice(rowIndex, 1);

      this.onChange(newModel);
    };

    this.onAddRow = () => {
      const model = this.props.model;

      const newModel = _extends({}, model);

      newModel.rows = newModel.rows.concat({
        id: this.rowIdCounter + 1,
        title: `Question Text ${newModel.rows.length + 1}`,
        values: new Array(model.layout - 1).fill(false)
      });

      this.rowIdCounter += 1;

      this.onChange(newModel);
    };

    this.onLayoutChange = newLayout => {
      const model = this.props.model;

      const oldLayout = model.layout;
      const newModel = _extends({}, model);

      if (newLayout > oldLayout) {
        for (let i = 0; i < newLayout - oldLayout; i++) {
          newModel.headers.push(`Column ${newModel.headers.length + 1}`);
        }

        newModel.rows.forEach(row => {
          for (let i = 0; i < newLayout - oldLayout; i++) {
            row.values.push(false);
          }
        });
      } else if (newLayout < oldLayout) {
        newModel.headers.splice(newLayout);

        newModel.rows.forEach(row => {
          row.values.splice(newLayout - 1);
        });
      }

      newModel.layout = newLayout;

      this.onChange(newModel);
    };

    this.onResponseTypeChange = newResponseType => {
      const model = this.props.model;

      const newModel = _extends({}, model);

      // if we're switching to radio and we have more than one true, reset
      if (newResponseType === 'radio') {
        newModel.rows.forEach(row => {
          const trueCount = row.values.reduce((total, current) => current === true ? total + 1 : total);

          if (trueCount > 1) {
            row.values = new Array(model.layout - 1).fill(false);
          }
        });
      }

      newModel.responseType = newResponseType;

      this.onChange(newModel);
    };

    this.onPartialScoringChange = partialScoring => {
      this.props.model.partialScoring = partialScoring.map(partialScore => ({
        numberOfCorrect: partialScore.numberOfCorrect || '',
        scorePercentage: partialScore.scorePercentage || ''
      }));

      this.props.onModelChanged(this.props.model);
    };

    this.rowIdCounter = props.model.rows[props.model.rows.length - 1].id + 1;

    this.state = {
      activeTab: 0
    };
  }

  render() {
    var _props2 = this.props;
    const classes = _props2.classes,
          model = _props2.model;


    log('[render] model', model);

    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement(
        _Tabs2.default,
        {
          value: this.state.activeTab,
          onChange: this.onTabChange,
          indicatorColor: 'primary',
          textColor: 'primary',
          fullWidth: true
        },
        _react2.default.createElement(_Tab2.default, { label: 'Design' }),
        _react2.default.createElement(_Tab2.default, { disabled: !model.allowPartialScoring, label: 'Scoring' })
      ),
      _react2.default.createElement(
        _reactSwipeableViews2.default,
        {
          axis: 'x',
          index: this.state.activeTab,
          onChangeIndex: this.onChangeTabIndex
        },
        _react2.default.createElement(
          'div',
          { className: classes.tab },
          _react2.default.createElement(
            'div',
            { className: classes.content },
            _react2.default.createElement(
              _Typography2.default,
              { component: 'div', type: 'body1' },
              _react2.default.createElement(
                'span',
                null,
                'In Choice Matrix, students associate choices in the first column with options in the adjacent rows. This interaction allows for either one or more correct answers. Setting more than one answer as correct allows for partial credit ',
                _react2.default.createElement(
                  'i',
                  null,
                  '(see the Scoring tab)'
                ),
                '.'
              )
            ),
            _react2.default.createElement(_generalConfigBlock2.default, {
              model: model,
              onResponseTypeChange: this.onResponseTypeChange,
              onLayoutChange: this.onLayoutChange
            }),
            _react2.default.createElement(_answerConfigBlock2.default, {
              model: model,
              onChange: this.onChange,
              onAddRow: this.onAddRow,
              onDeleteRow: this.onDeleteRow
            }),
            _react2.default.createElement(_configUi.FeedbackConfig, {
              feedback: model.feedback,
              onChange: this.onFeedbackChange
            })
          )
        ),
        _react2.default.createElement(
          'div',
          { className: classes.tab },
          _react2.default.createElement(_scoringConfig2.default, {
            numberOfCorrectResponses: model.rows.length,
            partialScoring: model.partialScoring,
            onChange: this.onPartialScoringChange
          })
        )
      )
    );
  }
}

Configure.propTypes = {
  onModelChanged: _propTypes2.default.func,
  classes: _propTypes2.default.object,
  model: _propTypes2.default.object.isRequired
};
const ConfigureMain = (0, _styles.withStyles)(styles)(Configure);

class StateWrapper extends _react2.default.Component {

  constructor(props) {
    super(props);

    this.state = {
      model: props.model
    };

    this.onModelChanged = m => {
      this.setState({ model: m }, () => {
        this.props.onModelChanged(this.state.model);
      });
    };
  }

  render() {
    const model = this.state.model;

    return _react2.default.createElement(ConfigureMain, { model: model, onModelChanged: this.onModelChanged });
  }
}

StateWrapper.propTypes = {
  model: _propTypes2.default.any,
  onModelChanged: _propTypes2.default.func
};
exports.default = StateWrapper;