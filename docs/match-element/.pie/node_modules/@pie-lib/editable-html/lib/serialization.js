'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.valueToHtml = exports.htmlToValue = undefined;

var _slateHtmlSerializer = require('slate-html-serializer');

var _slateHtmlSerializer2 = _interopRequireDefault(_slateHtmlSerializer);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _image = require('./plugins/image');

var _math = require('./plugins/math');

var _list = require('./plugins/list');

var _slate = require('slate');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('editable-html:serialization');

/**
 * Tags to blocks.
 *
 * @type {Object}
 */

var BLOCK_TAGS = {
  div: 'div',
  span: 'span',
  p: 'paragraph',
  blockquote: 'quote',
  pre: 'code',
  h1: 'heading-one',
  h2: 'heading-two',
  h3: 'heading-three',
  h4: 'heading-four',
  h5: 'heading-five',
  h6: 'heading-six'
};

/**
 * Tags to marks.
 *
 * @type {Object}
 */

var MARK_TAGS = {
  b: 'bold',
  em: 'italic',
  u: 'underline',
  s: 'strikethrough',
  code: 'code'
};

/**
 * Serializer rules.
 *
 * @type {Array}
 */

var blocks = {
  deserialize: function deserialize(el, next) {
    log('[blocks:deserialize] block: ', el);
    var block = BLOCK_TAGS[el.tagName.toLowerCase()];
    if (!block) return;
    log('[blocks:deserialize] block: ', block);

    if (el.childNodes.length === 1) {
      var cn = el.childNodes[0];
      if (cn && cn.tagName && cn.tagName.toLowerCase() === block) {
        log('[we have a child node of the same]...');
        return;
      }
    }
    return {
      object: 'block',
      type: block,
      nodes: next(el.childNodes)
    };
  },

  serialize: function serialize(object, children) {
    if (object.object !== 'block') return;

    log('[blocks:serialize] object: ', object, children);
    for (var key in BLOCK_TAGS) {
      if (BLOCK_TAGS[key] === object.type) {
        var Tag = key;
        return _react2.default.createElement(
          Tag,
          null,
          children
        );
      }
    }
  }
};

var marks = {
  deserialize: function deserialize(el, next) {
    var mark = MARK_TAGS[el.tagName.toLowerCase()];
    if (!mark) return;
    log('[deserialize] mark: ', mark);
    return {
      object: 'mark',
      type: mark,
      nodes: next(el.childNodes)
    };
  },
  serialize: function serialize(object, children) {
    if (_slate.Mark.isMark(object)) {
      for (var key in MARK_TAGS) {
        if (MARK_TAGS[key] === object.type) {
          var Tag = key;
          return _react2.default.createElement(
            Tag,
            null,
            children
          );
        }
      }
    }
  }
};

var TEXT_RULE = {
  deserialize: function deserialize(el) {
    if (el.tagName && el.tagName.toLowerCase() === 'br') {
      return {
        object: 'text',
        leaves: [{
          object: 'leaf',
          text: '\n'
        }]
      };
    }

    if (el.nodeName == '#text') {
      if (el.nodeValue && el.nodeValue.match(/<!--.*?-->/)) return;

      log('[text:deserialize] return text object..');
      return {
        object: 'text',
        leaves: [{
          object: 'leaf',
          text: el.nodeValue
        }]
      };
    }
  },
  serialize: function serialize(obj, children) {
    if (obj.object === 'string') {
      return children.split('\n').reduce(function (array, text, i) {
        if (i != 0) array.push(_react2.default.createElement('br', null));
        array.push(text);
        return array;
      }, []);
    }
  }
};

var RULES = [_list.serialization, _math.serialization, _image.serialization, TEXT_RULE, blocks, marks];

function defaultParseHtml(html) {
  if (typeof DOMParser === 'undefined') {
    throw new Error('The native `DOMParser` global which the `Html` serializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.');
  }

  var parsed = new DOMParser().parseFromString(html, 'text/html');
  var body = parsed.body;

  return body;
}

/** If this lib is used on the server side, we need to bypass using the DOMParser - just put in a stub. */
var parseHtml = typeof window === 'undefined' ? function () {
  return {
    childNodes: []
  };
} : defaultParseHtml;

var serializer = new _slateHtmlSerializer2.default({
  defaultBlock: 'div',
  rules: RULES,
  parseHtml: parseHtml
});

var htmlToValue = exports.htmlToValue = function htmlToValue(html) {
  return serializer.deserialize(html);
};
var valueToHtml = exports.valueToHtml = function valueToHtml(value) {
  return serializer.serialize(value);
};