'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _server = require('react-dom/server');

var _server2 = _interopRequireDefault(_server);

var _typeOf = require('type-of');

var _typeOf2 = _interopRequireDefault(_typeOf);

var _slate = require('slate');

var _immutable = require('immutable');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * String.
 *
 * @type {String}
 */

var String = new _immutable.Record({
  kind: 'string',
  text: ''
});

/**
 * A rule to (de)serialize text nodes. This is automatically added to the HTML
 * serializer so that users don't have to worry about text-level serialization.
 *
 * @type {Object}
 */

var TEXT_RULE = {
  deserialize: function deserialize(el) {
    if (el.tagName && el.tagName.toLowerCase() === 'br') {
      return {
        kind: 'text',
        leaves: [{
          kind: 'leaf',
          text: '\n'
        }]
      };
    }

    if (el.nodeName == '#text') {
      if (el.value && el.value.match(/<!--.*?-->/)) return;

      return {
        kind: 'text',
        leaves: [{
          kind: 'leaf',
          text: el.value || el.nodeValue
        }]
      };
    }
  },
  serialize: function serialize(obj, children) {
    if (obj.kind === 'string') {
      return children.split('\n').reduce(function (array, text, i) {
        if (i != 0) array.push(_react2.default.createElement('br', null));
        array.push(text);
        return array;
      }, []);
    }
  }
};

/**
 * A default `parseHtml` function that returns the `<body>` using `DOMParser`.
 *
 * @param {String} html
 * @return {Object}
 */

function defaultParseHtml(html) {
  if (typeof DOMParser === 'undefined') {
    throw new Error('The native `DOMParser` global which the `Html` serializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.');
  }

  var parsed = new DOMParser().parseFromString(html, 'text/html');
  var body = parsed.body;

  return body;
}

/**
 * HTML serializer.
 *
 * @type {Html}
 */

var Html =

/**
 * Create a new serializer with `rules`.
 *
 * @param {Object} options
 *   @property {Array} rules
 *   @property {String|Object|Block} defaultBlock
 *   @property {Function} parseHtml
 */

function Html() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  _classCallCheck(this, Html);

  _initialiseProps.call(this);

  var _options$defaultBlock = options.defaultBlock,
      defaultBlock = _options$defaultBlock === undefined ? 'paragraph' : _options$defaultBlock,
      _options$parseHtml = options.parseHtml,
      parseHtml = _options$parseHtml === undefined ? defaultParseHtml : _options$parseHtml,
      _options$rules = options.rules,
      rules = _options$rules === undefined ? [] : _options$rules;


  defaultBlock = _slate.Node.createProperties(defaultBlock);

  this.rules = [].concat(_toConsumableArray(rules), [TEXT_RULE]);
  this.defaultBlock = defaultBlock;
  this.parseHtml = parseHtml;
}

/**
 * Deserialize pasted HTML.
 *
 * @param {String} html
 * @param {Object} options
 *   @property {Boolean} toRaw
 * @return {Value}
 */

/**
 * Deserialize an array of DOM elements.
 *
 * @param {Array} elements
 * @return {Array}
 */

/**
 * Deserialize a DOM element.
 *
 * @param {Object} element
 * @return {Any}
 */

/**
 * Deserialize a `mark` object.
 *
 * @param {Object} mark
 * @return {Array}
 */

/**
 * Serialize a `value` object into an HTML string.
 *
 * @param {Value} value
 * @param {Object} options
 *   @property {Boolean} render
 * @return {String|Array}
 */

/**
 * Serialize a `node`.
 *
 * @param {Node} node
 * @return {String}
 */

/**
 * Serialize a `leaf`.
 *
 * @param {Leaf} leaf
 * @return {String}
 */

/**
 * Serialize a `string`.
 *
 * @param {String} string
 * @return {String}
 */

/**
 * Filter out cruft newline nodes inserted by the DOM parser.
 *
 * @param {Object} element
 * @return {Boolean}
 */

;

/**
 * Add a unique key to a React `element`.
 *
 * @param {Element} element
 * @return {Element}
 */

var _initialiseProps = function _initialiseProps() {
  var _this = this;

  this.deserialize = function (html) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$toJSON = options.toJSON,
        toJSON = _options$toJSON === undefined ? false : _options$toJSON;
    var defaultBlock = _this.defaultBlock,
        parseHtml = _this.parseHtml;

    var fragment = parseHtml(html);
    var children = Array.from(fragment.childNodes);
    var nodes = _this.deserializeElements(children);

    // COMPAT: ensure that all top-level inline nodes are wrapped into a block.
    nodes = nodes.reduce(function (memo, node, i, original) {
      if (node.kind == 'block') {
        memo.push(node);
        return memo;
      }

      if (i > 0 && original[i - 1].kind != 'block') {
        var _block = memo[memo.length - 1];
        _block.nodes.push(node);
        return memo;
      }

      var block = _extends({
        kind: 'block',
        data: {},
        isVoid: false
      }, defaultBlock, {
        nodes: [node]
      });

      memo.push(block);
      return memo;
    }, []);

    // TODO: pretty sure this is no longer needed.
    if (nodes.length == 0) {
      nodes = [_extends({
        kind: 'block',
        data: {},
        isVoid: false
      }, defaultBlock, {
        nodes: [{
          kind: 'text',
          leaves: [{
            kind: 'leaf',
            text: '',
            marks: []
          }]
        }]
      })];
    }

    var json = {
      kind: 'value',
      document: {
        kind: 'document',
        data: {},
        nodes: nodes
      }
    };

    var ret = toJSON ? json : _slate.Value.fromJSON(json);
    return ret;
  };

  this.deserializeElements = function () {
    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var nodes = [];

    elements.filter(_this.cruftNewline).forEach(function (element) {
      var node = _this.deserializeElement(element);
      switch ((0, _typeOf2.default)(node)) {
        case 'array':
          nodes = nodes.concat(node);
          break;
        case 'object':
          nodes.push(node);
          break;
      }
    });

    return nodes;
  };

  this.deserializeElement = function (element) {
    var node = void 0;

    if (!element.tagName) {
      element.tagName = '';
    }

    var next = function next(elements) {
      if (Object.prototype.toString.call(elements) == '[object NodeList]') {
        elements = Array.from(elements);
      }

      switch ((0, _typeOf2.default)(elements)) {
        case 'array':
          return _this.deserializeElements(elements);
        case 'object':
          return _this.deserializeElement(elements);
        case 'null':
        case 'undefined':
          return;
        default:
          throw new Error('The `next` argument was called with invalid children: "' + elements + '".');
      }
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _this.rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var rule = _step.value;

        if (!rule.deserialize) continue;
        var ret = rule.deserialize(element, next);
        var type = (0, _typeOf2.default)(ret);

        if (type != 'array' && type != 'object' && type != 'null' && type != 'undefined') {
          throw new Error('A rule returned an invalid deserialized representation: "' + node + '".');
        }

        if (ret === undefined) {
          continue;
        } else if (ret === null) {
          return null;
        } else if (ret.kind == 'mark') {
          node = _this.deserializeMark(ret);
        } else {
          node = ret;
        }

        break;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return node || next(element.childNodes);
  };

  this.deserializeMark = function (mark) {
    var type = mark.type,
        data = mark.data;


    var applyMark = function applyMark(node) {
      if (node.kind == 'mark') {
        return _this.deserializeMark(node);
      } else if (node.kind == 'text') {
        node.leaves = node.leaves.map(function (leaf) {
          leaf.marks = leaf.marks || [];
          leaf.marks.push({ type: type, data: data });
          return leaf;
        });
      } else {
        node.nodes = node.nodes.map(applyMark);
      }

      return node;
    };

    return mark.nodes.reduce(function (nodes, node) {
      var ret = applyMark(node);
      if (Array.isArray(ret)) return nodes.concat(ret);
      nodes.push(ret);
      return nodes;
    }, []);
  };

  this.serialize = function (value) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var document = value.document;

    var elements = document.nodes.map(_this.serializeNode);
    if (options.render === false) return elements;

    var html = _server2.default.renderToStaticMarkup(_react2.default.createElement(
      'body',
      null,
      elements
    ));
    var inner = html.slice(6, -7);
    return inner;
  };

  this.serializeNode = function (node) {
    if (node.kind === 'text') {
      var leaves = node.getLeaves();
      return leaves.map(_this.serializeLeaf);
    }

    var children = node.nodes.map(_this.serializeNode);

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _this.rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var rule = _step2.value;

        if (!rule.serialize) continue;
        var ret = rule.serialize(node, children);
        if (ret) return addKey(ret);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    throw new Error('No serializer defined for node of type "' + node.type + '".');
  };

  this.serializeLeaf = function (leaf) {
    var string = new String({ text: leaf.text });
    var text = _this.serializeString(string);

    return leaf.marks.reduce(function (children, mark) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = _this.rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var rule = _step3.value;

          if (!rule.serialize) continue;
          var ret = rule.serialize(mark, children);
          if (ret) return addKey(ret);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      throw new Error('No serializer defined for mark of type "' + mark.type + '".');
    }, text);
  };

  this.serializeString = function (string) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = _this.rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var rule = _step4.value;

        if (!rule.serialize) continue;
        var ret = rule.serialize(string, string.text);
        if (ret) return ret;
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  };

  this.cruftNewline = function (element) {
    return !(element.nodeName === '#text' && element.value == '\n');
  };
};

var key = 0;

function addKey(element) {
  return _react2.default.cloneElement(element, { key: key++ });
}

/**
 * Export.
 *
 * @type {Html}
 */

exports.default = Html;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJTdHJpbmciLCJraW5kIiwidGV4dCIsIlRFWFRfUlVMRSIsImRlc2VyaWFsaXplIiwiZWwiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJsZWF2ZXMiLCJub2RlTmFtZSIsInZhbHVlIiwibWF0Y2giLCJub2RlVmFsdWUiLCJzZXJpYWxpemUiLCJvYmoiLCJjaGlsZHJlbiIsInNwbGl0IiwicmVkdWNlIiwiYXJyYXkiLCJpIiwicHVzaCIsImRlZmF1bHRQYXJzZUh0bWwiLCJodG1sIiwiRE9NUGFyc2VyIiwiRXJyb3IiLCJwYXJzZWQiLCJwYXJzZUZyb21TdHJpbmciLCJib2R5IiwiSHRtbCIsIm9wdGlvbnMiLCJkZWZhdWx0QmxvY2siLCJwYXJzZUh0bWwiLCJydWxlcyIsImNyZWF0ZVByb3BlcnRpZXMiLCJ0b0pTT04iLCJmcmFnbWVudCIsIkFycmF5IiwiZnJvbSIsImNoaWxkTm9kZXMiLCJub2RlcyIsImRlc2VyaWFsaXplRWxlbWVudHMiLCJtZW1vIiwibm9kZSIsIm9yaWdpbmFsIiwiYmxvY2siLCJsZW5ndGgiLCJkYXRhIiwiaXNWb2lkIiwibWFya3MiLCJqc29uIiwiZG9jdW1lbnQiLCJyZXQiLCJmcm9tSlNPTiIsImVsZW1lbnRzIiwiZmlsdGVyIiwiY3J1ZnROZXdsaW5lIiwiZm9yRWFjaCIsImVsZW1lbnQiLCJkZXNlcmlhbGl6ZUVsZW1lbnQiLCJjb25jYXQiLCJuZXh0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwicnVsZSIsInR5cGUiLCJ1bmRlZmluZWQiLCJkZXNlcmlhbGl6ZU1hcmsiLCJtYXJrIiwiYXBwbHlNYXJrIiwibWFwIiwibGVhZiIsImlzQXJyYXkiLCJzZXJpYWxpemVOb2RlIiwicmVuZGVyIiwicmVuZGVyVG9TdGF0aWNNYXJrdXAiLCJpbm5lciIsInNsaWNlIiwiZ2V0TGVhdmVzIiwic2VyaWFsaXplTGVhZiIsImFkZEtleSIsInN0cmluZyIs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LEVBQVk7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDNUIsNEJBQW1CLE1BQUtsRCxLQUF4QixtSUFBK0I7QUFBQSxZQUFwQmlDLElBQW9COztBQUM3QixZQUFJLENBQUNBLEtBQUtwRCxTQUFWLEVBQXFCO0FBQ3JCLFlBQU1zQyxNQUFNYyxLQUFLcEQsU0FBTCxDQUFlcUUsTUFBZixFQUF1QkEsT0FBT2hGLElBQTlCLENBQVo7QUFDQSxZQUFJaUQsR0FBSixFQUFTLE9BQU9BLEdBQVA7QUFDVjtBQUwyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTTdCLEc7O09BU0RJLFksR0FBZSxVQUFDRSxPQUFELEVBQWE7QUFDMUIsV0FBTyxFQUFFQSxRQUFRaEQsUUFBUixLQUFxQixPQUFyQixJQUFnQ2dELFFBQVEvQyxLQUFSLElBQWlCLElBQW5ELENBQVA7QUFDRCxHOzs7QUFXSCxJQUFJMEUsTUFBTSxDQUFWOztBQUVBLFNBQVNILE1BQVQsQ0FBZ0J4QixPQUFoQixFQUF5QjtBQUN2QixTQUFPLGdCQUFNNEIsWUFBTixDQUFtQjVCLE9BQW5CLEVBQTRCLEVBQUUyQixLQUFLQSxLQUFQLEVBQTVCLENBQVA7QUFDRDs7QUFFRDs7Ozs7O2tCQU1leEQsSSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NU2VydmVyIGZyb20gJ3JlYWN0LWRvbS9zZXJ2ZXInXG5pbXBvcnQgdHlwZU9mIGZyb20gJ3R5cGUtb2YnXG5pbXBvcnQgeyBOb2RlLCBWYWx1ZSB9IGZyb20gJ3NsYXRlJ1xuaW1wb3J0IHsgUmVjb3JkIH0gZnJvbSAnaW1tdXRhYmxlJ1xuXG4vKipcbiAqIFN0cmluZy5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5cbmNvbnN0IFN0cmluZyA9IG5ldyBSZWNvcmQoe1xuICBraW5kOiAnc3RyaW5nJyxcbiAgdGV4dDogJydcbn0pXG5cbi8qKlxuICogQSBydWxlIHRvIChkZSlzZXJpYWxpemUgdGV4dCBub2Rlcy4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGFkZGVkIHRvIHRoZSBIVE1MXG4gKiBzZXJpYWxpemVyIHNvIHRoYXQgdXNlcnMgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0ZXh0LWxldmVsIHNlcmlhbGl6YXRpb24uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5jb25zdCBURVhUX1JVTEUgPSB7XG5cbiAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICBpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdicicpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6ICd0ZXh0JyxcbiAgICAgICAgbGVhdmVzOiBbe1xuICAgICAgICAgIGtpbmQ6ICdsZWFmJyxcbiAgICAgICAgICB0ZXh0OiAnXFxuJ1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbC5ub2RlTmFtZSA9PSAnI3RleHQnKSB7XG4gICAgICBpZiAoZWwudmFsdWUgJiYgZWwudmFsdWUubWF0Y2goLzwhLS0uKj8tLT4vKSkgcmV0dXJuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6ICd0ZXh0JyxcbiAgICAgICAgbGVhdmVzOiBbe1xuICAgICAgICAgIGtpbmQ6ICdsZWFmJyxcbiAgICAgICAgICB0ZXh0OiBlbC52YWx1ZSB8fCBlbC5ub2RlVmFsdWVcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2VyaWFsaXplKG9iaiwgY2hpbGRyZW4pIHtcbiAgICBpZiAob2JqLmtpbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAucmVkdWNlKChhcnJheSwgdGV4dCwgaSkgPT4ge1xuICAgICAgICAgIGlmIChpICE9IDApIGFycmF5LnB1c2goPGJyIC8+KVxuICAgICAgICAgIGFycmF5LnB1c2godGV4dClcbiAgICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgICAgfSwgW10pXG4gICAgfVxuICB9XG5cbn1cblxuLyoqXG4gKiBBIGRlZmF1bHQgYHBhcnNlSHRtbGAgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBgPGJvZHk+YCB1c2luZyBgRE9NUGFyc2VyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzZUh0bWwoaHRtbCkge1xuICBpZiAodHlwZW9mIERPTVBhcnNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBuYXRpdmUgYERPTVBhcnNlcmAgZ2xvYmFsIHdoaWNoIHRoZSBgSHRtbGAgc2VyaWFsaXplciB1c2VzIGJ5IGRlZmF1bHQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBlbnZpcm9ubWVudC4gWW91IG11c3Qgc3VwcGx5IHRoZSBgb3B0aW9ucy5wYXJzZUh0bWxgIGZ1bmN0aW9uIGluc3RlYWQuJylcbiAgfVxuXG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ3RleHQvaHRtbCcpXG4gIGNvbnN0IHsgYm9keSB9ID0gcGFyc2VkXG4gIHJldHVybiBib2R5XG59XG5cbi8qKlxuICogSFRNTCBzZXJpYWxpemVyLlxuICpcbiAqIEB0eXBlIHtIdG1sfVxuICovXG5cbmNsYXNzIEh0bWwge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2VyaWFsaXplciB3aXRoIGBydWxlc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqICAgQHByb3BlcnR5IHtBcnJheX0gcnVsZXNcbiAgICogICBAcHJvcGVydHkge1N0cmluZ3xPYmplY3R8QmxvY2t9IGRlZmF1bHRCbG9ja1xuICAgKiAgIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBhcnNlSHRtbFxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBsZXQge1xuICAgICAgZGVmYXVsdEJsb2NrID0gJ3BhcmFncmFwaCcsXG4gICAgICBwYXJzZUh0bWwgPSBkZWZhdWx0UGFyc2VIdG1sLFxuICAgICAgcnVsZXMgPSBbXSxcbiAgICB9ID0gb3B0aW9uc1xuXG4gICAgZGVmYXVsdEJsb2NrID0gTm9kZS5jcmVhdGVQcm9wZXJ0aWVzKGRlZmF1bHRCbG9jaylcblxuICAgIHRoaXMucnVsZXMgPSBbIC4uLnJ1bGVzLCBURVhUX1JVTEUgXVxuICAgIHRoaXMuZGVmYXVsdEJsb2NrID0gZGVmYXVsdEJsb2NrXG4gICAgdGhpcy5wYXJzZUh0bWwgPSBwYXJzZUh0bWxcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBwYXN0ZWQgSFRNTC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICBAcHJvcGVydHkge0Jvb2xlYW59IHRvUmF3XG4gICAqIEByZXR1cm4ge1ZhbHVlfVxuICAgKi9cblxuICBkZXNlcmlhbGl6ZSA9IChodG1sLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IHRvSlNPTiA9IGZhbHNlIH0gPSBvcHRpb25zXG4gICAgY29uc3QgeyBkZWZhdWx0QmxvY2ssIHBhcnNlSHRtbCB9ID0gdGhpc1xuICAgIGNvbnN0IGZyYWdtZW50ID0gcGFyc2VIdG1sKGh0bWwpXG4gICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGZyYWdtZW50LmNoaWxkTm9kZXMpXG4gICAgbGV0IG5vZGVzID0gdGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnRzKGNoaWxkcmVuKVxuXG4gICAgLy8gQ09NUEFUOiBlbnN1cmUgdGhhdCBhbGwgdG9wLWxldmVsIGlubGluZSBub2RlcyBhcmUgd3JhcHBlZCBpbnRvIGEgYmxvY2suXG4gICAgbm9kZXMgPSBub2Rlcy5yZWR1Y2UoKG1lbW8sIG5vZGUsIGksIG9yaWdpbmFsKSA9PiB7XG4gICAgICBpZiAobm9kZS5raW5kID09ICdibG9jaycpIHtcbiAgICAgICAgbWVtby5wdXNoKG5vZGUpXG4gICAgICAgIHJldHVybiBtZW1vXG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCAmJiBvcmlnaW5hbFtpIC0gMV0ua2luZCAhPSAnYmxvY2snKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbWVtb1ttZW1vLmxlbmd0aCAtIDFdXG4gICAgICAgIGJsb2NrLm5vZGVzLnB1c2gobm9kZSlcbiAgICAgICAgcmV0dXJuIG1lbW9cbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvY2sgPSB7XG4gICAgICAgIGtpbmQ6ICdibG9jaycsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICBpc1ZvaWQ6IGZhbHNlLFxuICAgICAgICAuLi5kZWZhdWx0QmxvY2ssXG4gICAgICAgIG5vZGVzOiBbbm9kZV0sXG4gICAgICB9XG5cbiAgICAgIG1lbW8ucHVzaChibG9jaylcbiAgICAgIHJldHVybiBtZW1vXG4gICAgfSwgW10pXG5cbiAgICAvLyBUT0RPOiBwcmV0dHkgc3VyZSB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQuXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICBub2RlcyA9IFt7XG4gICAgICAgIGtpbmQ6ICdibG9jaycsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICBpc1ZvaWQ6IGZhbHNlLFxuICAgICAgICAuLi5kZWZhdWx0QmxvY2ssXG4gICAgICAgIG5vZGVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAga2luZDogJ3RleHQnLFxuICAgICAgICAgICAgbGVhdmVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBraW5kOiAnbGVhZicsXG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgbWFya3M6IFtdLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgfV1cbiAgICB9XG5cbiAgICBjb25zdCBqc29uID0ge1xuICAgICAga2luZDogJ3ZhbHVlJyxcbiAgICAgIGRvY3VtZW50OiB7XG4gICAgICAgIGtpbmQ6ICdkb2N1bWVudCcsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICBub2RlcyxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0b0pTT04gPyBqc29uIDogVmFsdWUuZnJvbUpTT04oanNvbilcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYW4gYXJyYXkgb2YgRE9NIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50c1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG5cbiAgZGVzZXJpYWxpemVFbGVtZW50cyA9IChlbGVtZW50cyA9IFtdKSA9PiB7XG4gICAgbGV0IG5vZGVzID0gW11cblxuICAgIGVsZW1lbnRzLmZpbHRlcih0aGlzLmNydWZ0TmV3bGluZSkuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZGVzZXJpYWxpemVFbGVtZW50KGVsZW1lbnQpXG4gICAgICBzd2l0Y2ggKHR5cGVPZihub2RlKSkge1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQobm9kZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSlcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIERPTSBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtBbnl9XG4gICAqL1xuXG4gIGRlc2VyaWFsaXplRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgbGV0IG5vZGVcblxuICAgIGlmICghZWxlbWVudC50YWdOYW1lKSB7XG4gICAgICBlbGVtZW50LnRhZ05hbWUgPSAnJ1xuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSAoZWxlbWVudHMpID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudHMpID09ICdbb2JqZWN0IE5vZGVMaXN0XScpIHtcbiAgICAgICAgZWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnRzKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHR5cGVPZihlbGVtZW50cykpIHtcbiAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRWxlbWVudHMoZWxlbWVudHMpXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVFbGVtZW50KGVsZW1lbnRzKVxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcXGBuZXh0XFxgIGFyZ3VtZW50IHdhcyBjYWxsZWQgd2l0aCBpbnZhbGlkIGNoaWxkcmVuOiBcIiR7ZWxlbWVudHN9XCIuYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgdGhpcy5ydWxlcykge1xuICAgICAgaWYgKCFydWxlLmRlc2VyaWFsaXplKSBjb250aW51ZVxuICAgICAgY29uc3QgcmV0ID0gcnVsZS5kZXNlcmlhbGl6ZShlbGVtZW50LCBuZXh0KVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVPZihyZXQpXG5cbiAgICAgIGlmICh0eXBlICE9ICdhcnJheScgJiYgdHlwZSAhPSAnb2JqZWN0JyAmJiB0eXBlICE9ICdudWxsJyAmJiB0eXBlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBydWxlIHJldHVybmVkIGFuIGludmFsaWQgZGVzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uOiBcIiR7bm9kZX1cIi5gKVxuICAgICAgfVxuXG4gICAgICBpZiAocmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9IGVsc2UgaWYgKHJldC5raW5kID09ICdtYXJrJykge1xuICAgICAgICBub2RlID0gdGhpcy5kZXNlcmlhbGl6ZU1hcmsocmV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IHJldFxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiBub2RlIHx8IG5leHQoZWxlbWVudC5jaGlsZE5vZGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgYG1hcmtgIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcmtcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuXG4gIGRlc2VyaWFsaXplTWFyayA9IChtYXJrKSA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBtYXJrXG5cbiAgICBjb25zdCBhcHBseU1hcmsgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUua2luZCA9PSAnbWFyaycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVNYXJrKG5vZGUpXG4gICAgICB9XG5cbiAgICAgIGVsc2UgaWYgKG5vZGUua2luZCA9PSAndGV4dCcpIHtcbiAgICAgICAgbm9kZS5sZWF2ZXMgPSBub2RlLmxlYXZlcy5tYXAoKGxlYWYpID0+IHtcbiAgICAgICAgICBsZWFmLm1hcmtzID0gbGVhZi5tYXJrcyB8fCBbXVxuICAgICAgICAgIGxlYWYubWFya3MucHVzaCh7IHR5cGUsIGRhdGEgfSlcbiAgICAgICAgICByZXR1cm4gbGVhZlxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5ub2RlcyA9IG5vZGUubm9kZXMubWFwKGFwcGx5TWFyaylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9XG5cbiAgICByZXR1cm4gbWFyay5ub2Rlcy5yZWR1Y2UoKG5vZGVzLCBub2RlKSA9PiB7XG4gICAgICBjb25zdCByZXQgPSBhcHBseU1hcmsobm9kZSlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJldCkpIHJldHVybiBub2Rlcy5jb25jYXQocmV0KVxuICAgICAgbm9kZXMucHVzaChyZXQpXG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9LCBbXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSBgdmFsdWVgIG9iamVjdCBpbnRvIGFuIEhUTUwgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiAgIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gcmVuZGVyXG4gICAqIEByZXR1cm4ge1N0cmluZ3xBcnJheX1cbiAgICovXG5cbiAgc2VyaWFsaXplID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGRvY3VtZW50IH0gPSB2YWx1ZVxuICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQubm9kZXMubWFwKHRoaXMuc2VyaWFsaXplTm9kZSlcbiAgICBpZiAob3B0aW9ucy5yZW5kZXIgPT09IGZhbHNlKSByZXR1cm4gZWxlbWVudHNcblxuICAgIGNvbnN0IGh0bWwgPSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cCg8Ym9keT57ZWxlbWVudHN9PC9ib2R5PilcbiAgICBjb25zdCBpbm5lciA9IGh0bWwuc2xpY2UoNiwgLTcpXG4gICAgcmV0dXJuIGlubmVyXG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIGEgYG5vZGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cblxuICBzZXJpYWxpemVOb2RlID0gKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS5raW5kID09PSAndGV4dCcpIHtcbiAgICAgIGNvbnN0IGxlYXZlcyA9IG5vZGUuZ2V0TGVhdmVzKClcbiAgICAgIHJldHVybiBsZWF2ZXMubWFwKHRoaXMuc2VyaWFsaXplTGVhZilcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUubm9kZXMubWFwKHRoaXMuc2VyaWFsaXplTm9kZSlcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLnJ1bGVzKSB7XG4gICAgICBpZiAoIXJ1bGUuc2VyaWFsaXplKSBjb250aW51ZVxuICAgICAgY29uc3QgcmV0ID0gcnVsZS5zZXJpYWxpemUobm9kZSwgY2hpbGRyZW4pXG4gICAgICBpZiAocmV0KSByZXR1cm4gYWRkS2V5KHJldClcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlcmlhbGl6ZXIgZGVmaW5lZCBmb3Igbm9kZSBvZiB0eXBlIFwiJHtub2RlLnR5cGV9XCIuYClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgYSBgbGVhZmAuXG4gICAqXG4gICAqIEBwYXJhbSB7TGVhZn0gbGVhZlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIHNlcmlhbGl6ZUxlYWYgPSAobGVhZikgPT4ge1xuICAgIGNvbnN0IHN0cmluZyA9IG5ldyBTdHJpbmcoeyB0ZXh0OiBsZWFmLnRleHQgfSlcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5zZXJpYWxpemVTdHJpbmcoc3RyaW5nKVxuXG4gICAgcmV0dXJuIGxlYWYubWFya3MucmVkdWNlKChjaGlsZHJlbiwgbWFyaykgPT4ge1xuICAgICAgZm9yIChjb25zdCBydWxlIG9mIHRoaXMucnVsZXMpIHtcbiAgICAgICAgaWYgKCFydWxlLnNlcmlhbGl6ZSkgY29udGludWVcbiAgICAgICAgY29uc3QgcmV0ID0gcnVsZS5zZXJpYWxpemUobWFyaywgY2hpbGRyZW4pXG4gICAgICAgIGlmIChyZXQpIHJldHVybiBhZGRLZXkocmV0KVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlcmlhbGl6ZXIgZGVmaW5lZCBmb3IgbWFyayBvZiB0eXBlIFwiJHttYXJrLnR5cGV9XCIuYClcbiAgICB9LCB0ZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSBhIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cbiAgc2VyaWFsaXplU3RyaW5nID0gKHN0cmluZykgPT4ge1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLnJ1bGVzKSB7XG4gICAgICBpZiAoIXJ1bGUuc2VyaWFsaXplKSBjb250aW51ZVxuICAgICAgY29uc3QgcmV0ID0gcnVsZS5zZXJpYWxpemUoc3RyaW5nLCBzdHJpbmcudGV4dClcbiAgICAgIGlmIChyZXQpIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVyIG91dCBjcnVmdCBuZXdsaW5lIG5vZGVzIGluc2VydGVkIGJ5IHRoZSBET00gcGFyc2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cblxuICBjcnVmdE5ld2xpbmUgPSAoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiAhKGVsZW1lbnQubm9kZU5hbWUgPT09ICcjdGV4dCcgJiYgZWxlbWVudC52YWx1ZSA9PSAnXFxuJylcbiAgfVxuXG59XG5cbi8qKlxuICogQWRkIGEgdW5pcXVlIGtleSB0byBhIFJlYWN0IGBlbGVtZW50YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cblxubGV0IGtleSA9IDBcblxuZnVuY3Rpb24gYWRkS2V5KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7IGtleToga2V5KysgfSlcbn1cblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge0h0bWx9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgSHRtbFxuIl19