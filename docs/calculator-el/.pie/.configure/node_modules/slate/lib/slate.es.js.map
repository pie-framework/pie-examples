{"version":3,"file":"slate.es.js","sources":["../src/constants/model-types.js","../src/utils/key-utils.js","../src/models/block.js","../src/models/inline.js","../src/models/data.js","../src/utils/memoize.js","../src/models/mark.js","../src/changes/at-current-range.js","../src/models/document.js","../src/utils/path-utils.js","../src/models/range.js","../src/models/character.js","../src/models/leaf.js","../src/models/text.js","../src/models/node.js","../src/utils/text-utils.js","../src/changes/at-range.js","../src/changes/by-path.js","../src/models/history.js","../src/models/stack.js","../src/utils/slate-error.js","../src/models/schema.js","../src/models/value.js","../src/models/operation.js","../src/operations/invert.js","../src/changes/on-history.js","../src/changes/on-selection.js","../src/changes/on-value.js","../src/changes/with-schema.js","../src/changes/index.js","../src/operations/apply.js","../src/models/change.js","../src/operations/index.js","../src/utils/generate-key.js","../src/index.js"],"sourcesContent":["/**\n * Slate-specific model types.\n *\n * @type {Object}\n */\n\nconst MODEL_TYPES = {\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  CHANGE: '@@__SLATE_CHANGE__@@',\n  CHARACTER: '@@__SLATE_CHARACTER__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  HISTORY: '@@__SLATE_HISTORY__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  LEAF: '@@__SLATE_LEAF__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  OPERATION: '@@__SLATE_OPERATION__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@',\n  STACK: '@@__SLATE_STACK__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  VALUE: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Export type identification function\n *\n * @param {string} type\n * @param {any} any\n * @return {boolean}\n */\n\nexport function isType(type, any) {\n  return !!(any && any[MODEL_TYPES[type]])\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default MODEL_TYPES\n","/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate()\n  }\n\n  if (typeof key === 'string') {\n    return key\n  }\n\n  throw new Error(`Keys must be strings, but you passed: ${key}`)\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  create,\n  setGenerator,\n  resetGenerator,\n}\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport KeyUtils from '../utils/key-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = KeyUtils.create(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: Map(data),\n      nodes: Block.createChildren(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Block.fromJSON\n\n  /**\n   * Check if `any` is a `Block`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlock = isType.bind(null, 'BLOCK')\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'block'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the block is empty.\n   * Returns true if block is not void and all it's children nodes are empty.\n   * Void node is never empty, regardless of it's content.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.isVoid && !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the block's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nBlock.prototype[MODEL_TYPES.BLOCK] = true\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport KeyUtils from '../utils/key-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = KeyUtils.create(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: new Map(data),\n      nodes: Inline.createChildren(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Inline.fromJSON\n\n  /**\n   * Check if `any` is a `Inline`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInline = isType.bind(null, 'INLINE')\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'inline'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the inline is empty.\n   * Returns true if inline is not void and all it's children nodes are empty.\n   * Void node is never empty, regardless of it's content.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.isVoid && !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the inline's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nInline.prototype[MODEL_TYPES.INLINE] = true\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * GLOBAL: Changing this cache key will clear all previous cached results.\n *\n * @type {Number}\n */\n\nlet CACHE_KEY = 0\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Object}\n */\n\nconst LEAF = {}\n\n/**\n * A value to represent a memoized undefined value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Object}\n */\n\nconst UNDEFINED = {}\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args)\n\n      // If the cache key is different, previous caches must be cleared.\n      if (CACHE_KEY !== this.__cache_key) {\n        this.__cache_key = CACHE_KEY\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n        this.__cache_no_args = {}\n      }\n\n      if (!this.__cache) {\n        this.__cache = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      }\n\n      if (!this.__cache_no_args) {\n        this.__cache_no_args = {}\n      }\n\n      const takesArguments = args.length !== 0\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(this.__cache, keys)\n      } else {\n        cachedValue = this.__cache_no_args[property]\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        this.__cache = setIn(this.__cache, keys, v)\n      } else {\n        this.__cache_no_args[property] = v\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (const key of keys) {\n    map = map.get(key)\n    if (map === UNSET) return UNSET\n  }\n\n  return map.get(LEAF)\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let parent = map\n  let child\n\n  for (const key of keys) {\n    child = parent.get(key)\n\n    // If the path was not created yet...\n    if (child === UNSET) {\n      child = new Map() // eslint-disable-line no-undef,no-restricted-globals\n      parent.set(key, child)\n    }\n\n    parent = child\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child.set(LEAF, value)\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  CACHE_KEY++\n\n  if (CACHE_KEY >= Number.MAX_SAFE_INTEGER) {\n    CACHE_KEY = 0\n  }\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { Map, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Data from './data'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Mark.fromJSON\n\n  /**\n   * Check if `any` is a `Mark`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMark = isType.bind(null, 'MARK')\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Object.\n   */\n\n  get object() {\n    return 'mark'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get the component for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getComponent(schema) {\n    return schema.__getComponent(this)\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nMark.prototype[MODEL_TYPES.MARK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Mark.prototype, ['getComponent'])\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import logger from 'slate-dev-logger'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nconst PROXY_TRANSFORMS = [\n  'deleteBackward',\n  'deleteCharBackward',\n  'deleteLineBackward',\n  'deleteWordBackward',\n  'deleteForward',\n  'deleteCharForward',\n  'deleteWordForward',\n  'deleteLineForward',\n  'setBlocks',\n  'setInlines',\n  'splitInline',\n  'unwrapBlock',\n  'unwrapInline',\n  'wrapBlock',\n  'wrapInline',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const { value } = change\n    const { selection } = value\n    const methodAtRange = `${method}AtRange`\n    change[methodAtRange](selection, ...args)\n\n    if (method.match(/Backward$/)) {\n      change.collapseToStart()\n    } else if (method.match(/Forward$/)) {\n      change.collapseToEnd()\n    }\n  }\n})\n\nChanges.setBlock = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setBlock` method of Slate changes has been renamed to `setBlocks`.'\n  )\n\n  Changes.setBlocks(...args)\n}\n\nChanges.setInline = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setInline` method of Slate changes has been renamed to `setInlines`.'\n  )\n\n  Changes.setInlines(...args)\n}\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMarks = (change, marks) => {\n  marks.forEach(mark => change.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nChanges.delete = change => {\n  const { value } = change\n  const { selection } = value\n  change.deleteAtRange(selection)\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.collapseToStart()\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nChanges.insertBlock = (change, block) => {\n  block = Block.create(block)\n  const { value } = change\n  const { selection } = value\n  change.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(block.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nChanges.insertFragment = (change, fragment) => {\n  if (!fragment.nodes.size) return\n\n  let { value } = change\n  let { document, selection } = value\n  const { startText, endText, startInline } = value\n  const lastText = fragment.getLastText()\n  const lastInline = fragment.getClosestInline(lastText.key)\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const keys = document.getTexts().map(text => text.key)\n  const isAppending =\n    !startInline ||\n    selection.hasEdgeAtStartOf(startText) ||\n    selection.hasEdgeAtEndOf(endText)\n\n  const isInserting =\n    firstChild.hasBlockChildren() || lastChild.hasBlockChildren()\n\n  change.insertFragmentAtRange(selection, fragment)\n  value = change.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  const newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first()\n\n  if (newText && (lastInline || isInserting)) {\n    change.select(selection.collapseToEndOf(newText))\n  } else if (newText) {\n    change.select(\n      selection.collapseToStartOf(newText).move(lastText.text.length)\n    )\n  } else {\n    change.select(selection.collapseToStart().move(lastText.text.length))\n  }\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nChanges.insertInline = (change, inline) => {\n  inline = Inline.create(inline)\n  const { value } = change\n  const { selection } = value\n  change.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(inline.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nChanges.insertText = (change, text, marks) => {\n  const { value } = change\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n  change.insertTextAtRange(selection, text, marks)\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null })\n  }\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nChanges.splitBlock = (change, depth = 1) => {\n  const { value } = change\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  change.splitBlockAtRange(selection, depth).collapseToEnd()\n\n  if (marks && marks.size !== 0) {\n    change.select({ marks })\n  }\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.removeMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nChanges.replaceMark = (change, oldMark, newMark) => {\n  change.removeMark(oldMark)\n  change.addMark(newMark)\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.toggleMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    change.removeMark(mark)\n  } else {\n    change.addMark(mark)\n  }\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nChanges.wrapText = (change, prefix, suffix = prefix) => {\n  const { value } = change\n  const { selection } = value\n  change.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStart(0 - prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEnd(0 - suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport KeyUtils from '../utils/key-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  key: undefined,\n  nodes: new List(),\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Document.createChildren(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Document.fromJSON\n\n  /**\n   * Check if `any` is a `Document`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isDocument = isType.bind(null, 'DOCUMENT')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'document'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the document is empty.\n   * Returns true if all it's children nodes are empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the document's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDocument.prototype[MODEL_TYPES.DOCUMENT] = true\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import { List } from 'immutable'\n\n/**\n * Compare paths `a` and `b` to see which is before or after.\n *\n * @param {List} a\n * @param {List} b\n * @return {Number|Null}\n */\n\nfunction compare(a, b) {\n  // PERF: if the paths are the same we can exit early.\n  if (a.size !== b.size) return null\n\n  for (let i = 0; i < a.size; i++) {\n    const av = a.get(i)\n    const bv = b.get(i)\n\n    // If a's value is ever less than b's, it's before.\n    if (av < bv) return -1\n\n    // If b's value is ever less than a's, it's after.\n    if (av > bv) return 1\n  }\n\n  // Otherwise they were equal the whole way, it's the same.\n  return 0\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create(attrs) {\n  if (attrs == null) {\n    return null\n  }\n\n  if (List.isList(attrs)) {\n    return attrs\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs)\n  }\n\n  throw new Error(\n    `Paths can only be created from arrays or lists, but you passed: ${attrs}`\n  )\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b, size = min(a, b)) {\n  const ca = a.slice(0, size)\n  const cb = b.slice(0, size)\n  return [ca, cb]\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path, n = 1, index = path.size - 1) {\n  return increment(path, 0 - n, index)\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path, n = 1, index = path.size - 1) {\n  const value = path.get(index)\n  const newValue = value + n\n  const newPath = path.set(index, newValue)\n  return newPath\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  const [p, t] = crop(path, target)\n  return path.size < target.size && compare(p, t) === 0\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === 1\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === -1\n}\n\n/**\n * Lift a `path` to refer to its parent.\n *\n * @param {List} path\n * @return {Array}\n */\n\nfunction lift(path) {\n  const parent = path.slice(0, -1)\n  return parent\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  const n = Math.max(a.size, b.size)\n  return n\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  const n = Math.min(a.size, b.size)\n  return n\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  const array = []\n\n  for (let i = 0; i < a.size && i < b.size; i++) {\n    const av = a.get(i)\n    const bv = b.get(i)\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av)\n  }\n\n  const path = create(array)\n  return path\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  compare,\n  create,\n  crop,\n  decrement,\n  increment,\n  isAbove,\n  isAfter,\n  isBefore,\n  lift,\n  max,\n  min,\n  relate,\n}\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport PathUtils from '../utils/path-utils'\nimport MODEL_TYPES from '../constants/model-types'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchorKey: null,\n  anchorOffset: 0,\n  anchorPath: null,\n  focusKey: null,\n  focusOffset: 0,\n  focusPath: null,\n  isAtomic: false,\n  isBackward: null,\n  isFocused: false,\n  marks: null,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Range.isRange(a)) {\n      return {\n        anchorKey: a.anchorKey,\n        anchorOffset: a.anchorOffset,\n        anchorPath: a.anchorPath,\n        focusKey: a.focusKey,\n        focusOffset: a.focusOffset,\n        focusPath: a.focusPath,\n        isAtomic: a.isAtomic,\n        isBackward: a.isBackward,\n        isFocused: a.isFocused,\n        marks: a.marks,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchorKey' in a) p.anchorKey = a.anchorKey\n      if ('anchorOffset' in a) p.anchorOffset = a.anchorOffset\n      if ('anchorPath' in a) p.anchorPath = PathUtils.create(a.anchorPath)\n      if ('focusKey' in a) p.focusKey = a.focusKey\n      if ('focusOffset' in a) p.focusOffset = a.focusOffset\n      if ('focusPath' in a) p.focusPath = PathUtils.create(a.focusPath)\n      if ('isAtomic' in a) p.isAtomic = a.isAtomic\n      if ('isBackward' in a) p.isBackward = a.isBackward\n      if ('isFocused' in a) p.isFocused = a.isFocused\n      if ('marks' in a)\n        p.marks = a.marks == null ? null : Mark.createSet(a.marks)\n\n      // If only a path is set, or only a key is set, ensure that the other is\n      // set to null so that it can be normalized back to the right value.\n      // Otherwise we won't realize that the path and key don't match anymore.\n      if ('anchorPath' in a && !('anchorKey' in a)) p.anchorKey = null\n      if ('anchorKey' in a && !('anchorPath' in a)) p.anchorPath = null\n      if ('focusPath' in a && !('focusKey' in a)) p.focusKey = null\n      if ('focusKey' in a && !('focusPath' in a)) p.focusPath = null\n\n      return p\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects or ranges, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const {\n      anchorKey = null,\n      anchorOffset = 0,\n      anchorPath = null,\n      focusKey = null,\n      focusOffset = 0,\n      focusPath = null,\n      isAtomic = false,\n      isBackward = null,\n      isFocused = false,\n      marks = null,\n    } = object\n\n    const range = new Range({\n      anchorKey,\n      anchorOffset,\n      anchorPath: PathUtils.create(anchorPath),\n      focusKey,\n      focusOffset,\n      focusPath: PathUtils.create(focusPath),\n      isAtomic,\n      isBackward,\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return range\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Range.fromJSON\n\n  /**\n   * Check if an `obj` is a `Range`.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isRange(obj) {\n    return !!(obj && obj[MODEL_TYPES.RANGE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'range'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check whether the range is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.isBackward == null ? null : !this.isBackward\n  }\n\n  /**\n   * Check whether the range's keys are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return (\n      (this.anchorKey != null && this.focusKey != null) ||\n      (this.anchorPath != null && this.focusPath != null)\n    )\n  }\n\n  /**\n   * Check whether the range's keys are not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Get the start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.isBackward ? this.focusKey : this.anchorKey\n  }\n\n  /**\n   * Get the start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.isBackward ? this.focusOffset : this.anchorOffset\n  }\n\n  /**\n   * Get the start path.\n   *\n   * @return {String}\n   */\n\n  get startPath() {\n    return this.isBackward ? this.focusPath : this.anchorPath\n  }\n\n  /**\n   * Get the end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.isBackward ? this.anchorKey : this.focusKey\n  }\n\n  /**\n   * Get the end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.isBackward ? this.anchorOffset : this.focusOffset\n  }\n\n  /**\n   * Get the end path.\n   *\n   * @return {String}\n   */\n\n  get endPath() {\n    return this.isBackward ? this.anchorPath : this.focusPath\n  }\n\n  /**\n   * Check whether anchor point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtStartOf(node) {\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.anchorOffset != 0) return false\n    const first = getFirstText(node)\n    return this.anchorKey == first.key\n  }\n\n  /**\n   * Check whether anchor point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtEndOf(node) {\n    const last = getLastText(node)\n    return this.anchorKey == last.key && this.anchorOffset == last.text.length\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasAnchorBetween(node, start, end) {\n    return (\n      this.anchorOffset <= end &&\n      start <= this.anchorOffset &&\n      this.hasAnchorIn(node)\n    )\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorIn(node) {\n    return node.object == 'text'\n      ? node.key == this.anchorKey\n      : this.anchorKey != null && node.hasDescendant(this.anchorKey)\n  }\n\n  /**\n   * Check whether focus point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtEndOf(node) {\n    const last = getLastText(node)\n    return this.focusKey == last.key && this.focusOffset == last.text.length\n  }\n\n  /**\n   * Check whether focus point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtStartOf(node) {\n    if (this.focusOffset != 0) return false\n    const first = getFirstText(node)\n    return this.focusKey == first.key\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasFocusBetween(node, start, end) {\n    return (\n      start <= this.focusOffset &&\n      this.focusOffset <= end &&\n      this.hasFocusIn(node)\n    )\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusIn(node) {\n    return node.object == 'text'\n      ? node.key == this.focusKey\n      : this.focusKey != null && node.hasDescendant(this.focusKey)\n  }\n\n  /**\n   * Check whether the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOf(node) {\n    return this.isCollapsed && this.hasAnchorAtStartOf(node)\n  }\n\n  /**\n   * Check whether the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOf(node) {\n    return this.isCollapsed && this.hasAnchorAtEndOf(node)\n  }\n\n  /**\n   * Focus the range.\n   *\n   * @return {Range}\n   */\n\n  focus() {\n    return this.merge({\n      isFocused: true,\n    })\n  }\n\n  /**\n   * Blur the range.\n   *\n   * @return {Range}\n   */\n\n  blur() {\n    return this.merge({\n      isFocused: false,\n    })\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  deselect() {\n    return this.merge({\n      anchorKey: null,\n      anchorOffset: 0,\n      anchorPath: null,\n      focusKey: null,\n      focusOffset: 0,\n      focusPath: null,\n      isFocused: false,\n      isBackward: false,\n    })\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    return this.merge({\n      anchorKey: this.focusKey,\n      anchorOffset: this.focusOffset,\n      anchorPath: this.focusPath,\n      focusKey: this.anchorKey,\n      focusOffset: this.anchorOffset,\n      focusPath: this.anchorPath,\n      isBackward: this.isBackward == null ? null : !this.isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveAnchor(n = 1) {\n    const { anchorKey, focusKey, focusOffset, isBackward } = this\n    const anchorOffset = this.anchorOffset + n\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        anchorKey == focusKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveFocus(n = 1) {\n    const { anchorKey, anchorOffset, focusKey, isBackward } = this\n    const focusOffset = this.focusOffset + n\n    return this.merge({\n      focusOffset,\n      isBackward:\n        focusKey == anchorKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the range's anchor point to a new `key` or `path` and `offset`.\n   *\n   * @param {String|List} key or path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(key, offset) {\n    const {\n      anchorKey,\n      focusKey,\n      focusOffset,\n      anchorPath,\n      focusPath,\n      isBackward,\n    } = this\n\n    if (typeof key === 'string') {\n      const isAnchor = key === anchorKey\n      const isFocus = key === focusKey\n      return this.merge({\n        anchorKey: key,\n        anchorPath: isFocus ? focusPath : isAnchor ? anchorPath : null,\n        anchorOffset: offset,\n        isBackward: isFocus\n          ? offset > focusOffset\n          : isAnchor ? isBackward : null,\n      })\n    } else {\n      const path = key\n      const isAnchor = path && path.equals(anchorPath)\n      const isFocus = path && path.equals(focusPath)\n      return this.merge({\n        anchorPath: path,\n        anchorKey: isAnchor ? anchorKey : isFocus ? focusKey : null,\n        anchorOffset: offset,\n        isBackward: isFocus\n          ? offset > focusOffset\n          : isAnchor ? isBackward : null,\n      })\n    }\n  }\n\n  /**\n   * Move the range's focus point to a new `key` or `path` and `offset`.\n   *\n   * @param {String|List} key or path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(key, offset) {\n    const {\n      focusKey,\n      anchorKey,\n      anchorOffset,\n      anchorPath,\n      focusPath,\n      isBackward,\n    } = this\n\n    if (typeof key === 'string') {\n      const isAnchor = key === anchorKey\n      const isFocus = key === focusKey\n      return this.merge({\n        focusKey: key,\n        focusPath: isAnchor ? anchorPath : isFocus ? focusPath : null,\n        focusOffset: offset,\n        isBackward: isAnchor\n          ? offset < anchorOffset\n          : isFocus ? isBackward : null,\n      })\n    } else {\n      const path = key\n      const isAnchor = path && path.equals(anchorPath)\n      const isFocus = path && path.equals(focusPath)\n      return this.merge({\n        focusPath: path,\n        focusKey: isFocus ? focusKey : isAnchor ? anchorKey : null,\n        focusOffset: offset,\n        isBackward: isAnchor\n          ? offset < anchorOffset\n          : isFocus ? isBackward : null,\n      })\n    }\n  }\n\n  /**\n   * Move the range to `anchorOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @return {Range}\n   */\n\n  moveAnchorOffsetTo(anchorOffset) {\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? anchorOffset > this.focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `focusOffset`.\n   *\n   * @param {Number} focusOffset\n   * @return {Range}\n   */\n\n  moveFocusOffsetTo(focusOffset) {\n    return this.merge({\n      focusOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? this.anchorOffset > focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `anchorOffset` and `focusOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @param {Number} focusOffset (optional)\n   * @return {Range}\n   */\n\n  moveOffsetsTo(anchorOffset, focusOffset = anchorOffset) {\n    return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset)\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    return this.moveFocusTo(this.anchorKey, this.anchorOffset)\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    return this.moveAnchorTo(this.focusKey, this.focusOffset)\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOf(node) {\n    node = getFirstText(node)\n    return this.moveAnchorTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOf(node) {\n    node = getLastText(node)\n    return this.moveAnchorTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOf(node) {\n    node = getFirstText(node)\n    return this.moveFocusTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOf(node) {\n    node = getLastText(node)\n    return this.moveFocusTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOf(start, end = start) {\n    const range = this.isBackward ? this.flip() : this\n    return range.moveAnchorToStartOf(start).moveFocusToEndOf(end)\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    const range = this\n    let {\n      anchorKey,\n      anchorOffset,\n      anchorPath,\n      focusKey,\n      focusOffset,\n      focusPath,\n      isBackward,\n    } = range\n\n    const anchorOffsetType = typeof anchorOffset\n    const focusOffsetType = typeof focusOffset\n\n    if (anchorOffsetType != 'number' || focusOffsetType != 'number') {\n      logger.warn(\n        `The range offsets should be numbers, but they were of type \"${anchorOffsetType}\" and \"${focusOffsetType}\".`\n      )\n    }\n\n    // If either point in the range is unset, make sure it is fully unset.\n    if (\n      (anchorKey == null && anchorPath == null) ||\n      (focusKey == null && focusPath == null)\n    ) {\n      return range.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        anchorPath: null,\n        focusKey: null,\n        focusOffset: 0,\n        focusPath: null,\n        isBackward: false,\n      })\n    }\n\n    // Get the anchor and focus nodes.\n    let anchorNode = node.getNode(anchorKey || anchorPath)\n    let focusNode = node.getNode(focusKey || focusPath)\n\n    // If the range is malformed, warn and zero it out.\n    if (!anchorNode || !focusNode) {\n      logger.warn(\n        'The range was invalid and was reset. The range in question was:',\n        range\n      )\n\n      const first = node.getFirstText()\n      const path = first && node.getPath(first.key)\n      return range.merge({\n        anchorKey: first ? first.key : null,\n        anchorOffset: 0,\n        anchorPath: first ? path : null,\n        focusKey: first ? first.key : null,\n        focusOffset: 0,\n        focusPath: first ? path : null,\n        isBackward: false,\n      })\n    }\n\n    // If the anchor node isn't a text node, match it to one.\n    if (anchorNode.object != 'text') {\n      logger.warn(\n        'The range anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        anchorNode\n      )\n\n      const anchorText = anchorNode.getTextAtOffset(anchorOffset)\n      const offset = anchorNode.getOffset(anchorText.key)\n      anchorOffset = anchorOffset - offset\n      anchorNode = anchorText\n    }\n\n    // If the focus node isn't a text node, match it to one.\n    if (focusNode.object != 'text') {\n      logger.warn(\n        'The range focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        focusNode\n      )\n\n      const focusText = focusNode.getTextAtOffset(focusOffset)\n      const offset = focusNode.getOffset(focusText.key)\n      focusOffset = focusOffset - offset\n      focusNode = focusText\n    }\n\n    anchorKey = anchorNode.key\n    focusKey = focusNode.key\n    anchorPath = node.getPath(anchorKey)\n    focusPath = node.getPath(focusKey)\n\n    // If `isBackward` is not set, derive it.\n    if (isBackward == null) {\n      const result = PathUtils.compare(anchorPath, focusPath)\n      isBackward = result === 0 ? anchorOffset > focusOffset : result === 1\n    }\n\n    // Merge in any updated properties.\n    return range.merge({\n      anchorKey,\n      anchorOffset,\n      anchorPath,\n      focusKey,\n      focusOffset,\n      focusPath,\n      isBackward,\n    })\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchorKey: this.anchorKey,\n      anchorOffset: this.anchorOffset,\n      anchorPath: this.anchorPath && this.anchorPath.toArray(),\n      focusKey: this.focusKey,\n      focusOffset: this.focusOffset,\n      focusPath: this.focusPath && this.focusPath.toArray(),\n      isAtomic: this.isAtomic,\n      isBackward: this.isBackward,\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    if (!options.preserveKeys) {\n      delete object.anchorKey\n      delete object.focusKey\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nRange.prototype[MODEL_TYPES.RANGE] = true\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nconst MOVE_METHODS = [\n  ['move', ''],\n  ['move', 'To'],\n  ['move', 'ToStartOf'],\n  ['move', 'ToEndOf'],\n]\n\nMOVE_METHODS.forEach(([p, s]) => {\n  Range.prototype[`${p}${s}`] = function(...args) {\n    return this[`${p}Anchor${s}`](...args)[`${p}Focus${s}`](...args)\n  }\n})\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nconst EDGE_METHODS = [\n  ['has', 'AtStartOf', true],\n  ['has', 'AtEndOf', true],\n  ['has', 'Between', true],\n  ['has', 'In', true],\n  ['collapseTo', ''],\n  ['move', ''],\n  ['moveTo', ''],\n  ['move', 'To'],\n  ['move', 'OffsetTo'],\n]\n\nEDGE_METHODS.forEach(([p, s, hasEdge]) => {\n  const anchor = `${p}Anchor${s}`\n  const focus = `${p}Focus${s}`\n\n  Range.prototype[`${p}Start${s}`] = function(...args) {\n    return this.isBackward ? this[focus](...args) : this[anchor](...args)\n  }\n\n  Range.prototype[`${p}End${s}`] = function(...args) {\n    return this.isBackward ? this[anchor](...args) : this[focus](...args)\n  }\n\n  if (hasEdge) {\n    Range.prototype[`${p}Edge${s}`] = function(...args) {\n      return this[anchor](...args) || this[focus](...args)\n    }\n  }\n})\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseTo', 'moveTo'],\n  ['collapseToAnchor', 'moveToAnchor'],\n  ['collapseToFocus', 'moveToFocus'],\n  ['collapseToStart', 'moveToStart'],\n  ['collapseToEnd', 'moveToEnd'],\n  ['collapseToStartOf', 'moveToStartOf'],\n  ['collapseToEndOf', 'moveToEndOf'],\n  ['extend', 'moveFocus'],\n  ['extendTo', 'moveFocusTo'],\n  ['extendToStartOf', 'moveFocusToStartOf'],\n  ['extendToEndOf', 'moveFocusToEndOf'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Range.prototype[alias] = function(...args) {\n    return this[method](...args)\n  }\n})\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirstText(node) {\n  return node.object == 'text' ? node : node.getFirstText()\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLastText(node) {\n  return node.object == 'text' ? node : node.getLastText()\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: new Set(),\n  text: '',\n}\n\n/**\n * Character.\n *\n * @type {Character}\n */\n\nclass Character extends Record(DEFAULTS) {\n  /**\n   * Create a `Character` with `attrs`.\n   *\n   * @param {Object|String|Character} attrs\n   * @return {Character}\n   */\n\n  static create(attrs = {}) {\n    if (Character.isCharacter(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Character.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Character.create\\` only accepts objects, strings or characters, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Characters` from `elements`.\n   *\n   * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements\n   * @return {List<Character>}\n   */\n\n  static createList(elements = []) {\n    if (typeof elements == 'string') {\n      elements = elements.split('')\n    }\n\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Character.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts strings, arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Character` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Character}\n   */\n\n  static fromJSON(object) {\n    const { text, marks = [] } = object\n\n    if (typeof text != 'string') {\n      throw new Error('`Character.fromJSON` requires a block `text` string.')\n    }\n\n    const character = new Character({\n      text,\n      marks: new Set(marks),\n    })\n\n    return character\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Character.fromJSON\n\n  /**\n   * Check if `any` is a `Character`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacter = isType.bind(null, 'CHARACTER')\n\n  /**\n   * Check if `any` is a character list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacterList(any) {\n    return List.isList(any) && any.every(item => Character.isCharacter(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'character'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the character.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nCharacter.prototype[MODEL_TYPES.CHARACTER] = true\n\n/**\n * Export.\n *\n * @type {Character}\n */\n\nexport default Character\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Character from './character'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: Set(),\n  text: '',\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a valid List of `Leaf` from `leaves`\n   *\n   * @param {List<Leaf>} leaves\n   * @return {List<Leaf>}\n   */\n\n  static createLeaves(leaves) {\n    if (leaves.size <= 1) return leaves\n\n    let invalid = false\n\n    // TODO: we can make this faster with [List] and then flatten\n    const result = List().withMutations(cache => {\n      // Search from the leaves left end to find invalid node;\n      leaves.findLast((leaf, index) => {\n        const firstLeaf = cache.first()\n\n        // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n        if (firstLeaf) {\n          // If marks equals, then the two leaves can be connected\n          if (firstLeaf.marks.equals(leaf.marks)) {\n            invalid = true\n            cache.set(0, firstLeaf.set('text', `${leaf.text}${firstLeaf.text}`))\n            return\n          }\n\n          // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n          if (firstLeaf.text === '') {\n            invalid = true\n            cache.set(0, leaf)\n            return\n          }\n\n          // If the current leaf is empty, drop the leaf\n          if (leaf.text === '') {\n            invalid = true\n            return\n          }\n        }\n\n        cache.unshift(leaf)\n      })\n    })\n\n    if (!invalid) return leaves\n    return result\n  }\n\n  /**\n   * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n   * Corner Cases:\n   *   1. if offset is smaller than 0, then return [List(), leaves]\n   *   2. if offset is bigger than the text length, then return [leaves, List()]\n   *\n   * @param {List<Leaf> leaves\n   * @return {Array<List<Leaf>>}\n   */\n\n  static splitLeaves(leaves, offset) {\n    if (offset < 0) return [List(), leaves]\n\n    if (leaves.size === 0) {\n      return [List(), List()]\n    }\n\n    let endOffset = 0\n    let index = -1\n    let left, right\n\n    leaves.find(leaf => {\n      index++\n      const startOffset = endOffset\n      const { text } = leaf\n      endOffset += text.length\n\n      if (endOffset < offset) return false\n      if (startOffset > offset) return false\n\n      const length = offset - startOffset\n      left = leaf.set('text', text.slice(0, length))\n      right = leaf.set('text', text.slice(length))\n      return true\n    })\n\n    if (!left) return [leaves, List()]\n\n    if (left.text === '') {\n      if (index === 0) {\n        return [List.of(left), leaves]\n      }\n\n      return [leaves.take(index), leaves.skip(index)]\n    }\n\n    if (right.text === '') {\n      if (index === leaves.size - 1) {\n        return [leaves, List.of(right)]\n      }\n\n      return [leaves.take(index + 1), leaves.skip(index + 1)]\n    }\n\n    return [\n      leaves.take(index).push(left),\n      leaves.skip(index + 1).unshift(right),\n    ]\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Leaf.fromJSON\n\n  /**\n   * Check if `any` is a `Leaf`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeaf = isType.bind(null, 'LEAF')\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'leaf'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return leaf as a list of characters\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    logger.deprecate(\n      'slate@0.34.0',\n      'The `characters` property of Slate objects is deprecated'\n    )\n\n    const { marks } = this\n    const characters = Character.createList(\n      this.text.split('').map(char => {\n        return Character.create({\n          text: char,\n          marks,\n        })\n      })\n    )\n\n    return characters\n  }\n\n  /**\n   * Update a `mark` at leaf, replace with newMark\n   *\n   * @param {Mark} mark\n   * @param {Mark} newMark\n   * @returns {Leaf}\n   */\n\n  updateMark(mark, newMark) {\n    const { marks } = this\n    if (newMark.equals(mark)) return this\n    if (!marks.has(mark)) return this\n    const newMarks = marks.withMutations(collection => {\n      collection.remove(mark).add(newMark)\n    })\n    return this.set('marks', newMarks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   *\n   * @param {Set<Mark>} set\n   * @returns {Text}\n   */\n\n  addMarks(set) {\n    const { marks } = this\n    return this.set('marks', marks.union(set))\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  removeMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.remove(mark))\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nLeaf.prototype[MODEL_TYPES.LEAF] = true\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, OrderedSet, Record, Set } from 'immutable'\n\nimport Leaf from './leaf'\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  leaves: List(),\n  key: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { leaves: [{ text: attrs }] }\n    }\n\n    if (isPlainObject(attrs)) {\n      if (attrs.text) {\n        const { text, marks, key } = attrs\n        attrs = { key, leaves: [{ text, marks }] }\n      }\n\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    const { key = KeyUtils.create() } = object\n    let { leaves } = object\n\n    if (!leaves) {\n      if (object.ranges) {\n        logger.deprecate(\n          'slate@0.27.0',\n          'The `ranges` property of Slate objects has been renamed to `leaves`.'\n        )\n\n        leaves = object.ranges\n      } else {\n        leaves = List()\n      }\n    }\n\n    if (Array.isArray(leaves)) {\n      leaves = List(leaves.map(x => Leaf.create(x)))\n    } else if (List.isList(leaves)) {\n      leaves = leaves.map(x => Leaf.create(x))\n    } else {\n      throw new Error('leaves must be either Array or Immutable.List')\n    }\n\n    const node = new Text({\n      leaves: Leaf.createLeaves(leaves),\n      key,\n    })\n\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Text.fromJSON\n\n  /**\n   * Check if `any` is a `Text`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isText = isType.bind(null, 'TEXT')\n\n  /**\n   * Check if `any` is a list of texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'text'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Is the node empty?\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return this.text == ''\n  }\n\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getString()\n  }\n\n  /**\n   * Get the concatenated text of the node, cached for text getter\n   *\n   * @returns {String}\n   */\n\n  getString() {\n    return this.leaves.reduce((string, leaf) => string + leaf.text, '')\n  }\n\n  /**\n   * Get the concatenated characters of the node;\n   *\n   * @returns {String}\n   */\n\n  get characters() {\n    return this.leaves.flatMap(x => x.getCharacters())\n  }\n\n  /**\n   * Find the 'first' leaf at offset; By 'first' the alorighthm prefers `endOffset === offset` than `startOffset === offset`\n   * Corner Cases:\n   *   1. if offset is negative, return the first leaf;\n   *   2. if offset is larger than text length, the leaf is null, startOffset, endOffset and index is of the last leaf\n   *\n   * @param {number}\n   * @returns {Object}\n   *   @property {number} startOffset\n   *   @property {number} endOffset\n   *   @property {number} index\n   *   @property {Leaf} leaf\n   */\n\n  searchLeafAtOffset(offset) {\n    let endOffset = 0\n    let startOffset = 0\n    let index = -1\n\n    const leaf = this.leaves.find(l => {\n      index++\n      startOffset = endOffset\n      endOffset = startOffset + l.text.length\n      return endOffset >= offset\n    })\n\n    return {\n      leaf,\n      endOffset,\n      index,\n      startOffset,\n    }\n  }\n\n  /**\n   * Add a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(index, length, mark) {\n    const marks = Set.of(mark)\n    return this.addMarks(index, length, marks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   * Corner Cases:\n   *   1. If empty text, and if length === 0 and index === 0, will make sure the text contain an empty leaf with the given mark.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Set<Mark>} set\n   * @return {Text}\n   */\n\n  addMarks(index, length, set) {\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n\n      if (!first) {\n        return this.set(\n          'leaves',\n          List.of(Leaf.fromJSON({ text: '', marks: set }))\n        )\n      }\n\n      const newFirst = first.addMarks(set)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (this.text === '') return this\n    if (length === 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.addMarks(set)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Get the decorations for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDecorations(schema) {\n    return schema.__getDecorations(this)\n  }\n\n  /**\n   * Derive the leaves for a list of `decorations`.\n   *\n   * @param {Array|Void} decorations (optional)\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations = []) {\n    let { leaves } = this\n    if (leaves.size === 0) return List.of(Leaf.create({}))\n    if (!decorations || decorations.length === 0) return leaves\n    if (this.text.length === 0) return leaves\n    const { key } = this\n\n    decorations.forEach(range => {\n      const { startKey, endKey, startOffset, endOffset, marks } = range\n      const hasStart = startKey == key\n      const hasEnd = endKey == key\n\n      if (hasStart && hasEnd) {\n        const index = hasStart ? startOffset : 0\n        const length = hasEnd ? endOffset - index : this.text.length - index\n\n        if (length < 1) return\n        if (index >= this.text.length) return\n\n        if (index !== 0 || length < this.text.length) {\n          const [before, bundle] = Leaf.splitLeaves(leaves, index)\n          const [middle, after] = Leaf.splitLeaves(bundle, length)\n          leaves = before.concat(middle.map(x => x.addMarks(marks)), after)\n          return\n        }\n      }\n\n      leaves = leaves.map(x => x.addMarks(marks))\n    })\n\n    if (leaves === this.leaves) return leaves\n    return Leaf.createLeaves(leaves)\n  }\n\n  /**\n   * Get all of the active marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getActiveMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.intersect(leaf.marks)\n      if (result && result.size === 0) return false\n      return false\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the active marks on the text\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarks() {\n    if (this.leaves.size === 0) return Set()\n\n    const result = this.leaves.first().marks\n    if (result.size === 0) return result\n\n    return result.withMutations(x => {\n      this.leaves.forEach(c => {\n        x.intersect(c.marks)\n        if (x.size === 0) return false\n      })\n    })\n  }\n\n  getFirstText() {\n    return this\n  }\n\n  getLastText() {\n    return this\n  }\n\n  /**\n   * Get all of the marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.union(leaf.marks)\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the marks on the text.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks on the text as an array\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    if (this.leaves.size === 0) return []\n    const first = this.leaves.first().marks\n    if (this.leaves.size === 1) return first.toArray()\n\n    const result = []\n\n    this.leaves.forEach(leaf => {\n      result.push(leaf.marks.toArray())\n    })\n\n    return Array.prototype.concat.apply(first.toArray(), result)\n  }\n\n  /**\n   * Get the marks on the text at `index`.\n   * Corner Cases:\n   *   1. if no text is before the index, and index !== 0, then return Set()\n   *   2. (for insert after split node or mark at range) if index === 0, and text === '', then return the leaf.marks\n   *   3. if index === 0, text !== '', return Set()\n   *\n   *\n   * @param {Number} index\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtIndex(index) {\n    const { leaf } = this.searchLeafAtOffset(index)\n    if (!leaf) return Set()\n    return leaf.marks\n  }\n\n  /**\n   * Get a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode(key) {\n    return this.key == key ? this : null\n  }\n\n  /**\n   * Check if the node has a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode(key) {\n    return !!this.getNode(key)\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Numbder} offset\n   * @param {String} text\n   * @param {Set} marks (optional)\n   * @return {Text}\n   */\n\n  insertText(offset, text, marks) {\n    if (this.text === '') {\n      return this.set('leaves', List.of(Leaf.create({ text, marks })))\n    }\n\n    if (text.length === 0) return this\n    if (!marks) marks = Set()\n\n    const { startOffset, leaf, index } = this.searchLeafAtOffset(offset)\n    const delta = offset - startOffset\n    const beforeText = leaf.text.slice(0, delta)\n    const afterText = leaf.text.slice(delta)\n    const { leaves } = this\n\n    if (leaf.marks.equals(marks)) {\n      return this.set(\n        'leaves',\n        leaves.set(index, leaf.set('text', beforeText + text + afterText))\n      )\n    }\n\n    const nextLeaves = leaves.splice(\n      index,\n      1,\n      leaf.set('text', beforeText),\n      Leaf.create({ text, marks }),\n      leaf.set('text', afterText)\n    )\n\n    return this.setLeaves(nextLeaves)\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Text}\n   */\n\n  regenerateKey() {\n    const key = KeyUtils.create()\n    return this.set('key', key)\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(index, length, mark) {\n    if (this.text === '' && index === 0 && length === 0) {\n      const first = this.leaves.first()\n      if (!first) return this\n      const newFirst = first.removeMark(mark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.removeMark(mark)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Remove text from the text node at `start` for `length`.\n   *\n   * @param {Number} start\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(start, length) {\n    if (length <= 0) return this\n    if (start >= this.text.length) return this\n\n    // PERF: For simple backspace, we can operate directly on the leaf\n    if (length === 1) {\n      const { leaf, index, startOffset } = this.searchLeafAtOffset(start + 1)\n      const offset = start - startOffset\n\n      if (leaf) {\n        if (leaf.text.length === 1) {\n          const leaves = this.leaves.remove(index)\n          return this.setLeaves(leaves)\n        }\n\n        const beforeText = leaf.text.slice(0, offset)\n        const afterText = leaf.text.slice(offset + length)\n        const text = beforeText + afterText\n\n        if (text.length > 0) {\n          return this.set(\n            'leaves',\n            this.leaves.set(index, leaf.set('text', text))\n          )\n        }\n      }\n    }\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, start)\n    const after = Leaf.splitLeaves(bundle, length)[1]\n    const leaves = Leaf.createLeaves(before.concat(after))\n\n    if (leaves.size === 1) {\n      const first = leaves.first()\n\n      if (first.text === '') {\n        return this.set(\n          'leaves',\n          List.of(first.set('marks', this.getActiveMarks()))\n        )\n      }\n    }\n\n    return this.set('leaves', leaves)\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      leaves: this.getLeaves()\n        .toArray()\n        .map(r => r.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n\n  /**\n   * Update a `mark` at `index` and `length` with `properties`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Text}\n   */\n\n  updateMark(index, length, mark, properties) {\n    const newMark = mark.merge(properties)\n\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n      if (!first) return this\n      const newFirst = first.updateMark(mark, newMark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n\n    const leaves = before.concat(\n      middle.map(x => x.updateMark(mark, newMark)),\n      after\n    )\n\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Split this text and return two different texts\n   * @param {Number} position\n   * @returns {Array<Text>}\n   */\n\n  splitText(offset) {\n    const splitted = Leaf.splitLeaves(this.leaves, offset)\n    const one = this.set('leaves', splitted[0])\n    const two = this.set('leaves', splitted[1]).regenerateKey()\n    return [one, two]\n  }\n\n  /**\n   * merge this text and another text at the end\n   * @param {Text} text\n   * @returns {Text}\n   */\n\n  mergeText(text) {\n    const leaves = this.leaves.concat(text.leaves)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Normalize the text node with a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Function|Void}\n   */\n\n  normalize(schema) {\n    return schema.normalizeNode(this)\n  }\n\n  /**\n   * Validate the text node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Error|Void}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n\n  /**\n   * Get the first invalid descendant\n   * PERF: Do not cache this method; because it can cause cycle reference\n   *\n   * @param {Schema} schema\n   * @returns {Text|Null}\n   */\n\n  getFirstInvalidDescendant(schema) {\n    return this.validate(schema) ? this : null\n  }\n\n  /**\n   * Set leaves with normalized `leaves`\n   *\n   * @param {Schema} schema\n   * @returns {Text|Null}\n   */\n\n  setLeaves(leaves) {\n    const result = Leaf.createLeaves(leaves)\n\n    if (result.size === 1) {\n      const first = result.first()\n\n      if (!first.marks || first.marks.size === 0) {\n        if (first.text === '') {\n          return this.set('leaves', List())\n        }\n      }\n    }\n\n    return this.set('leaves', Leaf.createLeaves(leaves))\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nText.prototype[MODEL_TYPES.TEXT] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, [\n  'getDecorations',\n  'getActiveMarks',\n  'getMarks',\n  'getMarksAsArray',\n  'normalize',\n  'validate',\n  'getString',\n])\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import direction from 'direction'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, OrderedSet, Set } from 'immutable'\n\nimport Block from './block'\nimport Data from './data'\nimport Document from './document'\nimport Inline from './inline'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Range from './range'\nimport Text from './text'\nimport { isType } from '../constants/model-types'\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        logger.deprecate(\n          'slate@0.32.0',\n          'The `kind` property of Slate objects has been renamed to `object`.'\n        )\n\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = List(elements.map(Node.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        isVoid: attrs.isVoid,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      if ('isVoid' in attrs) props.isVoid = attrs.isVoid\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      logger.deprecate(\n        'slate@0.32.0',\n        'The `kind` property of Slate objects has been renamed to `object`.'\n      )\n\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Node.fromJSON\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return !!['BLOCK', 'DOCUMENT', 'INLINE', 'TEXT'].find(type =>\n      isType(type, any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  addMark(path, offset, length, mark) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.addMark(offset, length, mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants(iterator) {\n    const matches = []\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) matches.push(node)\n    })\n\n    return List(matches)\n  }\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant(iterator) {\n    let found = null\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) {\n        found = node\n        return false\n      }\n    })\n\n    return found\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant(iterator) {\n    let ret\n\n    this.nodes.forEach((child, i, nodes) => {\n      if (iterator(child, i, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object != 'text') {\n        ret = child.forEachDescendant(iterator)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get a set of the active marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Set()\n\n    if (range.isCollapsed) {\n      const { startKey, startOffset } = range\n      return this.getMarksAtPosition(startKey, startOffset).toSet()\n    }\n\n    let { startKey, endKey, startOffset, endOffset } = range\n    let startText = this.getDescendant(startKey)\n\n    if (startKey !== endKey) {\n      while (startKey !== endKey && endOffset === 0) {\n        const endText = this.getPreviousText(endKey)\n        endKey = endText.key\n        endOffset = endText.text.length\n      }\n\n      while (startKey !== endKey && startOffset === startText.text.length) {\n        startText = this.getNextText(startKey)\n        startKey = startText.key\n        startOffset = 0\n      }\n    }\n\n    if (startKey === endKey) {\n      return startText.getActiveMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const startMarks = startText.getActiveMarksBetweenOffsets(\n      startOffset,\n      startText.text.length\n    )\n    if (startMarks.size === 0) return Set()\n    const endText = this.getDescendant(endKey)\n    const endMarks = endText.getActiveMarksBetweenOffsets(0, endOffset)\n    let marks = startMarks.intersect(endMarks)\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) return marks\n\n    let text = this.getNextText(startKey)\n\n    while (text.key !== endKey) {\n      if (text.text.length !== 0) {\n        marks = marks.intersect(text.getActiveMarks())\n        if (marks.size === 0) return Set()\n      }\n\n      text = this.getNextText(text.key)\n    }\n    return marks\n  }\n\n  /**\n   * Get a list of the ancestors of a descendant.\n   *\n   * @param {List|String} path\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const ancestors = []\n\n    path.forEach((p, i) => {\n      const current = path.slice(0, i)\n      const parent = this.getNode(current)\n      ancestors.push(parent)\n    })\n\n    return List(ancestors)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const array = this.getBlocksAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray() {\n    return this.nodes.reduce((array, child) => {\n      if (child.object != 'block') return array\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray())\n      array.push(child)\n      return array\n    }, [])\n  }\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange(range) {\n    const array = this.getBlocksAtRangeAsArray(range)\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return new List(new OrderedSet(array))\n  }\n\n  /**\n   * Get the leaf block descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    const { startKey, endKey } = range\n    const startBlock = this.getClosestBlock(startKey)\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey === endKey) return [startBlock]\n\n    const endBlock = this.getClosestBlock(endKey)\n    const blocks = this.getBlocksAsArray()\n    const start = blocks.indexOf(startBlock)\n    const end = blocks.indexOf(endBlock)\n    return blocks.slice(start, end + 1)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const array = this.getBlocksByTypeAsArray(type)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      if (node.object != 'block') {\n        return array\n      } else if (node.isLeafBlock() && node.type == type) {\n        array.push(node)\n        return array\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Get all of the characters for every text node.\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    const characters = this.getTexts().flatMap(t => t.characters)\n    return characters\n  }\n\n  /**\n   * Get a list of the characters in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Character>}\n   */\n\n  getCharactersAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return List()\n    const { startKey, endKey, startOffset, endOffset } = range\n\n    if (startKey === endKey) {\n      const endText = this.getDescendant(endKey)\n      return endText.characters.slice(startOffset, endOffset)\n    }\n\n    return this.getTextsAtRange(range).flatMap(t => {\n      if (t.key === startKey) {\n        return t.characters.slice(startOffset)\n      }\n\n      if (t.key === endKey) {\n        return t.characters.slice(0, endOffset)\n      }\n      return t.characters\n    })\n  }\n\n  /**\n   * Get a child node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getChild(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    const child = path.size === 1 ? this.nodes.get(path.first()) : null\n    return child\n  }\n\n  /**\n   * Get closest parent of node that matches an `iterator`.\n   *\n   * @param {List|String} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const closest = ancestors.findLast((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return closest || null\n  }\n\n  /**\n   * Get the closest block parent of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(path) {\n    const closest = this.getClosest(path, n => n.object === 'block')\n    return closest\n  }\n\n  /**\n   * Get the closest inline parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestInline(path) {\n    const closest = this.getClosest(path, n => n.object === 'inline')\n    return closest\n  }\n\n  /**\n   * Get the closest void parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(path) {\n    const closest = this.getClosest(path, p => p.isVoid)\n    return closest\n  }\n\n  /**\n   * Get the common ancestor of nodes `a` and `b`.\n   *\n   * @param {List} a\n   * @param {List} b\n   * @return {Node}\n   */\n\n  getCommonAncestor(a, b) {\n    a = this.resolvePath(a)\n    b = this.resolvePath(b)\n    if (!a || !b) return null\n\n    const path = PathUtils.relate(a, b)\n    const node = this.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the decorations for the node from a `stack`.\n   *\n   * @param {Stack} stack\n   * @return {List}\n   */\n\n  getDecorations(stack) {\n    const decorations = stack.find('decorateNode', this)\n    const list = Range.createList(decorations || [])\n    return list\n  }\n\n  /**\n   * Get the depth of a descendant, with optional `startAt`.\n   *\n   * @param {List|String} path\n   * @param {Number} startAt\n   * @return {Number|Null}\n   */\n\n  getDepth(path, startAt = 1) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const node = this.getNode(path)\n    const depth = node ? path.size - 1 + startAt : null\n    return depth\n  }\n\n  /**\n   * Get a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getDescendant(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n\n    const array = path.toArray()\n    let descendant = this\n\n    for (const index of array) {\n      if (!descendant) return null\n      if (!descendant.nodes) return null\n      descendant = descendant.nodes.get(index)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Get the first invalid descendant\n   *\n   * @param {Schema} schema\n   * @return {Node|Text|Null}\n   */\n\n  getFirstInvalidDescendant(schema) {\n    let result = null\n\n    this.nodes.find(n => {\n      result = n.validate(schema) ? n : n.getFirstInvalidDescendant(schema)\n      return result\n    })\n\n    return result\n  }\n\n  /**\n   * Get the first child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    let descendant = null\n\n    const found = this.nodes.find(node => {\n      if (node.object === 'text') return true\n      descendant = node.getFirstText()\n      return !!descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = range.normalize(this)\n\n    if (range.isUnset) {\n      return Document.create()\n    }\n\n    const { startPath, startOffset, endPath, endOffset } = range\n    let node = this\n    let targetPath = endPath\n    let targetPosition = endOffset\n    let mode = 'end'\n\n    while (targetPath.size) {\n      const index = targetPath.last()\n      node = node.splitNode(targetPath, targetPosition)\n      targetPosition = index + 1\n      targetPath = PathUtils.lift(targetPath)\n\n      if (!targetPath.size && mode === 'end') {\n        targetPath = startPath\n        targetPosition = startOffset\n        mode = 'start'\n      }\n    }\n\n    const startIndex = startPath.first() + 1\n    const endIndex = endPath.first() + 2\n    const nodes = node.nodes.slice(startIndex, endIndex)\n    const fragment = Document.create({ nodes })\n    return fragment\n  }\n\n  /**\n   * Get the furthest parent of a node that matches an `iterator`.\n   *\n   * @param {Path} path\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest(path, iterator) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors.find((node, ...args) => {\n      // We never want to include the top-level node.\n      if (node === this) return false\n      return iterator(node, ...args)\n    })\n\n    return furthest || null\n  }\n\n  /**\n   * Get the furthest ancestor of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    const furthest = path.size ? this.nodes.get(path.first()) : null\n    return furthest\n  }\n\n  /**\n   * Get the furthest block parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'block')\n    return furthest\n  }\n\n  /**\n   * Get the furthest inline parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'inline')\n    return furthest\n  }\n\n  /**\n   * Get the furthest ancestor of a node that has only one child.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor(path) {\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors\n      .rest()\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      .last()\n\n    return furthest || null\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const array = this.getInlinesAsArray()\n    const list = new List(array)\n    return list\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray() {\n    let array = []\n\n    this.nodes.forEach(child => {\n      if (child.object == 'text') return\n\n      if (child.isLeafInline()) {\n        array.push(child)\n      } else {\n        array = array.concat(child.getInlinesAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange(range) {\n    const array = this.getInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    const list = new List(new OrderedSet(array))\n    return list\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const array = this.getInlinesByTypeAsArray(type)\n    const list = new List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray(type) {\n    const array = this.nodes.reduce((inlines, node) => {\n      if (node.object == 'text') {\n        return inlines\n      } else if (node.isLeafInline() && node.type == type) {\n        inlines.push(node)\n        return inlines\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type))\n      }\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Set()\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(range.startKey, range.startOffset)\n    }\n\n    const { startKey, startOffset } = range\n    const text = this.getDescendant(startKey)\n    const marks = text.getMarksAtIndex(startOffset + 1)\n    return marks\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Object}\n   */\n\n  getKeysToPathsTable() {\n    const ret = {\n      [this.key]: [],\n    }\n\n    this.nodes.forEach((node, i) => {\n      ret[node.key] = [i]\n\n      if (node.object !== 'text') {\n        const nested = node.getKeysToPathsTable()\n\n        for (const key in nested) {\n          const path = nested[key]\n          ret[key] = [i, ...path]\n        }\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get the last child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    let descendant = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object == 'text') return true\n      descendant = node.getLastText()\n      return descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    const set = new Set(array)\n    return set\n  }\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    const result = []\n\n    this.nodes.forEach(node => {\n      result.push(node.getMarksAsArray())\n    })\n\n    // PERF: use only one concat rather than multiple for speed.\n    const array = [].concat(...result)\n    return array\n  }\n\n  /**\n   * Get a set of marks in a `position`, the equivalent of a collapsed range\n   *\n   * @param {string} key\n   * @param {number} offset\n   * @return {Set}\n   */\n\n  getMarksAtPosition(key, offset) {\n    const text = this.getDescendant(key)\n    const currentMarks = text.getMarksAtIndex(offset)\n    if (offset !== 0) return currentMarks\n    const closestBlock = this.getClosestBlock(key)\n\n    if (closestBlock.text === '') {\n      // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n      return currentMarks\n    }\n\n    const previous = this.getPreviousText(key)\n    if (!previous) return Set()\n\n    if (closestBlock.hasDescendant(previous.key)) {\n      return previous.getMarksAtIndex(previous.text.length)\n    }\n\n    return currentMarks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    const marks = new Set(this.getOrderedMarksAtRange(range))\n    return marks\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    const set = new Set(array)\n    return set\n  }\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray(type) {\n    const array = this.nodes.reduce((memo, node) => {\n      return node.object == 'text'\n        ? memo.concat(node.getMarksAsArray().filter(m => m.type == type))\n        : memo.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n\n    return array\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock(key) {\n    const child = this.assertDescendant(key)\n    let last\n\n    if (child.object == 'block') {\n      last = child.getLastText()\n    } else {\n      const block = this.getClosestBlock(key)\n      last = block.getLastText()\n    }\n\n    const next = this.getNextText(last.key)\n    if (!next) return null\n\n    const closest = this.getClosestBlock(next.key)\n    return closest\n  }\n\n  /**\n   * Get the next node in the tree from a node.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the next ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      const target = PathUtils.increment(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the next sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const p = PathUtils.increment(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const next = this.getNextNode(path)\n    if (!next) return null\n    const text = next.getFirstText()\n    return text\n  }\n\n  /**\n   * Get a node in the tree.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    const node = path.size ? this.getDescendant(path) : this\n    return node\n  }\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset(key) {\n    this.assertDescendant(key)\n\n    // Calculate the offset of the nodes before the highest child.\n    const child = this.getFurthestAncestor(key)\n    const offset = this.nodes\n      .takeUntil(n => n == child)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    const ret = this.hasChild(key) ? offset : offset + child.getOffset(key)\n    return ret\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = range.normalize(this)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { startKey, startOffset } = range\n    const offset = this.getOffset(startKey) + startOffset\n    return offset\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks() {\n    const array = this.getMarksAsArray()\n    const set = new OrderedSet(array)\n    return set\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return OrderedSet()\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(range.startKey, range.startOffset)\n    }\n\n    const { startKey, startOffset, endKey, endOffset } = range\n    const marks = this.getOrderedMarksBetweenPositions(\n      startKey,\n      startOffset,\n      endKey,\n      endOffset\n    )\n\n    return marks\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   * PERF: arguments use key and offset for utilizing cache\n   *\n   * @param {string} startKey\n   * @param {number} startOffset\n   * @param {string} endKey\n   * @param {number} endOffset\n   * @returns {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset) {\n    if (startKey === endKey) {\n      const startText = this.getDescendant(startKey)\n      return startText.getMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const texts = this.getTextsBetweenPositionsAsArray(startKey, endKey)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        if (text.key === startKey) {\n          result.union(\n            text.getMarksBetweenOffsets(startOffset, text.text.length)\n          )\n        } else if (text.key === endKey) {\n          result.union(text.getMarksBetweenOffsets(0, endOffset))\n        } else {\n          result.union(text.getMarks())\n        }\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    const set = new OrderedSet(array)\n    return set\n  }\n\n  /**\n   * Get the parent of a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getParent(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const parentPath = PathUtils.lift(path)\n    const parent = this.getNode(parentPath)\n    return parent\n  }\n\n  /**\n   * Find the path to a node.\n   *\n   * @param {String|List} key\n   * @return {List}\n   */\n\n  getPath(key) {\n    // Handle the case of passing in a path directly, to match other methods.\n    if (List.isList(key)) return key\n\n    const dict = this.getKeysToPathsTable()\n    const path = dict[key]\n    return path ? List(path) : null\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(key) {\n    const child = this.assertDescendant(key)\n    let first\n\n    if (child.object == 'block') {\n      first = child.getFirstText()\n    } else {\n      const block = this.getClosestBlock(key)\n      first = block.getFirstText()\n    }\n\n    const previous = this.getPreviousText(first.key)\n    if (!previous) return null\n\n    const closest = this.getClosestBlock(previous.key)\n    return closest\n  }\n\n  /**\n   * Get the previous node from a node in the tree.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      if (p.last() === 0) continue\n\n      const target = PathUtils.decrement(p)\n      const node = this.getNode(target)\n      if (node) return node\n    }\n\n    return null\n  }\n\n  /**\n   * Get the previous sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    if (path.last() === 0) return null\n    const p = PathUtils.decrement(path)\n    const sibling = this.getNode(p)\n    return sibling\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousText(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const previous = this.getPreviousNode(path)\n    if (!previous) return null\n    const text = previous.getLastText()\n    return text\n  }\n\n  /**\n   * Get the indexes of the selection for a `range`, given an extra flag for\n   * whether the node `isSelected`, to determine whether not finding matches\n   * means everything is selected or nothing is.\n   *\n   * @param {Range} range\n   * @param {Boolean} isSelected\n   * @return {Object|Null}\n   */\n\n  getSelectionIndexes(range, isSelected = true) {\n    const { startKey, endKey } = range\n\n    // PERF: if we're not selected, we can exit early.\n    if (!isSelected) {\n      return null\n    }\n\n    // if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (startKey == endKey) {\n      const child = this.getFurthestAncestor(startKey)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let start = null\n    let end = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object == 'text') {\n        if (start == null && child.key == startKey) start = i\n        if (end == null && child.key == endKey) end = i + 1\n      } else {\n        if (start == null && child.hasDescendant(startKey)) start = i\n        if (end == null && child.hasDescendant(endKey)) end = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return start == null || end == null\n    })\n\n    if (isSelected && start == null) start = 0\n    if (isSelected && end == null) end = this.nodes.size\n    return start == null ? null : { start, end }\n  }\n\n  /**\n   * Get the concatenated text string of all child nodes.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    const text = this.nodes.reduce((string, node) => {\n      return string + node.text\n    }, '')\n\n    return text\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset === 0) return this.getFirstText()\n    if (offset === this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n    const text = this.getTexts().find((node, i, nodes) => {\n      length += node.text.length\n      return length > offset\n    })\n\n    return text\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = direction(this.text)\n    return dir === 'neutral' ? null : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const array = this.getTextsAsArray()\n    const list = new List(array)\n    return list\n  }\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray() {\n    let array = []\n\n    this.nodes.forEach(node => {\n      if (node.object == 'text') {\n        array.push(node)\n      } else {\n        array = array.concat(node.getTextsAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return List()\n    const { startKey, endKey } = range\n    const list = new List(\n      this.getTextsBetweenPositionsAsArray(startKey, endKey)\n    )\n\n    return list\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getTextsAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n    const { startKey, endKey } = range\n    const texts = this.getTextsBetweenPositionsAsArray(startKey, endKey)\n    return texts\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   * PERF: use key in arguments for cache\n   *\n   * @param {string} startKey\n   * @param {string} endKey\n   * @returns {Array}\n   */\n\n  getTextsBetweenPositionsAsArray(startKey, endKey) {\n    const startText = this.getDescendant(startKey)\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startText]\n\n    const endText = this.getDescendant(endKey)\n    const texts = this.getTextsAsArray()\n    const start = texts.indexOf(startText)\n    const end = texts.indexOf(endText, start)\n    const ret = texts.slice(start, end + 1)\n    return ret\n  }\n\n  /**\n   * Check if the node has block children.\n   *\n   * @return {Boolean}\n   */\n\n  hasBlockChildren() {\n    return !!(this.nodes && this.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasChild(path) {\n    const child = this.getChild(path)\n    return !!child\n  }\n\n  /**\n   * Check if a node has inline children.\n   *\n   * @return {Boolean}\n   */\n\n  hasInlineChildren() {\n    return !!(\n      this.nodes &&\n      this.nodes.find(n => n.object === 'inline' || n.object === 'text')\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasDescendant(path) {\n    const descendant = this.getDescendant(path)\n    return !!descendant\n  }\n\n  /**\n   * Recursively check if a node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasNode(path) {\n    const node = this.getNode(path)\n    return !!node\n  }\n\n  /**\n   * Check if a node has a void parent.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasVoidParent(path) {\n    const closest = this.getClosestVoid(path)\n    return !!closest\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(path, node) {\n    path = this.resolvePath(path)\n    const index = path.last()\n    const parentPath = PathUtils.lift(path)\n    let parent = this.assertNode(parentPath)\n    const nodes = parent.nodes.splice(index, 0, node)\n    parent = parent.set('nodes', nodes)\n    const ret = this.replaceNode(parentPath, parent)\n    return ret\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @param {Set} marks\n   * @return {Node}\n   */\n\n  insertText(path, offset, text, marks) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.insertText(offset, text, marks)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    return (\n      this.object === 'block' && this.nodes.every(n => n.object !== 'block')\n    )\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    return (\n      this.object === 'inline' && this.nodes.every(n => n.object !== 'inline')\n    )\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = iterator(node, i, this.nodes)\n      if (ret !== node) nodes = nodes.set(ret.key, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object !== 'text') ret = ret.mapDescendants(iterator)\n      ret = iterator(ret, index, this.nodes)\n      if (ret === node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Node}\n   */\n\n  mergeNode(path) {\n    const b = this.assertNode(path)\n    path = this.resolvePath(path)\n\n    if (path.last() === 0) {\n      throw new Error(\n        `Unable to merge node because it has no previous sibling: ${b}`\n      )\n    }\n\n    const withPath = PathUtils.decrement(path)\n    const a = this.assertNode(withPath)\n\n    if (a.object !== b.object) {\n      throw new Error(\n        `Unable to merge two different kinds of nodes: ${a} and ${b}`\n      )\n    }\n\n    const newNode =\n      a.object === 'text'\n        ? a.mergeText(b)\n        : a.set('nodes', a.nodes.concat(b.nodes))\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.removeNode(withPath)\n    ret = ret.insertNode(withPath, newNode)\n    return ret\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Node}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    const node = this.assertNode(path)\n    path = this.resolvePath(path)\n    newPath = this.resolvePath(newPath, newIndex)\n\n    const newParentPath = PathUtils.lift(newPath)\n    this.assertNode(newParentPath)\n\n    const [p, np] = PathUtils.crop(path, newPath)\n    const position = PathUtils.compare(p, np)\n\n    // If the old path ends above and before a node in the new path, then\n    // removing it will alter the target, so we need to adjust the new path.\n    if (path.size < newPath.size && position === -1) {\n      newPath = PathUtils.decrement(newPath, 1, p.size - 1)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(newPath, node)\n    return ret\n  }\n\n  /**\n   * Attempt to \"refind\" a node by a previous `path`, falling back to looking\n   * it up by `key` again.\n   *\n   * @param {List|String} path\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  refindNode(path, key) {\n    const node = this.getDescendant(path)\n    const found = node && node.key === key ? node : this.getDescendant(key)\n    return found\n  }\n\n  /**\n   * Attempt to \"refind\" the path to a node by a previous `path`, falling back\n   * to looking it up by `key`.\n   *\n   * @param {List|String} path\n   * @param {String} key\n   * @return {List|Null}\n   */\n\n  refindPath(path, key) {\n    const node = this.getDescendant(path)\n    const found = node && node.key === key ? path : this.getPath(key)\n    return found\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = KeyUtils.create()\n    const node = this.set('key', key)\n    return node\n  }\n\n  /**\n   * Remove mark from text at `offset` and `length` in node.\n   *\n   * @param {List} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  removeMark(path, offset, length, mark) {\n    let node = this.assertDescendant(path)\n    path = this.resolvePath(path)\n    node = node.removeMark(offset, length, mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Remove a node.\n   *\n   * @param {List|String} path\n   * @return {Node}\n   */\n\n  removeNode(path) {\n    this.assertDescendant(path)\n    path = this.resolvePath(path)\n    const deep = path.flatMap(x => List(['nodes', x]))\n    const ret = this.deleteIn(deep)\n    return ret\n  }\n\n  /**\n   * Remove `text` at `offset` in node.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  removeText(path, offset, text) {\n    let node = this.assertDescendant(path)\n    node = node.removeText(offset, text.length)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Replace a `node` in the tree.\n   *\n   * @param {List|Key} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  replaceNode(path, node) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      throw new Error(\n        `Unable to replace a node because it could not be found in the first place: ${path}`\n      )\n    }\n\n    if (!path.size) return node\n    this.assertNode(path)\n    const deep = path.flatMap(x => List(['nodes', x]))\n    const ret = this.setIn(deep, node)\n    return ret\n  }\n\n  /**\n   * Resolve a path from a path list or key string.\n   *\n   * An `index` can be provided, in which case paths created from a key string\n   * will have the index pushed onto them. This is helpful in cases where you\n   * want to accept either a `path` or a `key, index` combination for targeting\n   * a location in the tree that doesn't exist yet, like when inserting.\n   *\n   * @param {List|String} value\n   * @param {Number} index\n   * @return {List}\n   */\n\n  resolvePath(path, index) {\n    if (typeof path === 'string') {\n      path = this.getPath(path)\n\n      if (index != null) {\n        path = path.concat(index)\n      }\n    } else {\n      path = PathUtils.create(path)\n    }\n\n    return path\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setNode(path, properties) {\n    let node = this.assertNode(path)\n    node = node.merge(properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setMark(path, offset, length, mark, properties) {\n    let node = this.assertNode(path)\n    node = node.updateMark(offset, length, mark, properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  splitNode(path, position, properties) {\n    const child = this.assertNode(path)\n    path = this.resolvePath(path)\n    let a\n    let b\n\n    if (child.object === 'text') {\n      ;[a, b] = child.splitText(position)\n    } else {\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      a = child.set('nodes', befores)\n      b = child.set('nodes', afters).regenerateKey()\n    }\n\n    if (properties && child.object !== 'text') {\n      b = b.merge(properties)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(path, b)\n    ret = ret.insertNode(path, a)\n    return ret\n  }\n\n  /**\n   * Normalize the node with a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Function|Void}\n   */\n\n  normalize(schema) {\n    return schema.normalizeNode(this)\n  }\n\n  /**\n   * Validate the node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Error|Void}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  getNodeAtPath(path) {\n    logger.deprecate(\n      `0.35.0`,\n      'The `Node.getNodeAtPath` method has been combined into `Node.getNode`.'\n    )\n\n    return this.getNode(path)\n  }\n\n  getDescendantAtPath(path) {\n    logger.deprecate(\n      `0.35.0`,\n      'The `Node.getDescendantAtPath` has been combined into `Node.getDescendant`.'\n    )\n\n    return this.getDescendant(path)\n  }\n\n  getKeys() {\n    logger.deprecate(`0.35.0`, 'The `Node.getKeys` method is deprecated.')\n\n    const keys = this.getKeysAsArray()\n    return new Set(keys)\n  }\n\n  getKeysAsArray() {\n    logger.deprecate(\n      `0.35.0`,\n      'The `Node.getKeysAsArray` method is deprecated.'\n    )\n\n    const dict = this.getKeysToPathsTable()\n    const keys = []\n\n    for (const key in dict) {\n      if (this.key !== key) {\n        keys.push(key)\n      }\n    }\n\n    return keys\n  }\n\n  areDescendantsSorted(first, second) {\n    logger.deprecate(\n      `0.35.0`,\n      'The `Node.areDescendantsSorted` method is deprecated. Use the new `PathUtils.compare` helper instead.'\n    )\n\n    first = KeyUtils.create(first)\n    second = KeyUtils.create(second)\n\n    const keys = this.getKeysAsArray().filter(k => k !== this.key)\n    const firstIndex = keys.indexOf(first)\n    const secondIndex = keys.indexOf(second)\n    if (firstIndex == -1 || secondIndex == -1) return null\n\n    return firstIndex < secondIndex\n  }\n\n  isInRange(range) {\n    logger.deprecate(\n      `0.35.0`,\n      'The `Node.isInRange` method is deprecated. Use the new `PathUtils.compare` helper instead.'\n    )\n\n    range = range.normalize(this)\n\n    const node = this\n    const { startKey, endKey, isCollapsed } = range\n\n    // PERF: solve the most common cast where the start or end key are inside\n    // the node, for collapsed selections.\n    if (\n      node.key == startKey ||\n      node.key == endKey ||\n      node.hasDescendant(startKey) ||\n      node.hasDescendant(endKey)\n    ) {\n      return true\n    }\n\n    // PERF: if the selection is collapsed and the previous check didn't return\n    // true, then it must be false.\n    if (isCollapsed) {\n      return false\n    }\n\n    // Otherwise, look through all of the leaf text nodes in the range, to see\n    // if any of them are inside the node.\n    const texts = node.getTextsAtRange(range)\n    let memo = false\n\n    texts.forEach(text => {\n      if (node.hasDescendant(text.key)) memo = true\n      return memo\n    })\n\n    return memo\n  }\n}\n\n/**\n * Mix in assertion variants.\n */\n\nconst ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path']\n\nfor (const method of ASSERTS) {\n  Node.prototype[`assert${method}`] = function(path, ...args) {\n    const ret = this[`get${method}`](path, ...args)\n\n    if (ret == null) {\n      throw new Error(\n        `\\`Node.assert${method}\\` could not find node with path or key: ${path}`\n      )\n    }\n\n    return ret\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Node.prototype, [\n  'getBlocksAsArray',\n  'getBlocksAtRangeAsArray',\n  'getBlocksByTypeAsArray',\n  'getDecorations',\n  'getFirstInvalidDescendant',\n  'getFirstText',\n  'getFragmentAtRange',\n  'getInlinesAsArray',\n  'getInlinesAtRangeAsArray',\n  'getInlinesByTypeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getOrderedMarksBetweenPositions',\n  'getInsertMarksAtRange',\n  'getKeysToPathsTable',\n  'getLastText',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getOffset',\n  'getOffsetAtRange',\n  'getPreviousBlock',\n  'getText',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPositionsAsArray',\n  'isLeafBlock',\n  'isLeafInline',\n  'normalize',\n  'validate',\n])\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(method => {\n  if (method === 'constructor') return\n  Block.prototype[method] = Node.prototype[method]\n  Inline.prototype[method] = Node.prototype[method]\n  Document.prototype[method] = Node.prototype[method]\n})\n\nBlock.createChildren = Node.createList\nInline.createChildren = Node.createList\nDocument.createChildren = Node.createList\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  const char = text.charAt(0)\n  return getCharLength(char)\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharLength,\n  getCharOffset,\n  getCharOffsetBackward,\n  getCharOffsetForward,\n  getWordOffset,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n  isSurrogate,\n  isWord,\n}\n","import { List } from 'immutable'\nimport logger from 'slate-dev-logger'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport TextUtils from '../utils/text-utils'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset, endKey, endOffset } = range\n  const texts = document.getTextsAtRange(range)\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.addMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarksAtRange = (change, range, marks, options = {}) => {\n  marks.forEach(mark => change.addMarkAtRange(range, mark, options))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteAtRange = (change, range, options = {}) => {\n  if (range.isCollapsed) return\n\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection()\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { startKey, startOffset, endKey, endOffset } = range\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey)\n  let isEndVoid = document.hasVoidParent(endKey)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start node is inside a void node, remove the void node and update\n  // the starting point to be right after it, continuously until the start point\n  // is not a void, or until the entire range is handled.\n  while (isStartVoid) {\n    const startVoid = document.getClosestVoid(startKey)\n    const nextText = document.getNextText(startKey)\n    change.removeNodeByKey(startVoid.key, { normalize: false })\n\n    // If the start and end keys are the same, we're done.\n    if (startKey == endKey) return\n\n    // If there is no next text node, we're done.\n    if (!nextText) return\n\n    // Continue...\n    document = change.value.document\n    startKey = nextText.key\n    startOffset = 0\n    isStartVoid = document.hasVoidParent(startKey)\n  }\n\n  // If the end node is inside a void node, do the same thing but backwards. But\n  // we don't need any aborting checks because if we've gotten this far there\n  // must be a non-void node that will exit the loop.\n  while (isEndVoid) {\n    const endVoid = document.getClosestVoid(endKey)\n    const prevText = document.getPreviousText(endKey)\n    change.removeNodeByKey(endVoid.key, { normalize: false })\n\n    // Continue...\n    document = change.value.document\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start and end key are the same, and it was a hanging selection, we\n  // can just remove the entire block.\n  if (startKey == endKey && isHanging) {\n    change.removeNodeByKey(startBlock.key, { normalize })\n    return\n  } else if (startKey == endKey) {\n    // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n    // simply remove the text in the range.\n    const index = startOffset\n    const length = endOffset - startOffset\n    change.removeTextByKey(startKey, index, length, { normalize })\n    return\n  } else {\n    // Otherwise, we need to recursively remove text and nodes inside the start\n    // block after the start offset and inside the end block before the end\n    // offset. Then remove any blocks that are in between the start and end\n    // blocks. Then finally merge the start and end nodes.\n    startBlock = document.getClosestBlock(startKey)\n    endBlock = document.getClosestBlock(endKey)\n    const startText = document.getNode(startKey)\n    const endText = document.getNode(endKey)\n    const startLength = startText.text.length - startOffset\n    const endLength = endOffset\n\n    const ancestor = document.getCommonAncestor(startKey, endKey)\n    const startChild = ancestor.getFurthestAncestor(startKey)\n    const endChild = ancestor.getFurthestAncestor(endKey)\n\n    const startParent = document.getParent(startBlock.key)\n    const startParentIndex = startParent.nodes.indexOf(startBlock)\n    const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n    let child\n\n    // Iterate through all of the nodes in the tree after the start text node\n    // but inside the end child, and remove them.\n    child = startText\n\n    while (child.key != startChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const afters = parent.nodes.slice(index + 1)\n\n      afters.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove all of the middle children.\n    const startChildIndex = ancestor.nodes.indexOf(startChild)\n    const endChildIndex = ancestor.nodes.indexOf(endChild)\n    const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n    middles.reverse().forEach(node => {\n      change.removeNodeByKey(node.key, { normalize: false })\n    })\n\n    // Remove the nodes before the end text node in the tree.\n    child = endText\n\n    while (child.key != endChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const befores = parent.nodes.slice(0, index)\n\n      befores.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove any overlapping text content from the leaf text nodes.\n    if (startLength != 0) {\n      change.removeTextByKey(startKey, startOffset, startLength, {\n        normalize: false,\n      })\n    }\n\n    if (endLength != 0) {\n      change.removeTextByKey(endKey, 0, endOffset, { normalize: false })\n    }\n\n    // If the start and end blocks aren't the same, move and merge the end block\n    // into the start block.\n    if (startBlock.key != endBlock.key) {\n      document = change.value.document\n      const lonely = document.getFurthestOnlyChildAncestor(endBlock.key)\n\n      // Move the end block to be right after the start block.\n      if (endParentIndex != startParentIndex + 1) {\n        change.moveNodeByKey(\n          endBlock.key,\n          startParent.key,\n          startParentIndex + 1,\n          { normalize: false }\n        )\n      }\n\n      // If the selection is hanging, just remove the start block, otherwise\n      // merge the end block into it.\n      if (isHanging) {\n        change.removeNodeByKey(startBlock.key, { normalize: false })\n      } else {\n        change.mergeNodeByKey(endBlock.key, { normalize: false })\n      }\n\n      // If nested empty blocks are left over above the end block, remove them.\n      if (lonely) {\n        change.removeNodeByKey(lonely.key, { normalize: false })\n      }\n    }\n\n    // If we should normalize, do it now after everything.\n    if (normalize) {\n      change.normalizeNodeByKey(ancestor.key)\n    }\n  }\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  change.deleteBackwardAtRange(range, o, options)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = TextUtils.getWordOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteBackwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(startKey)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    change.removeNodeByKey(block.key, { normalize })\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n\n  if (range.isAtStartOf(text)) {\n    const prev = document.getPreviousText(text.key)\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      change.removeNodeByKey(prevVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.text.length,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focusOffset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  change.deleteForwardAtRange(range, startBlock.text.length - o, options)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = TextUtils.getWordOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteForwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(startKey)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    const nextBlock = document.getNextBlock(block.key)\n    change.removeNodeByKey(block.key, { normalize })\n\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOf(nextBlock)\n    }\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n\n  if (range.isAtEndOf(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      change.removeNodeByKey(nextVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focusOffset\n  let traversed = text.text.length - focusOffset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  let { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n\n  if (startBlock.isVoid) {\n    const extra = range.isAtEndOf(startBlock) ? 1 : 0\n    change.insertNodeByKey(parent.key, index + extra, block, { normalize })\n  } else if (startBlock.isEmpty) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else if (range.isAtStartOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block, { normalize })\n  } else if (range.isAtEndOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else {\n    if (startInline && startInline.isVoid) {\n      const atEnd = range.isAtEndOf(startInline)\n      const siblingText = atEnd\n        ? document.getNextText(startKey)\n        : document.getPreviousText(startKey)\n\n      const splitRange = atEnd\n        ? range.moveToStartOf(siblingText)\n        : range.moveToEndOf(siblingText)\n\n      startKey = splitRange.startKey\n      startOffset = splitRange.startOffset\n    }\n\n    change.splitDescendantsByKey(startBlock.key, startKey, startOffset, {\n      normalize: false,\n    })\n\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  }\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentAtRange = (change, range, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  // If the range is expanded, delete it first.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    if (change.value.document.getDescendant(range.startKey)) {\n      range = range.collapseToStart()\n    } else {\n      range = range.collapseTo(range.endKey, 0)\n    }\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n  // Calculate a few things...\n  const { startKey, startOffset } = range\n  const { value } = change\n  let { document } = value\n  let startText = document.getDescendant(startKey)\n  let startBlock = document.getClosestBlock(startText.key)\n  let startChild = startBlock.getFurthestAncestor(startText.key)\n  const isAtStart = range.isAtStartOf(startBlock)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n  const blocks = fragment.getBlocks()\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const firstBlock = blocks.first()\n  const lastBlock = blocks.last()\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock == lastBlock && firstBlock.isVoid) {\n    change.insertBlockAtRange(range, firstBlock, options)\n    return\n  }\n\n  // If the fragment starts or ends with single nested block, (e.g., table),\n  // do not merge this fragment with existing blocks.\n  if (firstChild.hasBlockChildren() || lastChild.hasBlockChildren()) {\n    fragment.nodes.reverse().forEach(node => {\n      change.insertBlockAtRange(range, node, options)\n    })\n    return\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    const lonelyParent = fragment.getFurthest(\n      firstBlock.key,\n      p => p.nodes.size == 1\n    )\n    const lonelyChild = lonelyParent || firstBlock\n    const startIndex = parent.nodes.indexOf(startBlock)\n    fragment = fragment.removeNode(lonelyChild.key)\n\n    fragment.nodes.forEach((node, i) => {\n      const newIndex = startIndex + i + 1\n      change.insertNodeByKey(parent.key, newIndex, node, { normalize: false })\n    })\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false,\n    })\n  }\n\n  // Update our variables with the new value.\n  document = change.value.document\n  startText = document.getDescendant(startKey)\n  startBlock = document.getClosestBlock(startKey)\n  startChild = startBlock.getFurthestAncestor(startText.key)\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    const nextChild = isAtStart\n      ? startChild\n      : startBlock.getNextSibling(startChild.key)\n    const nextNodes = nextChild\n      ? startBlock.nodes.skipUntil(n => n.key == nextChild.key)\n      : List()\n    const lastIndex = lastBlock.nodes.size\n\n    nextNodes.forEach((node, i) => {\n      const newIndex = lastIndex + i\n\n      change.moveNodeByKey(node.key, lastBlock.key, newIndex, {\n        normalize: false,\n      })\n    })\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    change.removeNodeByKey(startBlock.key, { normalize: false })\n    change.insertNodeByKey(parent.key, index, firstBlock, { normalize: false })\n  } else {\n    // Otherwise, we maintain the starting block, and insert all of the first\n    // block's inline nodes into it at the split point.\n    const inlineChild = startBlock.getFurthestAncestor(startText.key)\n    const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n    firstBlock.nodes.forEach((inline, i) => {\n      const o = startOffset == 0 ? 0 : 1\n      const newIndex = inlineIndex + i + o\n\n      change.insertNodeByKey(startBlock.key, newIndex, inline, {\n        normalize: false,\n      })\n    })\n  }\n\n  // Normalize if requested.\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertInlineAtRange = (change, range, inline, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  inline = Inline.create(inline)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const parent = document.getParent(startKey)\n  const startText = document.assertDescendant(startKey)\n  const index = parent.nodes.indexOf(startText)\n\n  if (parent.isVoid) return\n\n  change.splitNodeByKey(startKey, startOffset, { normalize: false })\n  change.insertNodeByKey(parent.key, index + 1, inline, { normalize: false })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextAtRange = (change, range, text, marks, options = {}) => {\n  let { normalize } = options\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  let key = startKey\n  let offset = startOffset\n  const parent = document.getParent(startKey)\n\n  if (parent.isVoid) return\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    // Update range start after delete\n    if (change.value.startKey !== key) {\n      key = change.value.startKey\n      offset = change.value.startOffset\n    }\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize === undefined) {\n    normalize = range.isExpanded && marks && marks.size !== 0\n  }\n\n  change.insertTextByKey(key, offset, text, marks, { normalize: false })\n\n  if (normalize) {\n    // normalize in the narrowest existing block that originally contains startKey and endKey\n    const commonAncestor = document.getCommonAncestor(startKey, range.endKey)\n    const ancestors = document\n      .getAncestors(commonAncestor.key)\n      .push(commonAncestor)\n    const normalizeAncestor = ancestors.findLast(n =>\n      change.value.document.getDescendant(n.key)\n    )\n    // it is possible that normalizeAncestor doesn't return any node\n    // on that case fallback to startKey to be normalized\n    const normalizeKey = normalizeAncestor ? normalizeAncestor.key : startKey\n    change.normalizeNodeByKey(normalizeKey)\n  }\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.removeMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setBlocksAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const blocks = document.getBlocksAtRange(range)\n\n  const { startKey, startOffset, endKey, endOffset, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(startKey)\n  const startBlock = document.getClosestBlock(startKey)\n  const endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed == false &&\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  sets.forEach(block => {\n    change.setNodeByKey(block.key, properties, { normalize })\n  })\n}\n\nChanges.setBlockAtRange = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setBlockAtRange` method of Slate changes has been renamed to `setBlocksAtRange`.'\n  )\n\n  Changes.setBlocksAtRange(...args)\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setInlinesAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const inlines = document.getInlinesAtRange(range)\n\n  inlines.forEach(inline => {\n    change.setNodeByKey(inline.key, properties, { normalize })\n  })\n}\n\nChanges.setInlineAtRange = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setInlineAtRange` method of Slate changes has been renamed to `setInlinesAtRange`.'\n  )\n\n  Changes.setInlinesAtRange(...args)\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitBlockAtRange = (change, range, height = 1, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  const { startKey, startOffset, endOffset, endKey } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, {\n    normalize: normalize && range.isCollapsed,\n  })\n\n  if (range.isExpanded) {\n    if (range.isBackward) range = range.flip()\n    const nextBlock = change.value.document.getNextBlock(node.key)\n    range = range.moveAnchorToStartOf(nextBlock)\n\n    if (startKey === endKey) {\n      range = range.moveFocusTo(range.anchorKey, endOffset - startOffset)\n    }\n\n    change.deleteAtRange(range, { normalize })\n  }\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitInlineAtRange = (\n  change,\n  range,\n  height = Infinity,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    range = range.collapseToStart()\n  }\n\n  const { startKey, startOffset } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, { normalize })\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.toggleMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark, { normalize })\n  } else {\n    change.addMarkAtRange(range, mark, { normalize })\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { document } = value\n  const blocks = document.getBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object != 'block') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  wrappers.forEach(block => {\n    const first = block.nodes.first()\n    const last = block.nodes.last()\n    const parent = document.getParent(block.key)\n    const index = parent.nodes.indexOf(block)\n\n    const children = block.nodes.filter(child => {\n      return blocks.some(b => child == b || child.hasDescendant(b.key))\n    })\n\n    const firstMatch = children.first()\n    const lastMatch = children.last()\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false,\n        })\n      })\n\n      change.removeNodeByKey(block.key, { normalize: false })\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(n => n == firstMatch).forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    } else if (first == firstMatch) {\n      block.nodes\n        .takeUntil(n => n == lastMatch)\n        .push(lastMatch)\n        .forEach((child, i) => {\n          change.moveNodeByKey(child.key, parent.key, index + i, {\n            normalize: false,\n          })\n        })\n    } else {\n      const firstText = firstMatch.getFirstText()\n\n      change.splitDescendantsByKey(block.key, firstText.key, 0, {\n        normalize: false,\n      })\n\n      document = change.value.document\n\n      children.forEach((child, i) => {\n        if (i == 0) {\n          const extra = child\n          child = document.getNextBlock(child.key)\n          change.removeNodeByKey(extra.key, { normalize: false })\n        }\n\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    }\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object != 'inline') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  inlines.forEach(inline => {\n    const parent = change.value.document.getParent(inline.key)\n    const index = parent.nodes.indexOf(inline)\n\n    inline.nodes.forEach((child, i) => {\n      change.moveNodeByKey(child.key, parent.key, index + i, {\n        normalize: false,\n      })\n    })\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const blocks = document.getBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 == p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  // Inject the new block node into the parent.\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach((node, i) => {\n    change.moveNodeByKey(node.key, block.key, i, { normalize: false })\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineAtRange = (change, range, inline, options = {}) => {\n  const { value } = change\n  let { document } = value\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(startKey)\n\n    if (!inlineParent.isVoid) {\n      return\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline, options)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n  const startInline = document.getClosestInline(startKey)\n  const endInline = document.getClosestInline(endKey)\n  let startChild = startBlock.getFurthestAncestor(startKey)\n  let endChild = endBlock.getFurthestAncestor(endKey)\n\n  if (!startInline || startInline != endInline) {\n    change.splitDescendantsByKey(endChild.key, endKey, endOffset, {\n      normalize: false,\n    })\n\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false,\n    })\n  }\n\n  document = change.value.document\n  startBlock = document.getDescendant(startBlock.key)\n  endBlock = document.getDescendant(endBlock.key)\n  startChild = startBlock.getFurthestAncestor(startKey)\n  endChild = endBlock.getFurthestAncestor(endKey)\n  const startIndex = startBlock.nodes.indexOf(startChild)\n  const endIndex = endBlock.nodes.indexOf(endChild)\n\n  if (startInline && startInline == endInline) {\n    const text = startBlock\n      .getTextsAtRange(range)\n      .get(0)\n      .splitText(startOffset)[1]\n      .splitText(endOffset - startOffset)[0]\n    inline = inline.set('nodes', List([text]))\n    Changes.insertInlineAtRange(change, range, inline, { normalize: false })\n    const inlinekey = inline.getFirstText().key\n    const rng = {\n      anchorKey: inlinekey,\n      focusKey: inlinekey,\n      anchorOffset: 0,\n      focusOffset: endOffset - startOffset,\n      isFocused: true,\n    }\n    change.select(rng)\n  } else if (startBlock == endBlock) {\n    document = change.value.document\n    startBlock = document.getClosestBlock(startKey)\n    startChild = startBlock.getFurthestAncestor(startKey)\n\n    const startInner = document.getNextSibling(startChild.key)\n    const startInnerIndex = startBlock.nodes.indexOf(startInner)\n    const endInner =\n      startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey)\n    const inlines = startBlock.nodes\n      .skipUntil(n => n == startInner)\n      .takeUntil(n => n == endInner)\n      .push(endInner)\n\n    const node = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startInnerIndex, node, {\n      normalize: false,\n    })\n\n    inlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key)\n    }\n  } else {\n    const startInlines = startBlock.nodes.slice(startIndex + 1)\n    const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n    const startNode = inline.regenerateKey()\n    const endNode = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startIndex + 1, startNode, {\n      normalize: false,\n    })\n\n    change.insertNodeByKey(endBlock.key, endIndex, endNode, {\n      normalize: false,\n    })\n\n    startInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, startNode.key, i, { normalize: false })\n    })\n\n    endInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, endNode.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key).normalizeNodeByKey(endBlock.key)\n    }\n\n    blocks.slice(1, -1).forEach(block => {\n      const node = inline.regenerateKey()\n      change.insertNodeByKey(block.key, 0, node, { normalize: false })\n\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n      })\n\n      if (normalize) {\n        change.normalizeNodeByKey(block.key)\n      }\n    })\n  }\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapTextAtRange = (\n  change,\n  range,\n  prefix,\n  suffix = prefix,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, endKey } = range\n  const start = range.collapseToStart()\n  let end = range.collapseToEnd()\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length)\n  }\n\n  change.insertTextAtRange(start, prefix, [], { normalize })\n  change.insertTextAtRange(end, suffix, [], { normalize })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport PathUtils from '../utils/path-utils'\nimport Range from '../models/range'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n */\n\nChanges.addMarkByPath = (change, path, offset, length, mark, options) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'add_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n * @param {Object} options\n */\n\nChanges.insertFragmentByPath = (change, path, index, fragment, options) => {\n  fragment.nodes.forEach((node, i) => {\n    change.insertNodeByPath(path, index + i, node)\n  })\n\n  change.normalizeNodeByPath(path, options)\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n */\n\nChanges.insertNodeByPath = (change, path, index, node, options) => {\n  const { value } = change\n\n  change.applyOperation({\n    type: 'insert_node',\n    value,\n    path: path.concat(index),\n    node,\n  })\n\n  change.normalizeNodeByPath(path, options)\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n */\n\nChanges.insertTextByPath = (change, path, offset, text, marks, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  marks = marks || node.getMarksAtIndex(offset)\n\n  change.applyOperation({\n    type: 'insert_text',\n    value,\n    path,\n    offset,\n    text,\n    marks,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.mergeNodeByPath = (change, path, options) => {\n  const { value } = change\n  const { document } = value\n  const original = document.getDescendant(path)\n  const previous = document.getPreviousSibling(path)\n\n  if (!previous) {\n    throw new Error(\n      `Unable to merge node with path \"${path}\", because it has no previous sibling.`\n    )\n  }\n\n  const position =\n    previous.object == 'text' ? previous.text.length : previous.nodes.size\n\n  change.applyOperation({\n    type: 'merge_node',\n    value,\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Move a node by `path` to a new parent by `newPath` and `index`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} newPath\n * @param {Number} index\n * @param {Object} options\n */\n\nChanges.moveNodeByPath = (change, path, newPath, newIndex, options) => {\n  const { value } = change\n\n  change.applyOperation({\n    type: 'move_node',\n    value,\n    path,\n    newPath: newPath.concat(newIndex),\n  })\n\n  const ancestorPath = PathUtils.relate(path, newPath)\n  change.normalizeNodeByPath(ancestorPath, options)\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n */\n\nChanges.removeMarkByPath = (change, path, offset, length, mark, options) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'remove_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.removeAllMarksByPath = (change, path, options) => {\n  const { state } = change\n  const { document } = state\n  const node = document.assertNode(path)\n  const texts = node.object === 'text' ? [node] : node.getTextsAsArray()\n\n  texts.forEach(text => {\n    text.getMarksAsArray().forEach(mark => {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark, options)\n    })\n  })\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.removeNodeByPath = (change, path, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n\n  change.applyOperation({\n    type: 'remove_node',\n    value,\n    path,\n    node,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n */\n\nChanges.setTextByPath = (change, path, text, marks, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const end = node.text.length\n  change.replaceTextByPath(path, 0, end, text, marks, options)\n}\n\n/**\n * Replace A Length of Text with another string or text\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *\n */\n\nChanges.replaceTextByPath = (\n  change,\n  path,\n  offset,\n  length,\n  text,\n  marks,\n  options\n) => {\n  const { document } = change.value\n  const node = document.assertNode(path)\n\n  if (length + offset > node.text.length) {\n    length = node.text.length - offset\n  }\n\n  const range = Range.create({\n    anchorPath: path,\n    focusPath: path,\n    anchorOffset: offset,\n    focusOffset: offset + length,\n  }).normalize(document)\n\n  let activeMarks = document.getActiveMarksAtRange(range)\n\n  change.removeTextByPath(path, offset, length, { normalize: false })\n\n  if (!marks) {\n    // Do not use mark at index when marks and activeMarks are both empty\n    marks = activeMarks ? activeMarks : []\n  } else if (activeMarks) {\n    // Do not use `has` because we may want to reset marks like font-size with an updated data;\n    activeMarks = activeMarks.filter(\n      activeMark => !marks.find(m => activeMark.type === m.type)\n    )\n\n    marks = activeMarks.merge(marks)\n  }\n\n  change.insertTextByPath(path, offset, text, marks, options)\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n */\n\nChanges.removeTextByPath = (change, path, offset, length, options) => {\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const leaves = node.getLeaves()\n  const { text } = node\n\n  const removals = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n    const string = text.slice(start, end)\n\n    removals.push({\n      type: 'remove_text',\n      value,\n      path,\n      offset: start,\n      text: string,\n      marks: leaf.marks,\n    })\n  })\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse())\n\n  const block = document.getClosestBlock(node.key)\n  change.normalizeNodeByKey(block.key, options)\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|Node} node\n * @param {Object} options\n */\n\nChanges.replaceNodeByPath = (change, path, newNode, options) => {\n  newNode = Node.create(newNode)\n  const index = path.last()\n  const parentPath = PathUtils.lift(path)\n  change.removeNodeByPath(path, { normalize: false })\n  change.insertNodeByPath(parentPath, index, newNode, { normalize: false })\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n */\n\nChanges.setMarkByPath = (\n  change,\n  path,\n  offset,\n  length,\n  mark,\n  properties,\n  options\n) => {\n  mark = Mark.create(mark)\n  properties = Mark.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation({\n    type: 'set_mark',\n    value,\n    path,\n    offset,\n    length,\n    mark,\n    properties,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges.setNodeByPath = (change, path, properties, options) => {\n  properties = Node.createProperties(properties)\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n\n  change.applyOperation({\n    type: 'set_node',\n    value,\n    path,\n    node,\n    properties,\n  })\n\n  change.normalizeNodeByPath(path, options)\n}\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nChanges.splitNodeByPath = (change, path, position, options = {}) => {\n  const { target = null } = options\n  const { value } = change\n  const { document } = value\n  const node = document.getDescendant(path)\n\n  change.applyOperation({\n    type: 'split_node',\n    value,\n    path,\n    position,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n    target,\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n * @param {Object} options\n */\n\nChanges.splitDescendantsByPath = (\n  change,\n  path,\n  textPath,\n  textOffset,\n  options\n) => {\n  if (path.equals(textPath)) {\n    change.splitNodeByPath(textPath, textOffset, options)\n    return\n  }\n\n  const { value } = change\n  const { document } = value\n  const node = document.assertNode(path)\n  const text = document.assertNode(textPath)\n  const ancestors = document.getAncestors(textPath)\n  const nodes = ancestors\n    .skipUntil(a => a.key == node.key)\n    .reverse()\n    .unshift(text)\n\n  let previous\n  let index\n\n  nodes.forEach(n => {\n    const prevIndex = index == null ? null : index\n    index = previous ? n.nodes.indexOf(previous) + 1 : textOffset\n    previous = n\n\n    change.splitNodeByKey(n.key, index, {\n      normalize: false,\n      target: prevIndex,\n    })\n  })\n\n  change.normalizeParentByPath(path, options)\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges.unwrapInlineByPath = (change, path, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapInlineAtRange(range, properties, options)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object|String} properties\n * @param {Object} options\n */\n\nChanges.unwrapBlockByPath = (change, path, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapBlockAtRange(range, properties, options)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Object} options\n */\n\nChanges.unwrapNodeByPath = (change, path, options) => {\n  const { value } = change\n  const { document } = value\n  document.assertNode(path)\n\n  const parentPath = PathUtils.lift(path)\n  const parent = document.assertNode(parentPath)\n  const index = path.last()\n  const parentIndex = parentPath.last()\n  const grandPath = PathUtils.lift(parentPath)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  if (parent.nodes.size === 1) {\n    change.moveNodeByPath(path, grandPath, parentIndex + 1, {\n      normalize: false,\n    })\n\n    change.removeNodeByPath(parentPath, options)\n  } else if (isFirst) {\n    change.moveNodeByPath(path, grandPath, parentIndex, options)\n  } else if (isLast) {\n    change.moveNodeByPath(path, grandPath, parentIndex + 1, options)\n  } else {\n    change.splitNodeByPath(parentPath, index, { normalize: false })\n\n    let updatedPath = PathUtils.increment(path, 1, parentPath.size - 1)\n    updatedPath = updatedPath.set(updatedPath.size - 1, 0)\n\n    change.moveNodeByPath(updatedPath, grandPath, parentIndex + 1, {\n      normalize: false,\n    })\n\n    change.normalizeNodeByPath(grandPath, options)\n  }\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} block\n * @param {Object} options\n */\n\nChanges.wrapBlockByPath = (change, path, block, options) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n  change.insertNodeByPath(parentPath, index, block, { normalize: false })\n  change.moveNodeByPath(newPath, path, 0, options)\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Block|Object|String} inline\n * @param {Object} options\n */\n\nChanges.wrapInlineByPath = (change, path, inline, options) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n  change.insertNodeByPath(parentPath, index, inline, { normalize: false })\n  change.moveNodeByPath(newPath, path, 0, options)\n}\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Change} change\n * @param {Array} path\n * @param {Node|Object} node\n * @param {Object} options\n */\n\nChanges.wrapNodeByPath = (change, path, node) => {\n  node = Node.create(node)\n\n  if (node.object == 'block') {\n    change.wrapBlockByPath(path, node)\n    return\n  }\n\n  if (node.object == 'inline') {\n    change.wrapInlineByPath(path, node)\n    return\n  }\n}\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nconst CHANGES = [\n  'addMark',\n  'insertFragment',\n  'insertNode',\n  'insertText',\n  'mergeNode',\n  'removeMark',\n  'removeAllMarks',\n  'removeNode',\n  'setText',\n  'replaceText',\n  'removeText',\n  'replaceNode',\n  'setMark',\n  'setNode',\n  'splitNode',\n  'unwrapInline',\n  'unwrapBlock',\n  'unwrapNode',\n  'wrapBlock',\n  'wrapInline',\n  'wrapNode',\n]\n\nfor (const method of CHANGES) {\n  Changes[`${method}ByKey`] = (change, key, ...args) => {\n    const { value } = change\n    const { document } = value\n    const path = document.assertPath(key)\n    change[`${method}ByPath`](path, ...args)\n  }\n}\n\n// Moving nodes takes two keys, so it's slightly different.\nChanges.moveNodeByKey = (change, key, newKey, ...args) => {\n  const { value } = change\n  const { document } = value\n  const path = document.assertPath(key)\n  const newPath = document.assertPath(newKey)\n  change.moveNodeByPath(path, newPath, ...args)\n}\n\n// Splitting descendants takes two keys, so it's slightly different.\nChanges.splitDescendantsByKey = (change, key, textKey, ...args) => {\n  const { value } = change\n  const { document } = value\n  const path = document.assertPath(key)\n  const textPath = document.assertPath(textKey)\n  change.splitDescendantsByPath(path, textPath, ...args)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Debug from 'debug'\nimport isEqual from 'lodash/isEqual'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record, Stack } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:history')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  redos: new Stack(),\n  undos: new Stack(),\n}\n\n/**\n * History.\n *\n * @type {History}\n */\n\nclass History extends Record(DEFAULTS) {\n  /**\n   * Create a new `History` with `attrs`.\n   *\n   * @param {Object|History} attrs\n   * @return {History}\n   */\n\n  static create(attrs = {}) {\n    if (History.isHistory(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return History.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`History.create\\` only accepts objects or histories, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `operations`.\n   *\n   * @param {Array<Object>|List<Object>} operations\n   * @return {List<Object>}\n   */\n\n  static createOperationsList(operations = []) {\n    if (List.isList(operations)) {\n      return operations\n    }\n\n    if (Array.isArray(operations)) {\n      return new List(operations)\n    }\n\n    throw new Error(\n      `\\`History.createList\\` only accepts arrays or lists, but you passed it: ${operations}`\n    )\n  }\n\n  /**\n   * Create a `History` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {History}\n   */\n\n  static fromJSON(object) {\n    const { redos = [], undos = [] } = object\n\n    const history = new History({\n      redos: new Stack(redos.map(this.createOperationsList)),\n      undos: new Stack(undos.map(this.createOperationsList)),\n    })\n\n    return history\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = History.fromJSON\n\n  /**\n   * Check if `any` is a `History`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isHistory = isType.bind(null, 'HISTORY')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'history'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Save an `operation` into the history.\n   *\n   * @param {Object} operation\n   * @param {Object} options\n   * @return {History}\n   */\n\n  save(operation, options = {}) {\n    let history = this\n    let { undos, redos } = history\n    let { merge, skip } = options\n    const prevBatch = undos.peek()\n    const prevOperation = prevBatch && prevBatch.last()\n\n    if (skip == null) {\n      skip = shouldSkip(operation, prevOperation)\n    }\n\n    if (skip) {\n      return history\n    }\n\n    if (merge == null) {\n      merge = shouldMerge(operation, prevOperation)\n    }\n\n    debug('save', { operation, merge })\n\n    // If the `merge` flag is true, add the operation to the previous batch.\n    if (merge && prevBatch) {\n      const batch = prevBatch.push(operation)\n      undos = undos.pop()\n      undos = undos.push(batch)\n    } else {\n      // Otherwise, create a new batch with the operation.\n      const batch = new List([operation])\n      undos = undos.push(batch)\n    }\n\n    // Constrain the history to 100 entries for memory's sake.\n    if (undos.size > 100) {\n      undos = undos.take(100)\n    }\n\n    // Clear the redos and update the history.\n    redos = redos.clear()\n    history = history.set('undos', undos).set('redos', redos)\n    return history\n  }\n\n  /**\n   * Return a JSON representation of the history.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      redos: this.redos.toJSON(),\n      undos: this.undos.toJSON(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nHistory.prototype[MODEL_TYPES.HISTORY] = true\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type == 'set_selection' && p.type == 'set_selection') ||\n    (o.type == 'insert_text' &&\n      p.type == 'insert_text' &&\n      o.offset == p.offset + p.text.length &&\n      isEqual(o.path, p.path)) ||\n    (o.type == 'remove_text' &&\n      p.type == 'remove_text' &&\n      o.offset + o.text.length == p.offset &&\n      isEqual(o.path, p.path))\n\n  return merge\n}\n\n/**\n * Check whether to skip a new operation `o`, given previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldSkip(o, p) {\n  if (!p) return false\n\n  const skip = o.type == 'set_selection' && p.type == 'set_selection'\n\n  return skip\n}\n\n/**\n * Export.\n *\n * @type {History}\n */\n\nexport default History\n","import logger from 'slate-dev-logger'\nimport { Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport memoize from '../utils/memoize'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  plugins: [],\n}\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nclass Stack extends Record(DEFAULTS) {\n  /**\n   * Constructor.\n   *\n   * @param {Object} attrs\n   */\n\n  static create(attrs = {}) {\n    const { plugins = [] } = attrs\n    const stack = new Stack({ plugins })\n    return stack\n  }\n\n  /**\n   * Check if `any` is a `Stack`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isStack(any) {\n    return !!(any && any[MODEL_TYPES.STACK])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'stack'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get all plugins with `property`.\n   *\n   * @param {String} property\n   * @return {Array}\n   */\n\n  getPluginsWith(property) {\n    return this.plugins.filter(plugin => plugin[property] != null)\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning the first non-null value.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  find(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return ret\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning all the non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   * @return {Array}\n   */\n\n  map(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n    const array = []\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) array.push(ret)\n    }\n\n    return array\n  }\n\n  /**\n   * Iterate the plugins with `property`, breaking on any a non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  run(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, reducing to a set of React children.\n   *\n   * @param {String} property\n   * @param {Object} props\n   * @param {Any} ...args\n   */\n\n  render(property, props, ...args) {\n    const plugins = this.getPluginsWith(property)\n    return plugins.reduceRight((children, plugin) => {\n      if (!plugin[property]) return children\n      const ret = plugin[property](props, ...args)\n      if (ret == null) return children\n      props.children = ret\n      return ret\n    }, props.children === undefined ? null : props.children)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nStack.prototype[MODEL_TYPES.STACK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Stack.prototype, ['getPluginsWith'])\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexport default Stack\n","/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nclass SlateError extends Error {\n  constructor(code, attrs = {}) {\n    super(code)\n    this.code = code\n\n    for (const key in attrs) {\n      this[key] = attrs[key]\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {SlateError}\n */\n\nexport default SlateError\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { Record } from 'immutable'\nimport {\n  CHILD_OBJECT_INVALID,\n  CHILD_REQUIRED,\n  CHILD_TYPE_INVALID,\n  CHILD_UNKNOWN,\n  FIRST_CHILD_OBJECT_INVALID,\n  FIRST_CHILD_TYPE_INVALID,\n  LAST_CHILD_OBJECT_INVALID,\n  LAST_CHILD_TYPE_INVALID,\n  NODE_DATA_INVALID,\n  NODE_IS_VOID_INVALID,\n  NODE_MARK_INVALID,\n  NODE_OBJECT_INVALID,\n  NODE_TEXT_INVALID,\n  NODE_TYPE_INVALID,\n  PARENT_OBJECT_INVALID,\n  PARENT_TYPE_INVALID,\n} from 'slate-schema-violations'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Stack from './stack'\nimport Text from './text'\nimport SlateError from '../utils/slate-error'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:schema')\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nconst CORE_RULES = [\n  // Only allow block nodes in documents.\n  {\n    match: { object: 'document' },\n    nodes: [\n      {\n        match: { object: 'block' },\n      },\n    ],\n  },\n\n  // Only allow block nodes or inline and text nodes in blocks.\n  {\n    match: {\n      object: 'block',\n      first: { object: 'block' },\n    },\n    nodes: [\n      {\n        match: { object: 'block' },\n      },\n    ],\n  },\n  {\n    match: {\n      object: 'block',\n      first: [{ object: 'inline' }, { object: 'text' }],\n    },\n    nodes: [\n      {\n        match: [{ object: 'inline' }, { object: 'text' }],\n      },\n    ],\n  },\n\n  // Only allow inline and text nodes in inlines.\n  {\n    match: { object: 'inline' },\n    nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }],\n  },\n\n  // Ensure that block and inline nodes have at least one text child.\n  {\n    match: [{ object: 'block' }, { object: 'inline' }],\n    nodes: [{ min: 1 }],\n    normalize: (change, error) => {\n      const { code, node } = error\n      if (code !== 'child_required') return\n      change.insertNodeByKey(node.key, 0, Text.create(), { normalize: false })\n    },\n  },\n\n  // Ensure that inline non-void nodes are never empty.\n  {\n    match: {\n      object: 'inline',\n      isVoid: false,\n      nodes: [{ match: { object: 'text' } }],\n    },\n    text: /[\\w\\W]+/,\n  },\n\n  // Ensure that inline void nodes are surrounded by text nodes.\n  {\n    match: { object: 'block' },\n    first: [{ object: 'block' }, { object: 'text' }],\n    last: [{ object: 'block' }, { object: 'text' }],\n    normalize: (change, error) => {\n      const { code, node } = error\n      const text = Text.create()\n      let i\n\n      if (code === 'first_child_object_invalid') {\n        i = 0\n      } else if (code === 'last_child_object_invalid') {\n        i = node.nodes.size\n      } else {\n        return\n      }\n\n      change.insertNodeByKey(node.key, i, text, { normalize: false })\n    },\n  },\n  {\n    match: { object: 'inline' },\n    first: [{ object: 'block' }, { object: 'text' }],\n    last: [{ object: 'block' }, { object: 'text' }],\n    previous: [{ object: 'block' }, { object: 'text' }],\n    next: [{ object: 'block' }, { object: 'text' }],\n    normalize: (change, error) => {\n      const { code, node, index } = error\n      const text = Text.create()\n      let i\n\n      if (code === 'first_child_object_invalid') {\n        i = 0\n      } else if (code === 'last_child_object_invalid') {\n        i = node.nodes.size\n      } else if (code === 'previous_sibling_object_invalid') {\n        i = index\n      } else if (code === 'next_sibling_object_invalid') {\n        i = index + 1\n      } else {\n        return\n      }\n\n      change.insertNodeByKey(node.key, i, text, { normalize: false })\n    },\n  },\n\n  // Merge adjacent text nodes.\n  {\n    match: { object: 'text' },\n    next: [{ object: 'block' }, { object: 'inline' }],\n    normalize: (change, error) => {\n      const { code, next } = error\n      if (code !== 'next_sibling_object_invalid') return\n      change.mergeNodeByKey(next.key, { normalize: false })\n    },\n  },\n]\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  stack: Stack.create(),\n  rules: [],\n}\n\n/**\n * Schema.\n *\n * @type {Schema}\n */\n\nclass Schema extends Record(DEFAULTS) {\n  /**\n   * Create a new `Schema` with `attrs`.\n   *\n   * @param {Object|Schema} attrs\n   * @return {Schema}\n   */\n\n  static create(attrs = {}) {\n    if (Schema.isSchema(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Schema.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Schema.create\\` only accepts objects or schemas, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Schema` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Schema}\n   */\n\n  static fromJSON(object) {\n    if (Schema.isSchema(object)) {\n      return object\n    }\n\n    const plugins = object.plugins ? object.plugins : [{ schema: object }]\n    let rules = [...CORE_RULES]\n\n    for (const plugin of plugins) {\n      const { schema = {} } = plugin\n      const { blocks = {}, inlines = {} } = schema\n\n      if (schema.rules) {\n        rules = rules.concat(schema.rules)\n      }\n\n      if (schema.document) {\n        rules.push({\n          match: [{ object: 'document' }],\n          ...schema.document,\n        })\n      }\n\n      for (const key in blocks) {\n        rules.push({\n          match: [{ object: 'block', type: key }],\n          ...blocks[key],\n        })\n      }\n\n      for (const key in inlines) {\n        rules.push({\n          match: [{ object: 'inline', type: key }],\n          ...inlines[key],\n        })\n      }\n    }\n\n    const stack = Stack.create({ plugins })\n    const ret = new Schema({ stack, rules })\n    return ret\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Schema.fromJSON\n\n  /**\n   * Check if `any` is a `Schema`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isSchema(any) {\n    return !!(any && any[MODEL_TYPES.SCHEMA])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'schema'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Validate a `node` with the schema, returning an error if it's invalid.\n   *\n   * @param {Node} node\n   * @return {Error|Void}\n   */\n\n  validateNode(node) {\n    const rules = this.rules.filter(r => testRules(node, r.match))\n    const failure = validateRules(node, rules, this.rules, { every: true })\n    if (!failure) return\n    const error = new SlateError(failure.code, failure)\n    return error\n  }\n\n  /**\n   * Test whether a `node` is valid against the schema.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  testNode(node) {\n    const error = this.validateNode(node)\n    return !error\n  }\n\n  /**\n   * Assert that a `node` is valid against the schema.\n   *\n   * @param {Node} node\n   * @throws\n   */\n\n  assertNode(node) {\n    const error = this.validateNode(node)\n    if (error) throw error\n  }\n\n  /**\n   * Normalize a `node` with the schema, returning a function that will fix the\n   * invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @return {Function|Void}\n   */\n\n  normalizeNode(node) {\n    const ret = this.stack.find('normalizeNode', node)\n    if (ret) return ret\n    if (node.object == 'text') return\n\n    const error = this.validateNode(node)\n    if (!error) return\n\n    return change => {\n      debug(`normalizing`, { error })\n      const { rule } = error\n      const { size } = change.operations\n\n      // First run the user-provided `normalize` function if one exists...\n      if (rule.normalize) {\n        rule.normalize(change, error)\n      }\n\n      // If the `normalize` function did not add any operations to the change\n      // object, it can't have normalized, so run the default one.\n      if (change.operations.size === size) {\n        defaultNormalize(change, error)\n      }\n    }\n  }\n\n  /**\n   * Return a JSON representation of the schema.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      rules: this.rules,\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS() {\n    return this.toJSON()\n  }\n}\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Change} change\n * @param {SlateError} error\n */\n\nfunction defaultNormalize(change, error) {\n  switch (error.code) {\n    case CHILD_OBJECT_INVALID:\n    case CHILD_TYPE_INVALID:\n    case CHILD_UNKNOWN:\n    case FIRST_CHILD_OBJECT_INVALID:\n    case FIRST_CHILD_TYPE_INVALID:\n    case LAST_CHILD_OBJECT_INVALID:\n    case LAST_CHILD_TYPE_INVALID: {\n      const { child, node } = error\n      return child.object == 'text' &&\n        node.object == 'block' &&\n        node.nodes.size == 1\n        ? change.removeNodeByKey(node.key)\n        : change.removeNodeByKey(child.key)\n    }\n\n    case CHILD_REQUIRED:\n    case NODE_TEXT_INVALID:\n    case PARENT_OBJECT_INVALID:\n    case PARENT_TYPE_INVALID: {\n      const { node } = error\n      return node.object == 'document'\n        ? node.nodes.forEach(child => change.removeNodeByKey(child.key))\n        : change.removeNodeByKey(node.key)\n    }\n\n    case NODE_DATA_INVALID: {\n      const { node, key } = error\n      return node.data.get(key) === undefined && node.object != 'document'\n        ? change.removeNodeByKey(node.key)\n        : change.setNodeByKey(node.key, { data: node.data.delete(key) })\n    }\n\n    case NODE_IS_VOID_INVALID: {\n      const { node } = error\n      return change.setNodeByKey(node.key, { isVoid: !node.isVoid })\n    }\n\n    case NODE_MARK_INVALID: {\n      const { node, mark } = error\n      return node\n        .getTexts()\n        .forEach(t => change.removeMarkByKey(t.key, 0, t.text.length, mark))\n    }\n\n    default: {\n      const { node } = error\n      return change.removeNodeByKey(node.key)\n    }\n  }\n}\n\n/**\n * Check that a `node` matches one of a set of `rules`.\n *\n * @param {Node} node\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(node, rules) {\n  const error = validateRules(node, rules)\n  return !error\n}\n\n/**\n * Validate that a `node` matches a `rule` object or array.\n *\n * @param {Node} node\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(node, rule, rules, options = {}) {\n  const { every = false } = options\n\n  if (Array.isArray(rule)) {\n    const array = rule.length ? rule : [{}]\n    let first\n\n    for (const r of array) {\n      const error = validateRules(node, r, rules)\n      first = first || error\n      if (every && error) return error\n      if (!every && !error) return\n    }\n\n    return first\n  }\n\n  const error =\n    validateObject(node, rule) ||\n    validateType(node, rule) ||\n    validateIsVoid(node, rule) ||\n    validateData(node, rule) ||\n    validateMarks(node, rule) ||\n    validateText(node, rule) ||\n    validateFirst(node, rule) ||\n    validateLast(node, rule) ||\n    validateNodes(node, rule, rules)\n\n  return error\n}\n\nfunction validateObject(node, rule) {\n  if (rule.objects) {\n    logger.warn(\n      'The `objects` schema validation rule was changed. Please use the new `match` syntax with `object`.'\n    )\n  }\n\n  if (rule.object == null) return\n  if (rule.object === node.object) return\n  return fail(NODE_OBJECT_INVALID, { rule, node })\n}\n\nfunction validateType(node, rule) {\n  if (rule.types) {\n    logger.warn(\n      'The `types` schema validation rule was changed. Please use the new `match` syntax with `type`.'\n    )\n  }\n\n  if (rule.type == null) return\n  if (rule.type === node.type) return\n  return fail(NODE_TYPE_INVALID, { rule, node })\n}\n\nfunction validateIsVoid(node, rule) {\n  if (rule.isVoid == null) return\n  if (rule.isVoid === node.isVoid) return\n  return fail(NODE_IS_VOID_INVALID, { rule, node })\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return\n  if (node.data == null) return\n\n  for (const key in rule.data) {\n    const fn = rule.data[key]\n    const value = node.data && node.data.get(key)\n    const valid = typeof fn === 'function' ? fn(value) : fn === value\n    if (valid) continue\n    return fail(NODE_DATA_INVALID, { rule, node, key, value })\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return\n  const marks = node.getMarks().toArray()\n\n  for (const mark of marks) {\n    const valid = rule.marks.some(def => def.type === mark.type)\n    if (valid) continue\n    return fail(NODE_MARK_INVALID, { rule, node, mark })\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return\n  const { text } = node\n  const valid = rule.text.test(text)\n  if (valid) return\n  return fail(NODE_TEXT_INVALID, { rule, node, text })\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return\n  const first = node.nodes.first()\n  if (!first) return\n  const error = validateRules(first, rule.first)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = first\n  error.code = error.code.replace('node_', 'first_child_')\n  return error\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return\n  const last = node.nodes.last()\n  if (!last) return\n  const error = validateRules(last, rule.last)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = last\n  error.code = error.code.replace('node_', 'last_child_')\n  return error\n}\n\nfunction validateNodes(node, rule, rules = []) {\n  if (node.nodes == null) return\n\n  const children = node.nodes.toArray()\n  const defs = rule.nodes != null ? rule.nodes.slice() : []\n  let offset\n  let min\n  let index\n  let def\n  let max\n  let child\n  let previous\n  let next\n\n  function nextDef() {\n    offset = offset == null ? null : 0\n    def = defs.shift()\n    min = def && def.min\n    max = def && def.max\n    return !!def\n  }\n\n  function nextChild() {\n    index = index == null ? 0 : index + 1\n    offset = offset == null ? 0 : offset + 1\n    previous = child\n    child = children[index]\n    next = children[index + 1]\n    if (max != null && offset == max) nextDef()\n    return !!child\n  }\n\n  function rewind() {\n    offset -= 1\n    index -= 1\n  }\n\n  if (rule.nodes != null) {\n    nextDef()\n  }\n\n  while (nextChild()) {\n    const err =\n      validateParent(node, child, rules) ||\n      validatePrevious(node, child, previous, index, rules) ||\n      validateNext(node, child, next, index, rules)\n\n    if (err) return err\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail(CHILD_UNKNOWN, { rule, node, child, index })\n      }\n\n      if (def) {\n        if (def.objects) {\n          logger.warn(\n            'The `objects` schema validation rule was changed. Please use the new `match` syntax with `object`.'\n          )\n        }\n\n        if (def.types) {\n          logger.warn(\n            'The `types` schema validation rule was changed. Please use the new `match` syntax with `type`.'\n          )\n        }\n      }\n\n      if (def.match) {\n        const error = validateRules(child, def.match)\n\n        if (error && offset >= min && nextDef()) {\n          rewind()\n          continue\n        }\n\n        if (error) {\n          error.rule = rule\n          error.node = node\n          error.child = child\n          error.index = index\n          error.code = error.code.replace('node_', 'child_')\n          return error\n        }\n      }\n    }\n  }\n\n  if (rule.nodes != null) {\n    while (min != null) {\n      if (offset < min) {\n        return fail(CHILD_REQUIRED, { rule, node, index })\n      }\n\n      nextDef()\n    }\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  for (const rule of rules) {\n    if (rule.parent == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(node, rule.parent)\n    if (!error) continue\n\n    error.rule = rule\n    error.parent = node\n    error.node = child\n    error.code = error.code.replace('node_', 'parent_')\n    return error\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return\n\n  for (const rule of rules) {\n    if (rule.previous == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(previous, rule.previous)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.previous = previous\n    error.code = error.code.replace('node_', 'previous_sibling_')\n    return error\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return\n\n  for (const rule of rules) {\n    if (rule.next == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(next, rule.next)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.next = next\n    error.code = error.code.replace('node_', 'next_sibling_')\n    return error\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return { code, ...attrs }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSchema.prototype[MODEL_TYPES.SCHEMA] = true\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexport default Schema\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { Record, Set, List, Map } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport PathUtils from '../utils/path-utils'\nimport Change from './change'\nimport Data from './data'\nimport Document from './document'\nimport History from './history'\nimport Range from './range'\nimport Schema from './schema'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  decorations: null,\n  document: Document.create(),\n  history: History.create(),\n  schema: Schema.create(),\n  selection: Range.create(),\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Value.isValue(a)) {\n      return {\n        data: a.data,\n        decorations: a.decorations,\n        schema: a.schema,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('decorations' in a) p.decorations = Range.createList(a.decorations)\n      if ('schema' in a) p.schema = Schema.create(a.schema)\n      return p\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let { document = {}, selection = {}, schema = {}, history = {} } = object\n    let data = new Map()\n    document = Document.fromJSON(document)\n    selection = Range.fromJSON(selection)\n    schema = Schema.fromJSON(schema)\n    history = History.fromJSON(history)\n\n    // Allow plugins to set a default value for `data`.\n    if (options.plugins) {\n      for (const plugin of options.plugins) {\n        if (plugin.data) data = data.merge(plugin.data)\n      }\n    }\n\n    // Then merge in the `data` provided.\n    if ('data' in object) {\n      data = data.merge(object.data)\n    }\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.collapseToStartOf(text)\n    }\n\n    selection = selection.normalize(document)\n\n    let value = new Value({\n      data,\n      document,\n      selection,\n      schema,\n      history,\n    })\n\n    if (options.normalize !== false) {\n      value = value.change({ save: false }).normalize().value\n    }\n\n    return value\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Value.fromJSON\n\n  /**\n   * Check if a `value` is a `Value`.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isValue(value) {\n    return !!(value && value[MODEL_TYPES.VALUE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'value'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Are there undoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasUndos() {\n    return this.history.undos.size > 0\n  }\n\n  /**\n   * Are there redoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasRedos() {\n    return this.history.redos.size > 0\n  }\n\n  /**\n   * Is the current selection blurred?\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return this.selection.isBlurred\n  }\n\n  /**\n   * Is the current selection focused?\n   *\n   * @return {Boolean}\n   */\n\n  get isFocused() {\n    return this.selection.isFocused\n  }\n\n  /**\n   * Is the current selection collapsed?\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return this.selection.isCollapsed\n  }\n\n  /**\n   * Is the current selection expanded?\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return this.selection.isExpanded\n  }\n\n  /**\n   * Is the current selection backward?\n   *\n   * @return {Boolean} isBackward\n   */\n\n  get isBackward() {\n    return this.selection.isBackward\n  }\n\n  /**\n   * Is the current selection forward?\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.selection.isForward\n  }\n\n  /**\n   * Get the current start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.selection.startKey\n  }\n\n  /**\n   * Get the current end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.selection.endKey\n  }\n\n  /**\n   * Get the current start path.\n   *\n   * @return {String}\n   */\n\n  get startPath() {\n    return this.selection.startPath\n  }\n\n  /**\n   * Get the current end path.\n   *\n   * @return {String}\n   */\n\n  get endPath() {\n    return this.selection.endPath\n  }\n\n  /**\n   * Get the current start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.selection.startOffset\n  }\n\n  /**\n   * Get the current end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.selection.endOffset\n  }\n\n  /**\n   * Get the current anchor key.\n   *\n   * @return {String}\n   */\n\n  get anchorKey() {\n    return this.selection.anchorKey\n  }\n\n  /**\n   * Get the current focus key.\n   *\n   * @return {String}\n   */\n\n  get focusKey() {\n    return this.selection.focusKey\n  }\n\n  /**\n   * Get the current anchor path.\n   *\n   * @return {String}\n   */\n\n  get anchorPath() {\n    return this.selection.anchorPath\n  }\n\n  /**\n   * Get the current focus path.\n   *\n   * @return {String}\n   */\n\n  get focusPath() {\n    return this.selection.focusPath\n  }\n\n  /**\n   * Get the current anchor offset.\n   *\n   * @return {String}\n   */\n\n  get anchorOffset() {\n    return this.selection.anchorOffset\n  }\n\n  /**\n   * Get the current focus offset.\n   *\n   * @return {String}\n   */\n\n  get focusOffset() {\n    return this.selection.focusOffset\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return this.startKey && this.document.getClosestBlock(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return this.endKey && this.document.getClosestBlock(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return this.anchorKey && this.document.getClosestBlock(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return this.focusKey && this.document.getClosestBlock(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return this.startKey && this.document.getClosestInline(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return this.endKey && this.document.getClosestInline(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return this.anchorKey && this.document.getClosestInline(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return this.focusKey && this.document.getClosestInline(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return this.startKey && this.document.getDescendant(this.startKey)\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return this.endKey && this.document.getDescendant(this.endKey)\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return this.anchorKey && this.document.getDescendant(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return this.focusKey && this.document.getDescendant(this.focusKey)\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return this.endKey && this.document.getNextBlock(this.endKey)\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return this.startKey && this.document.getPreviousBlock(this.startKey)\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return this.endKey && this.document.getNextInline(this.endKey)\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return this.startKey && this.document.getPreviousInline(this.startKey)\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return this.endKey && this.document.getNextText(this.endKey)\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return this.startKey && this.document.getPreviousText(this.startKey)\n  }\n\n  /**\n   * Get the characters in the current selection.\n   *\n   * @return {List<Character>}\n   */\n\n  get characters() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getCharactersAtRange(this.selection)\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Check whether the selection is empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    if (this.isCollapsed) return true\n    if (this.endOffset != 0 && this.startOffset != 0) return false\n    return this.fragment.isEmpty\n  }\n\n  /**\n   * Check whether the selection is collapsed in a void node.\n   *\n   * @return {Boolean}\n   */\n\n  get isInVoid() {\n    if (this.isExpanded) return false\n    return this.document.hasVoidParent(this.startKey)\n  }\n\n  /**\n   * Create a new `Change` with the current value as a starting point.\n   *\n   * @param {Object} attrs\n   * @return {Change}\n   */\n\n  change(attrs = {}) {\n    return new Change({ ...attrs, value: this })\n  }\n\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addMark(path, offset, length, mark) {\n    let value = this\n    let { document } = value\n    document = document.addMark(path, offset, length, mark)\n    value = this.set('document', document)\n    return value\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Value}\n   */\n\n  insertNode(path, node) {\n    let value = this\n    let { document } = value\n    document = document.insertNode(path, node)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      return range.merge({ anchorPath: null, focusPath: null })\n    })\n\n    return value\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @param {Set} marks\n   * @return {Value}\n   */\n\n  insertText(path, offset, text, marks) {\n    let value = this\n    let { document } = value\n    document = document.insertText(path, offset, text, marks)\n    value = value.set('document', document)\n\n    // Update any ranges that were affected.\n    const node = document.assertNode(path)\n    value = value.clearAtomicRanges(node.key, offset)\n\n    value = value.mapRanges(range => {\n      const { anchorKey, anchorOffset, isBackward, isAtomic } = range\n\n      if (\n        anchorKey === node.key &&\n        (anchorOffset > offset ||\n          (anchorOffset === offset && (!isAtomic || !isBackward)))\n      ) {\n        return range.moveAnchor(text.length)\n      }\n\n      return range\n    })\n\n    value = value.mapRanges(range => {\n      const { focusKey, focusOffset, isBackward, isAtomic } = range\n\n      if (\n        focusKey === node.key &&\n        (focusOffset > offset ||\n          (focusOffset == offset && (!isAtomic || isBackward)))\n      ) {\n        return range.moveFocus(text.length)\n      }\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Value}\n   */\n\n  mergeNode(path) {\n    let value = this\n    const { document } = value\n    const newDocument = document.mergeNode(path)\n    path = document.resolvePath(path)\n    const withPath = PathUtils.decrement(path)\n    const one = document.getNode(withPath)\n    const two = document.getNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      if (two.object === 'text') {\n        const max = one.text.length\n\n        if (range.anchorKey === two.key) {\n          range = range.moveAnchorTo(one.key, max + range.anchorOffset)\n        }\n\n        if (range.focusKey === two.key) {\n          range = range.moveFocusTo(one.key, max + range.focusOffset)\n        }\n      }\n\n      range = range.merge({ anchorPath: null, focusPath: null })\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Value}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    let value = this\n    let { document } = value\n    document = document.moveNode(path, newPath, newIndex)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      return range.merge({ anchorPath: null, focusPath: null })\n    })\n\n    return value\n  }\n\n  /**\n   * Remove mark from text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeMark(path, offset, length, mark) {\n    let value = this\n    let { document } = value\n    document = document.removeMark(path, offset, length, mark)\n    value = this.set('document', document)\n    return value\n  }\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Value}\n   */\n\n  removeNode(path) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    const first = node.object == 'text' ? node : node.getFirstText() || node\n    const last = node.object == 'text' ? node : node.getLastText() || node\n    const prev = document.getPreviousText(first.key)\n    const next = document.getNextText(last.key)\n\n    document = document.removeNode(path)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      const { startKey, endKey } = range\n\n      if (node.hasNode(startKey)) {\n        range = prev\n          ? range.moveStartTo(prev.key, prev.text.length)\n          : next ? range.moveStartTo(next.key, 0) : range.deselect()\n      }\n\n      if (node.hasNode(endKey)) {\n        range = prev\n          ? range.moveEndTo(prev.key, prev.text.length)\n          : next ? range.moveEndTo(next.key, 0) : range.deselect()\n      }\n\n      range = range.merge({ anchorPath: null, focusPath: null })\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  removeText(path, offset, text) {\n    let value = this\n    let { document } = value\n    document = document.removeText(path, offset, text)\n    value = value.set('document', document)\n\n    const node = document.assertNode(path)\n    const { length } = text\n    const rangeOffset = offset + length\n    value = value.clearAtomicRanges(node.key, offset, offset + length)\n\n    value = value.mapRanges(range => {\n      const { anchorKey } = range\n\n      if (anchorKey === node.key) {\n        return range.anchorOffset >= rangeOffset\n          ? range.moveAnchor(-length)\n          : range.anchorOffset > offset\n            ? range.moveAnchorTo(range.anchorKey, offset)\n            : range\n      }\n\n      return range\n    })\n\n    value = value.mapRanges(range => {\n      const { focusKey } = range\n\n      if (focusKey === node.key) {\n        return range.focusOffset >= rangeOffset\n          ? range.moveFocus(-length)\n          : range.focusOffset > offset\n            ? range.moveFocusTo(range.focusKey, offset)\n            : range\n      }\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setNode(path, properties) {\n    let value = this\n    let { document } = value\n    document = document.setNode(path, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setMark(path, offset, length, mark, properties) {\n    let value = this\n    let { document } = value\n    document = document.setMark(path, offset, length, mark, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  setSelection(properties) {\n    let value = this\n    let { document, selection } = value\n    selection = selection.merge(properties)\n    selection = selection.normalize(document)\n    value = value.set('selection', selection)\n    return value\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  splitNode(path, position, properties) {\n    let value = this\n    const { document } = value\n    const newDocument = document.splitNode(path, position, properties)\n    const node = document.assertNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      const next = newDocument.getNextText(node.key)\n      const { startKey, startOffset, endKey, endOffset } = range\n\n      // If the start was after the split, move it to the next node.\n      if (node.key === startKey && position <= startOffset) {\n        range = range.moveStartTo(next.key, startOffset - position)\n      }\n\n      // If the end was after the split, move it to the next node.\n      if (node.key === endKey && position <= endOffset) {\n        range = range.moveEndTo(next.key, endOffset - position)\n      }\n\n      range = range.merge({ anchorPath: null, focusPath: null })\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Map all range objects to apply adjustments with an `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Value}\n   */\n\n  mapRanges(iterator) {\n    let value = this\n    const { document, selection, decorations } = value\n\n    if (selection) {\n      let next = selection.isSet ? iterator(selection) : selection\n      if (!next) next = selection.deselect()\n      if (next !== selection) next = next.normalize(document)\n      value = value.set('selection', next)\n    }\n\n    if (decorations) {\n      let next = decorations.map(decoration => {\n        let n = decoration.isSet ? iterator(decoration) : decoration\n        if (n && n !== decoration) n = n.normalize(document)\n        return n\n      })\n\n      next = next.filter(decoration => !!decoration)\n      next = next.size ? next : null\n      value = value.set('decorations', next)\n    }\n\n    return value\n  }\n\n  /**\n   * Remove any atomic ranges inside a `key`, `offset` and `length`.\n   *\n   * @param {String} key\n   * @param {Number} start\n   * @param {Number?} end\n   * @return {Value}\n   */\n\n  clearAtomicRanges(key, start, end = null) {\n    return this.mapRanges(range => {\n      const { isAtomic, startKey, startOffset, endKey, endOffset } = range\n      if (!isAtomic) return range\n      if (startKey !== key) return range\n\n      if (startOffset < start && (endKey !== key || endOffset > start)) {\n        return null\n      }\n\n      if (\n        end != null &&\n        startOffset < end &&\n        (endKey !== key || endOffset > end)\n      ) {\n        return null\n      }\n\n      return range\n    })\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON(options)\n    }\n\n    if (options.preserveDecorations) {\n      object.decorations = this.decorations\n        ? this.decorations.toArray().map(d => d.toJSON(options))\n        : null\n    }\n\n    if (options.preserveHistory) {\n      object.history = this.history.toJSON(options)\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON(options)\n    }\n\n    if (options.preserveSchema) {\n      object.schema = this.schema.toJSON(options)\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nValue.prototype[MODEL_TYPES.VALUE] = true\n\n/**\n * Export.\n */\n\nexport default Value\n","import isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport { List, Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Mark from './mark'\nimport Node from './node'\nimport PathUtils from '../utils/path-utils'\nimport Range from './range'\nimport Value from './value'\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target'],\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      if (v === undefined) {\n        // Skip keys for objects that should not be serialized, and are only used\n        // for providing the local-only invert behavior for the history stack.\n        if (key == 'document') continue\n        if (key == 'selection') continue\n        if (key == 'value') continue\n        if (key == 'node' && type != 'insert_node') continue\n\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key === 'path' || key === 'newPath') {\n        v = PathUtils.create(v)\n      }\n\n      if (key === 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key === 'marks' && v != null) {\n        v = Mark.createSet(v)\n      }\n\n      if (key === 'node') {\n        v = Node.create(v)\n      }\n\n      if (key === 'selection') {\n        v = Range.create(v)\n      }\n\n      if (key === 'value') {\n        v = Value.create(v)\n      }\n\n      if (key === 'properties' && type === 'merge_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_mark') {\n        v = Mark.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_selection') {\n        v = Range.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'set_value') {\n        v = Value.createProperties(v)\n      }\n\n      if (key === 'properties' && type === 'split_node') {\n        v = Node.createProperties(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const node = new Operation(attrs)\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Operation.fromJSON\n\n  /**\n   * Check if `any` is a `Operation`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperation(any) {\n    return !!(any && any[MODEL_TYPES.OPERATION])\n  }\n\n  /**\n   * Check if `any` is a list of operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'operation'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      // Skip keys for objects that should not be serialized, and are only used\n      // for providing the local-only invert behavior for the history stack.\n      if (key == 'document') continue\n      if (key == 'selection') continue\n      if (key == 'value') continue\n      if (key == 'node' && type != 'insert_node') continue\n\n      if (key == 'mark' || key == 'marks' || key == 'node') {\n        value = value.toJSON()\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('isVoid' in value) v.isVoid = value.isVoid\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const v = {}\n        if ('anchorOffset' in value) v.anchorOffset = value.anchorOffset\n        if ('anchorPath' in value)\n          v.anchorPath = value.anchorPath && value.anchorPath.toJSON()\n        if ('focusOffset' in value) v.focusOffset = value.focusOffset\n        if ('focusPath' in value)\n          v.focusPath = value.focusPath && value.focusPath.toJSON()\n        if ('isBackward' in value) v.isBackward = value.isBackward\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value) v.marks = value.marks && value.marks.toJSON()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('decorations' in value) v.decorations = value.decorations.toJS()\n        if ('schema' in value) v.schema = value.schema.toJS()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(options) {\n    return this.toJSON(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nOperation.prototype[MODEL_TYPES.OPERATION] = true\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import Debug from 'debug'\nimport pick from 'lodash/pick'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'insert_node': {\n      const inverse = op.set('type', 'remove_node')\n      return inverse\n    }\n\n    case 'remove_node': {\n      const inverse = op.set('type', 'insert_node')\n      return inverse\n    }\n\n    case 'move_node': {\n      const { newPath, path } = op\n      let inversePath = newPath\n      let inverseNewPath = path\n\n      const pathLast = path.size - 1\n      const newPathLast = newPath.size - 1\n\n      // If the node's old position was a left sibling of an ancestor of\n      // its new position, we need to adjust part of the path by -1.\n      if (\n        path.size < inversePath.size &&\n        path.slice(0, pathLast).every((e, i) => e == inversePath.get(i)) &&\n        path.last() < inversePath.get(pathLast)\n      ) {\n        inversePath = inversePath\n          .slice(0, pathLast)\n          .concat(inversePath.get(pathLast) - 1)\n          .concat(inversePath.slice(pathLast + 1, inversePath.size))\n      }\n\n      // If the node's new position is an ancestor of the old position,\n      // or a left sibling of an ancestor of its old position, we need\n      // to adjust part of the path by 1.\n      if (\n        newPath.size < inverseNewPath.size &&\n        newPath\n          .slice(0, newPathLast)\n          .every((e, i) => e == inverseNewPath.get(i)) &&\n        newPath.last() <= inverseNewPath.get(newPathLast)\n      ) {\n        inverseNewPath = inverseNewPath\n          .slice(0, newPathLast)\n          .concat(inverseNewPath.get(newPathLast) + 1)\n          .concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.size))\n      }\n\n      const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n      return inverse\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const inversePath = PathUtils.decrement(path)\n      const inverse = op.set('type', 'split_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const inversePath = PathUtils.increment(path)\n      const inverse = op.set('type', 'merge_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'set_node': {\n      const { properties, node } = op\n      const inverseNode = node.merge(properties)\n      const inverseProperties = pick(node, Object.keys(properties))\n      const inverse = op\n        .set('node', inverseNode)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    case 'insert_text': {\n      const inverse = op.set('type', 'remove_text')\n      return inverse\n    }\n\n    case 'remove_text': {\n      const inverse = op.set('type', 'insert_text')\n      return inverse\n    }\n\n    case 'add_mark': {\n      const inverse = op.set('type', 'remove_mark')\n      return inverse\n    }\n\n    case 'remove_mark': {\n      const inverse = op.set('type', 'add_mark')\n      return inverse\n    }\n\n    case 'set_mark': {\n      const { properties, mark } = op\n      const inverseMark = mark.merge(properties)\n      const inverseProperties = pick(mark, Object.keys(properties))\n      const inverse = op\n        .set('mark', inverseMark)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    case 'set_selection': {\n      const { properties, selection } = op\n      const inverseSelection = selection.merge(properties)\n      const inverseProps = pick(selection, Object.keys(properties))\n      const inverse = op\n        .set('selection', inverseSelection)\n        .set('properties', inverseProps)\n      return inverse\n    }\n\n    case 'set_value': {\n      const { properties, value } = op\n      const inverseValue = value.merge(properties)\n      const inverseProperties = pick(value, Object.keys(properties))\n      const inverse = op\n        .set('value', inverseValue)\n        .set('properties', inverseProperties)\n      return inverse\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import invert from '../operations/invert'\nimport omit from 'lodash/omit'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nChanges.redo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const next = redos.peek()\n  if (!next) return\n\n  // Shift the next value into the undo stack.\n  redos = redos.pop()\n  undos = undos.push(next)\n\n  // Replay the next operations.\n  next.forEach(op => {\n    const { type, properties } = op\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during redoing.\n    if (type == 'set_selection') {\n      op = op.set('properties', omit(properties, 'isFocused'))\n    }\n\n    change.applyOperation(op, { save: false })\n  })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nChanges.undo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const previous = undos.peek()\n  if (!previous) return\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop()\n  redos = redos.push(previous)\n\n  // Replay the inverse of the previous operations.\n  previous\n    .slice()\n    .reverse()\n    .map(invert)\n    .forEach(inverse => {\n      const { type, properties } = inverse\n\n      // When the operation mutates the selection, omit its `isFocused` value to\n      // prevent the editor focus from changing during undoing.\n      if (type == 'set_selection') {\n        inverse = inverse.set('properties', omit(properties, 'isFocused'))\n      }\n\n      change.applyOperation(inverse, { save: false })\n    })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import { is } from 'immutable'\nimport isEmpty from 'is-empty'\nimport pick from 'lodash/pick'\n\nimport Range from '../models/range'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Change} change\n * @param {Object} properties\n */\n\nChanges.select = (change, properties, options = {}) => {\n  properties = Range.createProperties(properties)\n  const { snapshot = false } = options\n  const { value } = change\n  const { document, selection } = value\n  const props = {}\n  const next = selection.merge(properties).normalize(document)\n\n  // Re-compute the properties, to ensure that we get their normalized values.\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      props[k] = properties[k]\n    }\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  if (\n    selection.marks &&\n    !props.marks &&\n    (props.hasOwnProperty('anchorKey') ||\n      props.hasOwnProperty('anchorOffset') ||\n      props.hasOwnProperty('focusKey') ||\n      props.hasOwnProperty('focusOffset'))\n  ) {\n    props.marks = null\n  }\n\n  // If there are no new properties to set, abort to avoid extra operations.\n  if (isEmpty(props)) {\n    return\n  }\n\n  change.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: props,\n      selection: selection.toJSON(),\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\n/**\n * Select the whole document.\n *\n * @param {Change} change\n */\n\nChanges.selectAll = change => {\n  const { value } = change\n  const { document, selection } = value\n  const next = selection.moveToRangeOf(document)\n  change.select(next)\n}\n\n/**\n * Snapshot the current selection.\n *\n * @param {Change} change\n */\n\nChanges.snapshotSelection = change => {\n  const { value } = change\n  const { selection } = value\n  change.select(selection, { snapshot: true })\n}\n\n/**\n * Move the anchor point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharBackward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const previousText = document.getPreviousText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && anchorOffset > 0) {\n    change.moveAnchor(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveAnchorToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && anchorBlock.hasNode(previousText.key)) {\n    change.moveAnchor(-1)\n  }\n}\n\n/**\n * Move the anchor point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharForward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const nextText = document.getNextText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && anchorOffset < anchorText.text.length) {\n    change.moveAnchor(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveAnchorToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && anchorBlock.hasNode(nextText.key)) {\n    change.moveAnchor(1)\n  }\n}\n\n/**\n * Move the focus point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharBackward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const previousText = document.getPreviousText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && focusOffset > 0) {\n    change.moveFocus(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveFocusToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && focusBlock.hasNode(previousText.key)) {\n    change.moveFocus(-1)\n  }\n}\n\n/**\n * Move the focus point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharForward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const nextText = document.getNextText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && focusOffset < focusText.text.length) {\n    change.moveFocus(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveFocusToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && focusBlock.hasNode(nextText.key)) {\n    change.moveFocus(1)\n  }\n}\n\n/**\n * Mix in move methods.\n */\n\nconst MOVE_DIRECTIONS = ['Forward', 'Backward']\n\nMOVE_DIRECTIONS.forEach(direction => {\n  const anchor = `moveAnchorChar${direction}`\n  const focus = `moveFocusChar${direction}`\n\n  Changes[`moveChar${direction}`] = change => {\n    change[anchor]()[focus]()\n  }\n\n  Changes[`moveStartChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[focus]()\n    } else {\n      change[anchor]()\n    }\n  }\n\n  Changes[`moveEndChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[anchor]()\n    } else {\n      change[focus]()\n    }\n  }\n\n  Changes[`extendChar${direction}`] = change => {\n    change[`moveFocusChar${direction}`]()\n  }\n\n  Changes[`collapseChar${direction}`] = change => {\n    const collapse =\n      direction == 'Forward' ? 'collapseToEnd' : 'collapseToStart'\n    change[collapse]()[`moveChar${direction}`]()\n  }\n})\n\n/**\n * Mix in alias methods.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseLineBackward', 'collapseToStartOfBlock'],\n  ['collapseLineForward', 'collapseToEndOfBlock'],\n  ['extendLineBackward', 'extendToStartOfBlock'],\n  ['extendLineForward', 'extendToEndOfBlock'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Changes[alias] = function(change, ...args) {\n    change[method](change, ...args)\n  }\n})\n\n/**\n * Mix in selection changes that are just a proxy for the selection method.\n */\n\nconst PROXY_TRANSFORMS = [\n  'blur',\n  'collapseTo',\n  'collapseToAnchor',\n  'collapseToEnd',\n  'collapseToEndOf',\n  'collapseToFocus',\n  'collapseToStart',\n  'collapseToStartOf',\n  'extend',\n  'extendTo',\n  'extendToEndOf',\n  'extendToStartOf',\n  'flip',\n  'focus',\n  'move',\n  'moveAnchor',\n  'moveAnchorOffsetTo',\n  'moveAnchorTo',\n  'moveAnchorToEndOf',\n  'moveAnchorToStartOf',\n  'moveEnd',\n  'moveEndOffsetTo',\n  'moveEndTo',\n  'moveFocus',\n  'moveFocusOffsetTo',\n  'moveFocusTo',\n  'moveFocusToEndOf',\n  'moveFocusToStartOf',\n  'moveOffsetsTo',\n  'moveStart',\n  'moveStartOffsetTo',\n  'moveStartTo',\n  'moveTo',\n  'moveToEnd',\n  'moveToEndOf',\n  'moveToRangeOf',\n  'moveToStart',\n  'moveToStartOf',\n  'deselect',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const normalize = method != 'deselect'\n    const { value } = change\n    const { document, selection } = value\n    let next = selection[method](...args)\n    if (normalize) next = next.normalize(document)\n    change.select(next)\n  }\n})\n\n/**\n * Mix in node-related changes.\n */\n\nconst PREFIXES = [\n  'moveTo',\n  'moveAnchorTo',\n  'moveFocusTo',\n  'moveStartTo',\n  'moveEndTo',\n  'collapseTo',\n  'extendTo',\n]\n\nconst DIRECTIONS = ['Next', 'Previous']\n\nconst OBJECTS = ['Block', 'Inline', 'Text']\n\nPREFIXES.forEach(prefix => {\n  const edges = ['Start', 'End']\n\n  if (prefix == 'moveTo') {\n    edges.push('Range')\n  }\n\n  edges.forEach(edge => {\n    const method = `${prefix}${edge}Of`\n\n    OBJECTS.forEach(object => {\n      const getNode = object == 'Text' ? 'getNode' : `getClosest${object}`\n\n      Changes[`${method}${object}`] = change => {\n        const { value } = change\n        const { document, selection } = value\n        const node = document[getNode](selection.startKey)\n        if (!node) return\n        change[method](node)\n      }\n\n      DIRECTIONS.forEach(direction => {\n        const getDirectionNode = `get${direction}${object}`\n        const directionKey = direction == 'Next' ? 'startKey' : 'endKey'\n\n        Changes[`${method}${direction}${object}`] = change => {\n          const { value } = change\n          const { document, selection } = value\n          const node = document[getNode](selection[directionKey])\n          if (!node) return\n          const target = document[getDirectionNode](node.key)\n          if (!target) return\n          change[method](target)\n        }\n      })\n    })\n  })\n})\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Value from '../models/value'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n * @param {Object} options\n */\n\nChanges.setValue = (change, properties, options = {}) => {\n  properties = Value.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation(\n    {\n      type: 'set_value',\n      properties,\n      value,\n    },\n    options\n  )\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import PathUtils from '../utils/path-utils'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Normalize the value with its schema.\n *\n * @param {Change} change\n */\n\nChanges.normalize = (change, options) => {\n  change.normalizeDocument(options)\n}\n\n/**\n * Normalize the document with the value's schema.\n *\n * @param {Change} change\n */\n\nChanges.normalizeDocument = (change, options) => {\n  const { value } = change\n  const { document } = value\n  change.normalizeNodeByKey(document.key, options)\n}\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Node|String} key\n */\n\nChanges.normalizeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  if (!normalize) return\n\n  const { value } = change\n  const { document, schema } = value\n  const node = document.assertNode(key)\n\n  normalizeNodeAndChildren(change, node, schema)\n\n  change.normalizeAncestorsByKey(key)\n}\n\n/**\n * Normalize a node's ancestors by `key`.\n *\n * @param {Change} change\n * @param {String} key\n */\n\nChanges.normalizeAncestorsByKey = (change, key) => {\n  const { value } = change\n  const { document, schema } = value\n  const ancestors = document.getAncestors(key)\n  if (!ancestors) return\n\n  ancestors.forEach(ancestor => {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema)\n    }\n  })\n}\n\nChanges.normalizeParentByKey = (change, key, options) => {\n  const { value } = change\n  const { document } = value\n  const parent = document.getParent(key)\n  change.normalizeNodeByKey(parent.key, options)\n}\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Array} path\n */\n\nChanges.normalizeNodeByPath = (change, path, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  if (!normalize) return\n\n  const { value } = change\n  let { document, schema } = value\n  const node = document.assertNode(path)\n\n  normalizeNodeAndChildren(change, node, schema)\n\n  document = change.value.document\n  const ancestors = document.getAncestors(path)\n  if (!ancestors) return\n\n  ancestors.forEach(ancestor => {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema)\n    }\n  })\n}\n\nChanges.normalizeParentByPath = (change, path, options) => {\n  const p = PathUtils.lift(path)\n  change.normalizeNodeByPath(p, options)\n}\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(change, node, schema) {\n  if (node.object == 'text') {\n    normalizeNode(change, node, schema)\n    return\n  }\n\n  let child = node.getFirstInvalidDescendant(schema)\n  let path = change.value.document.getPath(node.key)\n\n  while (node && child) {\n    normalizeNodeAndChildren(change, child, schema)\n    node = change.value.document.refindNode(path, node.key)\n\n    if (!node) {\n      path = []\n      child = null\n    } else {\n      path = change.value.document.refindPath(path, node.key)\n      child = node.getFirstInvalidDescendant(schema)\n    }\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(change, node, schema)\n  }\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(change, node, schema) {\n  const max = schema.stack.plugins.length + schema.rules.length + 1\n  let iterations = 0\n\n  function iterate(c, n) {\n    const normalize = n.normalize(schema)\n    if (!normalize) return\n\n    // Run the `normalize` function to fix the node.\n    let path = c.value.document.getPath(n.key)\n    normalize(c)\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = c.value.document.refindNode(path, n.key)\n    if (!n) return\n\n    path = c.value.document.refindPath(path, n.key)\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n\n    // Otherwise, iterate again.\n    iterate(c, n)\n  }\n\n  iterate(change, node)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import AtCurrentRange from './at-current-range'\nimport AtRange from './at-range'\nimport ByPath from './by-path'\nimport OnHistory from './on-history'\nimport OnSelection from './on-selection'\nimport OnValue from './on-value'\nimport WithSchema from './with-schema'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  ...AtCurrentRange,\n  ...AtRange,\n  ...ByPath,\n  ...OnHistory,\n  ...OnSelection,\n  ...OnValue,\n  ...WithSchema,\n}\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'add_mark': {\n      const { path, offset, length, mark } = op\n      const next = value.addMark(path, offset, length, mark)\n      return next\n    }\n\n    case 'insert_node': {\n      const { path, node } = op\n      const next = value.insertNode(path, node)\n      return next\n    }\n\n    case 'insert_text': {\n      const { path, offset, text, marks } = op\n      const next = value.insertText(path, offset, text, marks)\n      return next\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const next = value.mergeNode(path)\n      return next\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n      const next = value.moveNode(path, newPath)\n      return next\n    }\n\n    case 'remove_mark': {\n      const { path, offset, length, mark } = op\n      const next = value.removeMark(path, offset, length, mark)\n      return next\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const next = value.removeNode(path)\n      return next\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      const next = value.removeText(path, offset, text)\n      return next\n    }\n\n    case 'set_mark': {\n      const { path, offset, length, mark, properties } = op\n      const next = value.setMark(path, offset, length, mark, properties)\n      return next\n    }\n\n    case 'set_node': {\n      const { path, properties } = op\n      const next = value.setNode(path, properties)\n      return next\n    }\n\n    case 'set_selection': {\n      const { properties } = op\n      const next = value.setSelection(properties)\n      return next\n    }\n\n    case 'set_value': {\n      const { properties } = op\n      const next = value.merge(properties)\n      return next\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n      const next = value.splitNode(path, position, properties)\n      return next\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from 'slate-dev-logger'\nimport pick from 'lodash/pick'\nimport { List } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Changes from '../changes'\nimport Operation from './operation'\nimport apply from '../operations/apply'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:change')\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change {\n  /**\n   * Check if `any` is a `Change`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isChange = isType.bind(null, 'CHANGE')\n\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  constructor(attrs) {\n    const { value } = attrs\n    this.value = value\n    this.operations = new List()\n\n    this.flags = {\n      normalize: true,\n      ...pick(attrs, ['merge', 'save', 'normalize']),\n    }\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'change'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Apply an `operation` to the current value, saving the operation to the\n   * history if needed.\n   *\n   * @param {Operation|Object} operation\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperation(operation, options = {}) {\n    const { operations, flags } = this\n    let { value } = this\n    let { history } = value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Default options to the change-level flags, this allows for setting\n    // specific options for all of the operations of a given change.\n    options = { ...flags, ...options }\n\n    // Derive the default option values.\n    const {\n      merge = operations.size == 0 ? null : true,\n      save = true,\n      skip = null,\n    } = options\n\n    // Apply the operation to the value.\n    debug('apply', { operation, save, merge })\n    value = apply(value, operation)\n\n    // If needed, save the operation to the history.\n    if (history && save) {\n      history = history.save(operation, { merge, skip })\n      value = value.set('history', history)\n    }\n\n    // Update the mutable change object.\n    this.value = value\n    this.operations = operations.push(operation)\n    return this\n  }\n\n  /**\n   * Apply a series of `operations` to the current value.\n   *\n   * @param {Array|List} operations\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperations(operations, options) {\n    operations.forEach(op => this.applyOperation(op, options))\n    return this\n  }\n\n  /**\n   * Call a change `fn` with arguments.\n   *\n   * @param {Function} fn\n   * @param {Mixed} ...args\n   * @return {Change}\n   */\n\n  call(fn, ...args) {\n    fn(this, ...args)\n    return this\n  }\n\n  /**\n   * Applies a series of change mutations, deferring normalization to the end.\n   *\n   * @param {Function} fn\n   * @return {Change}\n   */\n\n  withoutNormalization(fn) {\n    const original = this.flags.normalize\n    this.setOperationFlag('normalize', false)\n    fn(this)\n    this.setOperationFlag('normalize', original)\n    this.normalizeDocument()\n    return this\n  }\n\n  /**\n   * Set an operation flag by `key` to `value`.\n   *\n   * @param {String} key\n   * @param {Any} value\n   * @return {Change}\n   */\n\n  setOperationFlag(key, value) {\n    this.flags[key] = value\n    return this\n  }\n\n  /**\n   * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`\n   * object with override flags.\n   *\n   * @param {String} key\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  getFlag(key, options = {}) {\n    return options[key] !== undefined ? options[key] : this.flags[key]\n  }\n\n  /**\n   * Unset an operation flag by `key`.\n   *\n   * @param {String} key\n   * @return {Change}\n   */\n\n  unsetOperationFlag(key) {\n    delete this.flags[key]\n    return this\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nChange.prototype[MODEL_TYPES.CHANGE] = true\n\n/**\n * Add a change method for each of the changes.\n */\n\nObject.keys(Changes).forEach(type => {\n  Change.prototype[type] = function(...args) {\n    debug(type, { args })\n    this.call(Changes[type], ...args)\n    return this\n  }\n})\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","import apply from './apply'\nimport invert from './invert'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  apply,\n  invert,\n}\n","import KeyUtils from './key-utils'\nimport logger from 'slate-dev-logger'\n\nfunction generateKey() {\n  logger.deprecate(\n    `0.35.0`,\n    'The `generateKey()` util is deprecrated. Use the `KeyUtils.create()` helper instead.'\n  )\n\n  return KeyUtils.create()\n}\n\nfunction setKeyGenerator(fn) {\n  logger.deprecate(\n    `0.35.0`,\n    'The `setKeyGenerator()` util is deprecrated. Use the `KeyUtils.setGenerator()` helper instead.'\n  )\n\n  return KeyUtils.setGenerator(fn)\n}\n\nfunction resetKeyGenerator() {\n  logger.deprecate(\n    `0.35.0`,\n    'The `resetKeyGenerator()` util is deprecrated. Use the `KeyUtils.resetGenerator()` helper instead.'\n  )\n\n  return KeyUtils.resetGenerator()\n}\n\nexport default generateKey\nexport { setKeyGenerator, resetKeyGenerator }\n","import Block from './models/block'\nimport Change from './models/change'\nimport Changes from './changes'\nimport Character from './models/character'\nimport Data from './models/data'\nimport Document from './models/document'\nimport History from './models/history'\nimport Inline from './models/inline'\nimport KeyUtils from './utils/key-utils'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport Operations from './operations'\nimport PathUtils from './utils/path-utils'\nimport Range from './models/range'\nimport Schema from './models/schema'\nimport Stack from './models/stack'\nimport Text from './models/text'\nimport TextUtils from './utils/text-utils'\nimport Value from './models/value'\nimport { resetKeyGenerator, setKeyGenerator } from './utils/generate-key'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Block,\n  Change,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  PathUtils,\n  Range,\n  resetKeyGenerator,\n  resetMemoization,\n  Schema,\n  setKeyGenerator,\n  Stack,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n\nexport default {\n  Block,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  PathUtils,\n  Range,\n  resetKeyGenerator,\n  resetMemoization,\n  Schema,\n  setKeyGenerator,\n  Stack,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n"],"names":["MODEL_TYPES","isType","type","any","n","generate","create","key","Error","setGenerator","func","resetGenerator","DEFAULTS","Map","undefined","List","Block","options","object","isVoid","data","toJSON","nodes","toArray","map","preserveKeys","deprecate","some","child","isEmpty","getText","attrs","isBlock","isPlainObject","fromJSON","isList","Array","isArray","list","KeyUtils","block","createChildren","every","item","Record","fromJS","bind","prototype","BLOCK","Inline","isInline","elements","inline","INLINE","Data","isMap","ENABLED","CACHE_KEY","LEAF","UNDEFINED","UNSET","memoize","properties","property","original","args","apply","__cache_key","__cache","__cache_no_args","takesArguments","length","cachedValue","keys","getIn","value","v","setIn","get","parent","set","resetMemoization","Number","MAX_SAFE_INTEGER","useMemoization","enabled","Mark","schema","__getComponent","isMark","Set","isSet","marks","props","mark","MARK","Changes","PROXY_TRANSFORMS","forEach","method","change","selection","methodAtRange","match","collapseToStart","collapseToEnd","setBlock","setBlocks","setInline","setInlines","addMark","document","isExpanded","addMarkAtRange","add","sel","select","getActiveMarksAtRange","addMarks","delete","deleteAtRange","insertBlock","insertBlockAtRange","node","getNode","collapseToEndOf","insertFragment","fragment","size","startText","endText","startInline","lastText","getLastText","lastInline","getClosestInline","firstChild","first","lastChild","last","getTexts","text","isAppending","hasEdgeAtStartOf","hasEdgeAtEndOf","isInserting","hasBlockChildren","insertFragmentAtRange","newTexts","filter","includes","newText","takeLast","collapseToStartOf","move","insertInline","insertInlineAtRange","insertText","getInsertMarksAtRange","insertTextAtRange","splitBlock","depth","splitBlockAtRange","removeMark","removeMarkAtRange","remove","replaceMark","oldMark","newMark","toggleMark","exists","activeMarks","has","wrapText","prefix","suffix","wrapTextAtRange","isCollapsed","moveStart","moveEnd","isForward","flip","Document","isDocument","DOCUMENT","compare","a","b","i","av","bv","crop","min","ca","slice","cb","decrement","path","index","increment","newValue","newPath","isAbove","target","p","t","isAfter","isBefore","lift","max","Math","relate","array","push","Range","anchorOffset","getFirstText","anchorKey","start","end","hasAnchorIn","hasDescendant","focusKey","focusOffset","hasFocusIn","hasAnchorAtStartOf","hasAnchorAtEndOf","merge","focusPath","anchorPath","isBackward","offset","isAnchor","isFocus","equals","moveAnchorOffsetTo","moveFocusOffsetTo","moveFocusTo","moveAnchorTo","range","moveAnchorToStartOf","moveFocusToEndOf","anchorOffsetType","focusOffsetType","warn","anchorNode","focusNode","getPath","anchorText","getTextAtOffset","getOffset","focusText","result","PathUtils","isAtomic","isFocused","m","isRange","createSet","obj","RANGE","MOVE_METHODS","s","EDGE_METHODS","hasEdge","anchor","focus","ALIAS_METHODS","alias","Character","isCharacter","split","character","CHARACTER","Leaf","characters","createList","char","newMarks","withMutations","union","isLeaf","leaves","invalid","findLast","leaf","firstLeaf","cache","unshift","endOffset","left","right","find","startOffset","of","take","skip","Text","reduce","string","l","newFirst","splitLeaves","before","bundle","middle","after","concat","x","setLeaves","__getDecorations","decorations","startKey","endKey","hasStart","hasEnd","createLeaves","getActiveMarks","leafEnd","leafStart","intersect","c","getMarks","getMarksAsArray","OrderedSet","searchLeafAtOffset","delta","beforeText","afterText","nextLeaves","splice","getLeaves","r","updateMark","splitted","one","two","regenerateKey","normalizeNode","validateNode","validate","getString","flatMap","getCharacters","isText","ranges","TEXT","Node","assertDescendant","resolvePath","ret","replaceNode","iterator","matches","forEachDescendant","found","normalize","isUnset","getMarksAtPosition","toSet","getDescendant","getPreviousText","getNextText","getActiveMarksBetweenOffsets","startMarks","endMarks","ancestors","current","getBlocksAsArray","isLeafBlock","getBlocksAtRangeAsArray","startBlock","getClosestBlock","endBlock","blocks","indexOf","getBlocksByTypeAsArray","getTextsAtRange","getAncestors","closest","getClosest","stack","startAt","descendant","getFirstInvalidDescendant","startPath","endPath","targetPath","targetPosition","mode","splitNode","startIndex","endIndex","furthest","getFurthest","rest","reverse","takeUntil","getInlinesAsArray","isLeafInline","getInlinesAtRangeAsArray","getTextsAtRangeAsArray","getInlinesByTypeAsArray","inlines","getMarksAtIndex","nested","getKeysToPathsTable","currentMarks","closestBlock","previous","getOrderedMarksAtRange","getMarksByTypeAsArray","memo","next","sibling","getNextNode","getFurthestAncestor","hasChild","getOrderedMarksBetweenPositions","getMarksBetweenOffsets","texts","getTextsBetweenPositionsAsArray","parentPath","dict","getPreviousNode","isSelected","dir","direction","getTextsAsArray","getChild","getClosestVoid","assertNode","mapDescendants","withPath","newNode","mergeText","removeNode","insertNode","newIndex","newParentPath","np","position","deep","deleteIn","removeText","splitText","befores","afters","getKeysAsArray","second","k","firstIndex","secondIndex","isNode","kind","ASSERTS","Object","getOwnPropertyNames","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","remaining","test","charAt","getCharLength","charCodeAt","getCharOffset","getCharOffsetBackward","getCharOffsetForward","getWordOffset","started","getWordOffsetBackward","o","getWordOffsetForward","getFlag","addMarkByKey","addMarksAtRange","snapshotSelection","isStartVoid","hasVoidParent","isEndVoid","isHanging","prevText","startVoid","nextText","removeNodeByKey","endVoid","removeTextByKey","startLength","endLength","ancestor","getCommonAncestor","startChild","endChild","startParent","getParent","startParentIndex","endParentIndex","startChildIndex","endChildIndex","middles","lonely","getFurthestOnlyChildAncestor","moveNodeByKey","mergeNodeByKey","normalizeNodeByKey","deleteCharBackwardAtRange","TextUtils","deleteBackwardAtRange","deleteLineBackwardAtRange","deleteWordBackwardAtRange","voidParent","isAtStartOf","prev","prevBlock","prevVoid","traversed","deleteCharForwardAtRange","deleteForwardAtRange","deleteLineForwardAtRange","deleteWordForwardAtRange","nextBlock","getNextBlock","moveToStartOf","isAtEndOf","nextVoid","extra","insertNodeByKey","atEnd","siblingText","splitRange","moveToEndOf","splitDescendantsByKey","collapseTo","isAtStart","getBlocks","firstBlock","lastBlock","lonelyParent","lonelyChild","nextChild","getNextSibling","nextNodes","skipUntil","lastIndex","inlineChild","inlineIndex","splitNodeByKey","insertTextByKey","commonAncestor","normalizeAncestor","normalizeKey","removeMarkByKey","setBlocksAtRange","getBlocksAtRange","sets","setNodeByKey","setBlockAtRange","setInlinesAtRange","getInlinesAtRange","setInlineAtRange","height","h","splitInlineAtRange","Infinity","toggleMarkAtRange","unwrapBlockAtRange","createProperties","wrappers","isSuperset","toOrderedSet","toList","children","firstMatch","lastMatch","firstText","normalizeDocument","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","inlinekey","rng","startInner","startInnerIndex","endInner","startInlines","endInlines","startNode","endNode","addMarkByPath","operations","bx","by","ax","ay","applyOperations","normalizeParentByPath","insertFragmentByPath","insertNodeByPath","normalizeNodeByPath","applyOperation","insertTextByPath","mergeNodeByPath","getPreviousSibling","moveNodeByPath","ancestorPath","removeMarkByPath","removeAllMarksByPath","state","removeNodeByPath","setTextByPath","replaceTextByPath","removeTextByPath","activeMark","removals","replaceNodeByPath","setMarkByPath","setNodeByPath","splitNodeByPath","splitDescendantsByPath","textPath","textOffset","prevIndex","unwrapInlineByPath","moveToRangeOf","unwrapBlockByPath","unwrapNodeByPath","parentIndex","grandPath","isFirst","isLast","updatedPath","wrapBlockByPath","wrapInlineByPath","wrapNodeByPath","CHANGES","assertPath","newKey","textKey","debug","Debug","Stack","History","operation","history","undos","redos","prevBatch","peek","prevOperation","shouldSkip","shouldMerge","batch","pop","isHistory","createOperationsList","HISTORY","isEqual","plugins","plugin","getPluginsWith","reduceRight","STACK","SlateError","captureStackTrace","constructor","CORE_RULES","error","Schema","rules","testRules","failure","validateRules","rule","isSchema","SCHEMA","defaultNormalize","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","CHILD_UNKNOWN","FIRST_CHILD_OBJECT_INVALID","FIRST_CHILD_TYPE_INVALID","LAST_CHILD_OBJECT_INVALID","LAST_CHILD_TYPE_INVALID","CHILD_REQUIRED","NODE_TEXT_INVALID","PARENT_OBJECT_INVALID","PARENT_TYPE_INVALID","NODE_DATA_INVALID","NODE_IS_VOID_INVALID","NODE_MARK_INVALID","validateObject","validateType","validateIsVoid","validateData","validateMarks","validateText","validateFirst","validateLast","validateNodes","objects","fail","NODE_OBJECT_INVALID","types","NODE_TYPE_INVALID","fn","valid","def","replace","defs","nextDef","shift","rewind","err","validateParent","validatePrevious","validateNext","Value","Change","mapRanges","clearAtomicRanges","moveAnchor","moveFocus","newDocument","mergeNode","moveNode","hasNode","moveStartTo","deselect","moveEndTo","rangeOffset","setNode","setMark","decoration","preserveData","preserveDecorations","d","preserveHistory","preserveSelection","preserveSchema","isBlurred","getPreviousBlock","getNextInline","getPreviousInline","getCharactersAtRange","getMarksAtRange","getFragmentAtRange","isValue","save","VALUE","OPERATION_ATTRIBUTES","Operation","json","ATTRIBUTES","toJS","isOperation","OPERATION","invertOperation","op","inverse","inversePath","inverseNewPath","pathLast","newPathLast","e","inverseNode","inverseProperties","pick","inverseMark","inverseSelection","inverseProps","inverseValue","redo","omit","undo","invert","snapshot","is","hasOwnProperty","selectAll","moveAnchorCharBackward","anchorBlock","previousText","isInVoid","isPreviousInVoid","moveAnchorToEndOf","moveAnchorCharForward","isNextInVoid","moveFocusCharBackward","focusBlock","moveFocusCharForward","moveFocusToStartOf","MOVE_DIRECTIONS","collapse","PREFIXES","DIRECTIONS","OBJECTS","edges","edge","getDirectionNode","directionKey","setValue","normalizeAncestorsByKey","normalizeParentByKey","normalizeNodeAndChildren","refindNode","refindPath","iterations","iterate","AtCurrentRange","AtRange","ByPath","OnHistory","OnSelection","OnValue","WithSchema","setSelection","flags","setOperationFlag","isChange","CHANGE","call","setKeyGenerator","resetKeyGenerator"],"mappings":"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"}