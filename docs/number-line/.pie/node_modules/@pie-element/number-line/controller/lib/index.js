'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.outcome = outcome;
exports.normalize = normalize;
exports.model = model;

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _omitBy = require('lodash/omitBy');

var _omitBy2 = _interopRequireDefault(_omitBy);

var _feedback = require('@pie-lib/feedback');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const score = number => {
  return {
    score: {
      scaled: number
    }
  };
};

const getPartialScore = (corrected, ps) => {
  const correct = corrected.correct;

  const rule = ps.find(r => r.numberOfCorrect === correct.length);

  if (rule) {
    return 1.0 * (rule.scorePercentage / 100);
  } else {
    return 0;
  }
};

function outcome(question, session) {
  session.answer = session.answer || [];

  return new Promise(resolve => {
    const corrected = getCorrected(session.answer, (0, _cloneDeep2.default)(question.correctResponse));
    const correctness = getCorrectness(corrected);

    if (correctness === 'correct') {
      resolve(score(1.0));
    } else if (correctness === 'incorrect') {
      resolve(score(0.0));
    } else if (correctness === 'partial') {
      const allowPartialScoring = question.allowPartialScoring,
            partialScoring = question.partialScoring;

      const ps = (partialScoring || []).filter(o => !(0, _isEmpty2.default)(o));
      const canDoPartialScoring = allowPartialScoring && ps.length > 0;
      if (canDoPartialScoring) {
        resolve(score(getPartialScore(corrected, ps)));
      } else {
        resolve(score(0.0));
      }
    } else {
      resolve({ score: { scaled: -1 } });
    }
  });
}

const getCorrected = (answer, correctResponse) => {
  const matches = a => {
    return v => {
      return (0, _isEqual2.default)(a, v);
    };
  };

  return answer.reduce((acc, a, index) => {
    const correct = acc.correct,
          incorrect = acc.incorrect,
          notInAnswer = acc.notInAnswer;


    const match = (0, _find2.default)(notInAnswer, matches(a));

    if (match) {
      correct.push(index);
      notInAnswer.splice(notInAnswer.indexOf(match), 1);
    } else {
      incorrect.push(index);
    }

    return {
      correct: correct,
      incorrect: incorrect,
      notInAnswer: notInAnswer
    };
  }, {
    correct: [],
    incorrect: [],
    notInAnswer: correctResponse
  });
};

const getCorrectness = corrected => {
  const incorrect = corrected.incorrect,
        correct = corrected.correct,
        notInAnswer = corrected.notInAnswer;


  if (incorrect.length === 0 && correct.length === 0) {
    return 'unanswered';
  }

  if (incorrect.length === 0 && notInAnswer.length === 0) {
    return 'correct';
  }

  if (incorrect.length > 0 || notInAnswer.length > 0) {
    if (correct.length > 0) {
      return 'partial';
    } else {
      return 'incorrect';
    }
  }

  return 'unknown';
};

const feedbackDefaults = {
  correct: {
    type: 'default',
    default: 'Correct'
  },
  incorrect: {
    type: 'default',
    default: 'Incorrect'
  },
  partial: {
    type: 'default',
    default: 'Nearly'
  }
};

/**
 * A sample of a normalize function see:
 * https://github.com/pie-framework/pie-elements/issues/21
 */
function normalize(question) {
  return new Promise(resolve => {
    const feedback = (0, _merge2.default)(feedbackDefaults, question.feedback);
    if ((0, _isEqual2.default)(feedback, question.feedback)) {
      return resolve(undefined);
    } else {
      question.feedback = feedback;
      resolve(question);
    }
  });
}

function model(question, session, env) {
  if (!question) {
    return Promise.reject(new Error('question is null'));
  }

  return new Promise((resolve, reject) => {
    const config = question.config;

    if (config) {
      const evaluateMode = env.mode === 'evaluate';

      const correctResponse = (0, _cloneDeep2.default)(question.correctResponse);
      const corrected = evaluateMode && getCorrected(session ? session.answer || [] : [], correctResponse);
      const correctness = evaluateMode && getCorrectness(corrected);

      const exhibitOnly = config.exhibitOnly;


      const disabled = env.mode !== 'gather' || exhibitOnly === true;

      const fb = evaluateMode ? (0, _feedback.getFeedbackForCorrectness)(correctness, question.feedback) : Promise.resolve(undefined);

      fb.then(feedbackMessage => {
        const out = {
          config,
          disabled,
          corrected,
          correctResponse: evaluateMode && ['unanswered', 'correct'].indexOf(correctness) === -1 && question.correctResponse,
          feedback: feedbackMessage && {
            type: correctness,
            message: feedbackMessage
          },
          colorContrast: env.accessibility && env.accessibility.colorContrast || 'black_on_white'
        };

        resolve((0, _omitBy2.default)(out, v => !v));
      });
    } else {
      reject(new Error('config is undefined'));
    }
  });
}